diff --git a/libc-test/build.rs b/libc-test/build.rs
index e738b0961..ca1e005ce 100644
--- a/libc-test/build.rs
+++ b/libc-test/build.rs
@@ -53,6 +53,7 @@ fn do_ctest() {
         t if t.contains("emscripten") => test_emscripten(t),
         t if t.contains("freebsd") => test_freebsd(t),
         t if t.contains("haiku") => test_haiku(t),
+        t if t.contains("l4re") => test_linux(t),
         t if t.contains("linux") => test_linux(t),
         t if t.contains("netbsd") => test_netbsd(t),
         t if t.contains("openbsd") => test_openbsd(t),
@@ -94,9 +95,10 @@ fn do_semver() {
     // NOTE: Android doesn't include the unix file (or the Linux file) because
     // there are some many definitions missing it's actually easier just to
     // maintain a file for Android.
-    // NOTE: AIX doesn't include the unix file because there are definitions
-    // missing on AIX. It is easier to maintain a file for AIX.
-    if family != os && !matches!(os.as_str(), "android" | "aix") {
+    // NOTE: AIX and L4Re do not include the unix file because there are
+    // definitions missing on these systems. It is easier to maintain separate
+    // files for them.
+    if family != os && !matches!(os.as_str(), "android" | "aix" | "l4re") {
         process_semver_file(&mut output, &mut semver_root, &family);
     }
     // We don't do semver for unknown targets.
@@ -3570,18 +3572,26 @@ fn config_gnu_bits(target: &str, cfg: &mut ctest::TestGenerator) {
 }
 
 fn test_linux(target: &str) {
-    assert!(target.contains("linux"));
+    assert!(target.contains("linux") || target.contains("l4re"));
+
+    // target_os
+    let linux = target.contains("linux");
+    let l4re = target.contains("l4re");
 
     // target_env
     let gnu = target.contains("gnu");
     let musl = target.contains("musl") || target.contains("ohos");
     let uclibc = target.contains("uclibc");
 
-    match (gnu, musl, uclibc) {
-        (true, false, false) => (),
-        (false, true, false) => (),
-        (false, false, true) => (),
-        (_, _, _) => panic!("linux target lib is gnu: {gnu}, musl: {musl}, uclibc: {uclibc}"),
+    match (linux, gnu, musl, uclibc) {
+        (true, true, false, false) => (),
+        (true, false, true, false) => (),
+        (true, false, false, true) => (),
+        (false, false, false, true) => (),
+        (_, _, _, _) => panic!(
+            "{} target lib is gnu: {gnu}, musl: {musl}, uclibc: {uclibc}",
+            if linux { "linux" } else { "l4re" }
+        ),
     }
 
     let arm = target.contains("arm");
@@ -3616,6 +3626,9 @@ fn test_linux(target: &str) {
         .define("__GLIBC_USE_DEPRECATED_SCANF", None);
 
     config_gnu_bits(target, &mut cfg);
+    if l4re {
+        cfg.flag("-Wno-unused-function");
+    }
 
     headers! { cfg:
                "ctype.h",
@@ -3634,11 +3647,12 @@ fn test_linux(target: &str) {
                "libgen.h",
                "limits.h",
                "link.h",
-               "linux/sysctl.h",
+               [uclibc]: "linux/if_ether.h",
+               [!l4re]: "linux/sysctl.h",
                "locale.h",
                "malloc.h",
                "mntent.h",
-               "mqueue.h",
+               [!l4re]: "mqueue.h",
                "net/ethernet.h",
                "net/if.h",
                "net/if_arp.h",
@@ -3648,6 +3662,7 @@ fn test_linux(target: &str) {
                "netinet/ip.h",
                "netinet/tcp.h",
                "netinet/udp.h",
+               [l4re]: "netpacket/packet.h",
                "poll.h",
                "pthread.h",
                "pty.h",
@@ -3658,43 +3673,44 @@ fn test_linux(target: &str) {
                "semaphore.h",
                "shadow.h",
                "signal.h",
-               "spawn.h",
-               "stddef.h",
+               [!l4re]: "spawn.h",
+               [!l4re]: "stddef.h",
                "stdint.h",
                "stdio.h",
                "stdlib.h",
                "string.h",
-               "sys/epoll.h",
-               "sys/eventfd.h",
+               [l4re]: "sys/auxv.h",
+               [!l4re]: "sys/epoll.h",
+               [!l4re]: "sys/eventfd.h",
                "sys/file.h",
-               "sys/fsuid.h",
-               "sys/klog.h",
-               "sys/inotify.h",
+               [!l4re]: "sys/fsuid.h",
+               [!l4re]: "sys/klog.h",
+               [!l4re]: "sys/inotify.h",
                "sys/ioctl.h",
                "sys/ipc.h",
                "sys/mman.h",
                "sys/mount.h",
-               "sys/msg.h",
-               "sys/personality.h",
+               [!l4re]: "sys/msg.h",
+               [!l4re]: "sys/personality.h",
                "sys/prctl.h",
-               "sys/ptrace.h",
-               "sys/quota.h",
-               "sys/random.h",
-               "sys/reboot.h",
+               [!l4re]: "sys/ptrace.h",
+               [!l4re]: "sys/quota.h",
+               [!l4re]: "sys/random.h",
+               [!l4re]: "sys/reboot.h",
                "sys/resource.h",
                "sys/sem.h",
-               "sys/sendfile.h",
+               [!l4re]: "sys/sendfile.h",
                "sys/shm.h",
-               "sys/signalfd.h",
+               [!l4re]: "sys/signalfd.h",
                "sys/socket.h",
                "sys/stat.h",
                "sys/statvfs.h",
-               "sys/swap.h",
+               [!l4re]: "sys/swap.h",
                "sys/syscall.h",
                "sys/time.h",
-               "sys/timerfd.h",
+               [!l4re]: "sys/timerfd.h",
                "sys/times.h",
-               "sys/timex.h",
+               [!l4re]: "sys/timex.h",
                "sys/types.h",
                "sys/uio.h",
                "sys/un.h",
@@ -3716,12 +3732,12 @@ fn test_linux(target: &str) {
                // ARM: https://bugzilla.redhat.com/show_bug.cgi?id=1116162
                // Also unavailable on gnueabihf with glibc 2.30.
                // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=6b33f373c7b9199e00ba5fbafd94ac9bfb4337b1
-               [(x86_64 || x86_32 || arm) && !gnueabihf]: "sys/io.h",
+               [(x86_64 || x86_32 || arm) && !gnueabihf && !l4re]: "sys/io.h",
                // `sys/reg.h` is only available on x86 and x86_64
-               [x86_64 || x86_32]: "sys/reg.h",
+               [(x86_64 || x86_32) && !l4re]: "sys/reg.h",
                // sysctl system call is deprecated and not available on musl
                // It is also unsupported in x32, deprecated since glibc 2.30:
-               [!(x32 || musl || gnu)]: "sys/sysctl.h",
+               [!(x32 || musl || gnu || l4re)]: "sys/sysctl.h",
                // <execinfo.h> is not supported by musl:
                // https://www.openwall.com/lists/musl/2015/04/09/3
                // <execinfo.h> is not present on uclibc.
@@ -3731,11 +3747,11 @@ fn test_linux(target: &str) {
     // Include linux headers at the end:
     headers! {
         cfg:
-        [loongarch64 || riscv64]: "asm/hwcap.h",
-        "asm/mman.h",
+        [(loongarch64 || riscv64) && !l4re]: "asm/hwcap.h",
+        [!l4re]: "asm/mman.h",
     }
 
-    if !wasm32 {
+    if !wasm32 && !l4re {
         headers! { cfg:
             [gnu]: "linux/aio_abi.h",
             "linux/can.h",
@@ -3753,7 +3769,6 @@ fn test_linux(target: &str) {
             "linux/if.h",
             "linux/if_addr.h",
             "linux/if_alg.h",
-            "linux/if_ether.h",
             "linux/if_packet.h",
             "linux/if_tun.h",
             "linux/if_xdp.h",
@@ -3800,7 +3815,6 @@ fn test_linux(target: &str) {
             "linux/wait.h",
             "linux/wireless.h",
             "sys/fanotify.h",
-            // <sys/auxv.h> is not present on uclibc
             [!uclibc]: "sys/auxv.h",
             [gnu || musl]: "linux/close_range.h",
         }
@@ -3809,7 +3823,7 @@ fn test_linux(target: &str) {
     // note: aio.h must be included before sys/mount.h
     headers! {
         cfg:
-        "sys/xattr.h",
+        [!l4re]: "sys/xattr.h",
         "sys/sysinfo.h",
         // AIO is not supported by uclibc:
         [!uclibc]: "aio.h",
@@ -3839,10 +3853,11 @@ fn test_linux(target: &str) {
 
     cfg.rename_type(move |ty| {
         match ty {
-            "Ioctl" if gnu => Some("unsigned long".to_string()),
+            "Ioctl" if gnu || uclibc => Some("unsigned long".to_string()),
             "Ioctl" => Some("int".to_string()),
             // LFS64 types have been removed in musl 1.2.4+
             "off64_t" if musl => Some("off_t".to_string()),
+            "fsword_t" if uclibc => Some("__SWORD_TYPE".to_string()),
             _ => None,
         }
     });
@@ -4098,6 +4113,13 @@ fn test_linux(target: &str) {
 
     cfg.skip_const(move |constant| {
         let name = constant.ident();
+
+        // L4Re requires a min stack size of 64k; that isn't defined in uClibc, but
+        // somewhere in the core libraries. uClibc wants 16k, but that's not enough.
+        if l4re && name == "PTHREAD_STACK_MIN" {
+            return true;
+        }
+
         if !gnu {
             // Skip definitions from the kernel on non-glibc Linux targets.
             // They're libc-independent, so we only need to check them on one
@@ -4277,7 +4299,7 @@ fn test_linux(target: &str) {
 
             // FIXME(musl): on musl the pthread types are defined a little differently
             // - these constants are used by the glibc implementation.
-            n if musl && n.contains("__SIZEOF_PTHREAD") => true,
+            n if (musl || uclibc) && n.contains("__SIZEOF_PTHREAD") => true,
 
             // FIXME(linux): It was extended to 4096 since glibc 2.31 (Linux 5.4).
             // We should do so after a while.
@@ -4867,7 +4889,9 @@ fn test_linux(target: &str) {
 
     ctest::generate_test(&mut cfg, "../src/lib.rs", "ctest_output.rs").unwrap();
 
-    test_linux_like_apis(target);
+    if !l4re {
+        test_linux_like_apis(target);
+    }
 }
 
 // This function tests APIs that are incompatible to test when other APIs
diff --git a/libc-test/semver/l4re.txt b/libc-test/semver/l4re.txt
new file mode 100644
index 000000000..ea50f8f58
--- /dev/null
+++ b/libc-test/semver/l4re.txt
@@ -0,0 +1,2660 @@
+ABDAY_1
+ABDAY_2
+ABDAY_3
+ABDAY_4
+ABDAY_5
+ABDAY_6
+ABDAY_7
+ABMON_1
+ABMON_10
+ABMON_11
+ABMON_12
+ABMON_2
+ABMON_3
+ABMON_4
+ABMON_5
+ABMON_6
+ABMON_7
+ABMON_8
+ABMON_9
+AF_ALG
+AF_APPLETALK
+AF_ASH
+AF_ATMPVC
+AF_ATMSVC
+AF_AX25
+AF_BLUETOOTH
+AF_BRIDGE
+AF_CAIF
+AF_CAN
+AF_DECnet
+AF_ECONET
+AF_IEEE802154
+AF_INET
+AF_INET6
+AF_IPX
+AF_IRDA
+AF_ISDN
+AF_IUCV
+AF_KEY
+AF_LLC
+AF_LOCAL
+AF_NETBEUI
+AF_NETLINK
+AF_NETROM
+AF_NFC
+AF_PACKET
+AF_PHONET
+AF_PPPOX
+AF_RDS
+AF_ROSE
+AF_ROUTE
+AF_RXRPC
+AF_SECURITY
+AF_SNA
+AF_TIPC
+AF_UNIX
+AF_UNSPEC
+AF_VSOCK
+AF_WANPIPE
+AF_X25
+AI_ADDRCONFIG
+AI_ALL
+AI_CANONNAME
+AI_NUMERICHOST
+AI_NUMERICSERV
+AI_PASSIVE
+AI_V4MAPPED
+ALT_DIGITS
+AM_STR
+ARPD_FLUSH
+ARPD_LOOKUP
+ARPD_UPDATE
+ARPHRD_ADAPT
+ARPHRD_APPLETLK
+ARPHRD_ARCNET
+ARPHRD_ASH
+ARPHRD_ATM
+ARPHRD_AX25
+ARPHRD_BIF
+ARPHRD_CAN
+ARPHRD_CHAOS
+ARPHRD_CISCO
+ARPHRD_CSLIP
+ARPHRD_CSLIP6
+ARPHRD_DDCMP
+ARPHRD_DLCI
+ARPHRD_ECONET
+ARPHRD_EETHER
+ARPHRD_ETHER
+ARPHRD_EUI64
+ARPHRD_FCAL
+ARPHRD_FCFABRIC
+ARPHRD_FCPL
+ARPHRD_FCPP
+ARPHRD_FDDI
+ARPHRD_FRAD
+ARPHRD_HDLC
+ARPHRD_HIPPI
+ARPHRD_HWX25
+ARPHRD_IEEE1394
+ARPHRD_IEEE802
+ARPHRD_IEEE80211
+ARPHRD_IEEE80211_PRISM
+ARPHRD_IEEE80211_RADIOTAP
+ARPHRD_IEEE802154
+ARPHRD_IEEE802_TR
+ARPHRD_INFINIBAND
+ARPHRD_IPDDP
+ARPHRD_IPGRE
+ARPHRD_IRDA
+ARPHRD_LAPB
+ARPHRD_LOCALTLK
+ARPHRD_LOOPBACK
+ARPHRD_METRICOM
+ARPHRD_NETROM
+ARPHRD_NONE
+ARPHRD_PIMREG
+ARPHRD_PPP
+ARPHRD_PRONET
+ARPHRD_RAWHDLC
+ARPHRD_ROSE
+ARPHRD_RSRVD
+ARPHRD_SIT
+ARPHRD_SKIP
+ARPHRD_SLIP
+ARPHRD_SLIP6
+ARPHRD_TUNNEL
+ARPHRD_TUNNEL6
+ARPHRD_VOID
+ARPHRD_X25
+ARPOP_InREPLY
+ARPOP_InREQUEST
+ARPOP_NAK
+ARPOP_REPLY
+ARPOP_REQUEST
+ARPOP_RREPLY
+ARPOP_RREQUEST
+ATF_COM
+ATF_DONTPUB
+ATF_MAGIC
+ATF_NETMASK
+ATF_PERM
+ATF_PUBL
+ATF_USETRAILERS
+AT_BASE
+AT_BASE_PLATFORM
+AT_CLKTCK
+AT_EACCESS
+AT_EGID
+AT_EMPTY_PATH
+AT_ENTRY
+AT_EUID
+AT_EXECFD
+AT_EXECFN
+AT_FDCWD
+AT_FLAGS
+AT_GID
+AT_HWCAP
+AT_HWCAP2
+AT_IGNORE
+AT_NOTELF
+AT_NO_AUTOMOUNT
+AT_NULL
+AT_PAGESZ
+AT_PHDR
+AT_PHENT
+AT_PHNUM
+AT_PLATFORM
+AT_RANDOM
+AT_RECURSIVE
+AT_REMOVEDIR
+AT_SECURE
+AT_SYMLINK_FOLLOW
+AT_SYMLINK_NOFOLLOW
+AT_SYSINFO_EHDR
+AT_UID
+B0
+B1000000
+B110
+B115200
+B1152000
+B1200
+B134
+B150
+B1500000
+B1800
+B19200
+B200
+B2000000
+B230400
+B2400
+B2500000
+B300
+B3000000
+B3500000
+B38400
+B4000000
+B460800
+B4800
+B50
+B500000
+B57600
+B576000
+B600
+B75
+B921600
+B9600
+BLKSSZGET
+BOTHER
+BRKINT
+BS0
+BS1
+BSDLY
+BUFSIZ
+BUS_ADRALN
+BUS_ADRERR
+CBAUD
+CBAUDEX
+CLD_CONTINUED
+CLD_DUMPED
+CLD_EXITED
+CLD_KILLED
+CLD_STOPPED
+CLD_TRAPPED
+CLOCAL
+CLOCK_BOOTTIME
+CLOCK_BOOTTIME_ALARM
+CLOCK_MONOTONIC
+CLOCK_MONOTONIC_COARSE
+CLOCK_MONOTONIC_RAW
+CLOCK_PROCESS_CPUTIME_ID
+CLOCK_REALTIME
+CLOCK_REALTIME_ALARM
+CLOCK_REALTIME_COARSE
+CLOCK_TAI
+CLOCK_THREAD_CPUTIME_ID
+CLONE_CHILD_CLEARTID
+CLONE_CHILD_SETTID
+CLONE_DETACHED
+CLONE_FILES
+CLONE_FS
+CLONE_IO
+CLONE_NEWIPC
+CLONE_NEWNET
+CLONE_NEWNS
+CLONE_NEWPID
+CLONE_NEWUSER
+CLONE_NEWUTS
+CLONE_PARENT
+CLONE_PARENT_SETTID
+CLONE_PTRACE
+CLONE_SETTLS
+CLONE_SIGHAND
+CLONE_SYSVSEM
+CLONE_THREAD
+CLONE_UNTRACED
+CLONE_VFORK
+CLONE_VM
+CMSG_DATA
+CMSG_FIRSTHDR
+CMSG_LEN
+CMSG_NXTHDR
+CMSG_SPACE
+CMSPAR
+CODESET
+CPU_ALLOC_SIZE
+CPU_CLR
+CPU_COUNT
+CPU_COUNT_S
+CPU_EQUAL
+CPU_ISSET
+CPU_SET
+CPU_SETSIZE
+CPU_ZERO
+CR0
+CR1
+CR2
+CR3
+CRDLY
+CREAD
+CRNCYSTR
+CRTSCTS
+CS5
+CS6
+CS7
+CS8
+CSIZE
+CSTOPB
+DAY_1
+DAY_2
+DAY_3
+DAY_4
+DAY_5
+DAY_6
+DAY_7
+DIR
+DT_BLK
+DT_CHR
+DT_DIR
+DT_FIFO
+DT_LNK
+DT_REG
+DT_SOCK
+DT_UNKNOWN
+D_FMT
+D_T_FMT
+Dl_info
+E2BIG
+EACCES
+EADDRINUSE
+EADDRNOTAVAIL
+EADV
+EAFNOSUPPORT
+EAGAIN
+EAI_AGAIN
+EAI_BADFLAGS
+EAI_FAIL
+EAI_FAMILY
+EAI_MEMORY
+EAI_NODATA
+EAI_NONAME
+EAI_OVERFLOW
+EAI_SERVICE
+EAI_SOCKTYPE
+EAI_SYSTEM
+EALREADY
+EBADE
+EBADF
+EBADFD
+EBADMSG
+EBADR
+EBADRQC
+EBADSLT
+EBFONT
+EBUSY
+ECANCELED
+ECHILD
+ECHO
+ECHOCTL
+ECHOE
+ECHOK
+ECHOKE
+ECHONL
+ECHOPRT
+ECHRNG
+ECOMM
+ECONNABORTED
+ECONNREFUSED
+ECONNRESET
+EDEADLK
+EDEADLOCK
+EDESTADDRREQ
+EDOM
+EDOTDOT
+EDQUOT
+EEXIST
+EFAULT
+EFBIG
+EHOSTDOWN
+EHOSTUNREACH
+EIDRM
+EILSEQ
+EINPROGRESS
+EINTR
+EINVAL
+EIO
+EISCONN
+EISDIR
+EISNAM
+EI_ABIVERSION
+EI_CLASS
+EI_DATA
+EI_MAG0
+EI_MAG1
+EI_MAG2
+EI_MAG3
+EI_NIDENT
+EI_OSABI
+EI_PAD
+EI_VERSION
+EKEYEXPIRED
+EKEYREJECTED
+EKEYREVOKED
+EL2HLT
+EL2NSYNC
+EL3HLT
+EL3RST
+ELF32_R_INFO
+ELF32_R_SYM
+ELF32_R_TYPE
+ELF64_R_INFO
+ELF64_R_SYM
+ELF64_R_TYPE
+ELFCLASS32
+ELFCLASS64
+ELFCLASSNONE
+ELFCLASSNUM
+ELFDATA2LSB
+ELFDATA2MSB
+ELFDATANONE
+ELFDATANUM
+ELFMAG0
+ELFMAG1
+ELFMAG2
+ELFMAG3
+ELFOSABI_AIX
+ELFOSABI_ARM
+ELFOSABI_FREEBSD
+ELFOSABI_GNU
+ELFOSABI_HPUX
+ELFOSABI_IRIX
+ELFOSABI_LINUX
+ELFOSABI_MODESTO
+ELFOSABI_NETBSD
+ELFOSABI_NONE
+ELFOSABI_OPENBSD
+ELFOSABI_SOLARIS
+ELFOSABI_STANDALONE
+ELFOSABI_SYSV
+ELFOSABI_TRU64
+ELIBACC
+ELIBBAD
+ELIBEXEC
+ELIBMAX
+ELIBSCN
+ELNRNG
+ELOOP
+EMEDIUMTYPE
+EMFILE
+EMLINK
+EMSGSIZE
+EMULTIHOP
+EM_386
+EM_68HC05
+EM_68HC08
+EM_68HC11
+EM_68HC12
+EM_68HC16
+EM_68K
+EM_860
+EM_88K
+EM_960
+EM_AARCH64
+EM_ALPHA
+EM_ARC
+EM_ARM
+EM_AVR
+EM_COLDFIRE
+EM_CRIS
+EM_D10V
+EM_D30V
+EM_FAKE_ALPHA
+EM_FIREPATH
+EM_FR20
+EM_FR30
+EM_FX66
+EM_H8S
+EM_H8_300
+EM_H8_300H
+EM_H8_500
+EM_HUANY
+EM_IA_64
+EM_JAVELIN
+EM_M32
+EM_M32R
+EM_ME16
+EM_MIPS
+EM_MIPS_RS3_LE
+EM_MIPS_X
+EM_MMA
+EM_MMIX
+EM_MN10200
+EM_MN10300
+EM_NCPU
+EM_NDR1
+EM_NONE
+EM_PARISC
+EM_PCP
+EM_PDSP
+EM_PJ
+EM_PPC
+EM_PPC64
+EM_PRISM
+EM_RCE
+EM_RH32
+EM_S370
+EM_S390
+EM_SH
+EM_SPARC
+EM_SPARC32PLUS
+EM_SPARCV9
+EM_ST100
+EM_ST19
+EM_ST7
+EM_ST9PLUS
+EM_STARCORE
+EM_SVX
+EM_TILEGX
+EM_TILEPRO
+EM_TINYJ
+EM_TRICORE
+EM_V800
+EM_V850
+EM_VAX
+EM_VPP500
+EM_X86_64
+EM_XTENSA
+EM_ZSP
+ENAMETOOLONG
+ENAVAIL
+ENETDOWN
+ENETRESET
+ENETUNREACH
+ENFILE
+ENOANO
+ENOBUFS
+ENOCSI
+ENODATA
+ENODEV
+ENOENT
+ENOEXEC
+ENOKEY
+ENOLCK
+ENOLINK
+ENOMEDIUM
+ENOMEM
+ENOMSG
+ENONET
+ENOPKG
+ENOPROTOOPT
+ENOSPC
+ENOSR
+ENOSTR
+ENOSYS
+ENOTBLK
+ENOTCONN
+ENOTDIR
+ENOTEMPTY
+ENOTNAM
+ENOTRECOVERABLE
+ENOTSOCK
+ENOTSUP
+ENOTTY
+ENOTUNIQ
+ENXIO
+EOF
+EOPNOTSUPP
+EOVERFLOW
+EOWNERDEAD
+EPERM
+EPFNOSUPPORT
+EPIPE
+EPROTO
+EPROTONOSUPPORT
+EPROTOTYPE
+ERA
+ERANGE
+ERA_D_FMT
+ERA_D_T_FMT
+ERA_T_FMT
+EREMCHG
+EREMOTE
+EREMOTEIO
+ERESTART
+EROFS
+ESHUTDOWN
+ESOCKTNOSUPPORT
+ESPIPE
+ESRCH
+ESRMNT
+ESTALE
+ESTRPIPE
+ETIME
+ETIMEDOUT
+ETOOMANYREFS
+ETXTBSY
+ET_CORE
+ET_DYN
+ET_EXEC
+ET_HIOS
+ET_HIPROC
+ET_LOOS
+ET_LOPROC
+ET_NONE
+ET_NUM
+ET_REL
+EUCLEAN
+EUNATCH
+EUSERS
+EV_NONE
+EV_NUM
+EWOULDBLOCK
+EXDEV
+EXFULL
+EXIT_FAILURE
+EXIT_SUCCESS
+EXTA
+EXTB
+Elf32_Addr
+Elf32_Ehdr
+Elf32_Half
+Elf32_Off
+Elf32_Phdr
+Elf32_Rel
+Elf32_Rela
+Elf32_Relr
+Elf32_Section
+Elf32_Shdr
+Elf32_Sword
+Elf32_Sym
+Elf32_Word
+Elf32_Xword
+Elf64_Addr
+Elf64_Ehdr
+Elf64_Half
+Elf64_Off
+Elf64_Phdr
+Elf64_Rel
+Elf64_Rela
+Elf64_Relr
+Elf64_Section
+Elf64_Shdr
+Elf64_Sword
+Elf64_Sxword
+Elf64_Sym
+Elf64_Word
+Elf64_Xword
+FD_CLOEXEC
+FD_CLR
+FD_ISSET
+FD_SET
+FD_SETSIZE
+FD_ZERO
+FF0
+FF1
+FFDLY
+FILE
+FILENAME_MAX
+FIOCLEX
+FIONBIO
+FIONCLEX
+FIONREAD
+FIOQSIZE
+FLUSHO
+FNM_CASEFOLD
+FNM_NOESCAPE
+FNM_NOMATCH
+FNM_PATHNAME
+FNM_PERIOD
+FOPEN_MAX
+F_ADD_SEALS
+F_CANCELLK
+F_DUPFD
+F_DUPFD_CLOEXEC
+F_GETFD
+F_GETFL
+F_GETLEASE
+F_GETLK
+F_GETOWN
+F_GETPIPE_SZ
+F_GET_SEALS
+F_LOCK
+F_NOTIFY
+F_OK
+F_SEAL_GROW
+F_SEAL_SEAL
+F_SEAL_SHRINK
+F_SEAL_WRITE
+F_SETFD
+F_SETFL
+F_SETLEASE
+F_SETLK
+F_SETLKW
+F_SETOWN
+F_SETPIPE_SZ
+F_TEST
+F_TLOCK
+F_ULOCK
+F_UNLCK
+F_WRLCK
+GLOB_ABORTED
+GLOB_APPEND
+GLOB_DOOFFS
+GLOB_ERR
+GLOB_MARK
+GLOB_NOCHECK
+GLOB_NOESCAPE
+GLOB_NOMATCH
+GLOB_NOSORT
+GLOB_NOSPACE
+HUPCL
+ICANON
+ICRNL
+IEXTEN
+IFF_AUTOMEDIA
+IFF_BROADCAST
+IFF_DEBUG
+IFF_MASTER
+IFF_MULTICAST
+IFF_POINTOPOINT
+IFF_PORTSEL
+IFF_PROMISC
+IFF_RUNNING
+IFF_SLAVE
+IFNAMSIZ
+IF_NAMESIZE
+IGNBRK
+IGNCR
+IGNPAR
+IN6ADDR_ANY_INIT
+IN6ADDR_LOOPBACK_INIT
+INADDR_ANY
+INADDR_BROADCAST
+INADDR_LOOPBACK
+INADDR_NONE
+INLCR
+INPCK
+INT_MAX
+INT_MIN
+IPC_CREAT
+IPC_EXCL
+IPC_INFO
+IPC_NOWAIT
+IPC_PRIVATE
+IPC_RMID
+IPC_SET
+IPC_STAT
+IPDEFTTL
+IPOPT_CLASS
+IPOPT_CLASS_MASK
+IPOPT_CONTROL
+IPOPT_COPIED
+IPOPT_COPY
+IPOPT_END
+IPOPT_EOL
+IPOPT_LSRR
+IPOPT_MEASUREMENT
+IPOPT_MINOFF
+IPOPT_NOOP
+IPOPT_NOP
+IPOPT_NUMBER
+IPOPT_NUMBER_MASK
+IPOPT_OFFSET
+IPOPT_OLEN
+IPOPT_OPTVAL
+IPOPT_RA
+IPOPT_RESERVED1
+IPOPT_RESERVED2
+IPOPT_RR
+IPOPT_SEC
+IPOPT_SID
+IPOPT_SSRR
+IPOPT_TIMESTAMP
+IPOPT_TS
+IPOPT_TS_PRESPEC
+IPOPT_TS_TSANDADDR
+IPOPT_TS_TSONLY
+IPPROTO_AH
+IPPROTO_COMP
+IPPROTO_DCCP
+IPPROTO_DSTOPTS
+IPPROTO_EGP
+IPPROTO_ENCAP
+IPPROTO_ESP
+IPPROTO_FRAGMENT
+IPPROTO_GRE
+IPPROTO_HOPOPTS
+IPPROTO_ICMP
+IPPROTO_ICMPV6
+IPPROTO_IDP
+IPPROTO_IGMP
+IPPROTO_IP
+IPPROTO_IPIP
+IPPROTO_IPV6
+IPPROTO_MAX
+IPPROTO_MH
+IPPROTO_MTP
+IPPROTO_NONE
+IPPROTO_PIM
+IPPROTO_PUP
+IPPROTO_RAW
+IPPROTO_ROUTING
+IPPROTO_RSVP
+IPPROTO_SCTP
+IPPROTO_TCP
+IPPROTO_TP
+IPPROTO_UDP
+IPPROTO_UDPLITE
+IPTOS_ECN
+IPTOS_ECN_CE
+IPTOS_ECN_ECT0
+IPTOS_ECN_ECT1
+IPTOS_ECN_MASK
+IPTOS_ECN_NOT_ECT
+IPTOS_LOWDELAY
+IPTOS_MINCOST
+IPTOS_PREC
+IPTOS_PREC_CRITIC_ECP
+IPTOS_PREC_FLASH
+IPTOS_PREC_FLASHOVERRIDE
+IPTOS_PREC_IMMEDIATE
+IPTOS_PREC_INTERNETCONTROL
+IPTOS_PREC_MASK
+IPTOS_PREC_NETCONTROL
+IPTOS_PREC_PRIORITY
+IPTOS_PREC_ROUTINE
+IPTOS_RELIABILITY
+IPTOS_THROUGHPUT
+IPTOS_TOS
+IPTOS_TOS_MASK
+IPV6_2292DSTOPTS
+IPV6_2292HOPLIMIT
+IPV6_2292HOPOPTS
+IPV6_2292PKTINFO
+IPV6_2292PKTOPTIONS
+IPV6_2292RTHDR
+IPV6_ADDRFORM
+IPV6_ADD_MEMBERSHIP
+IPV6_AUTHHDR
+IPV6_DROP_MEMBERSHIP
+IPV6_DSTOPTS
+IPV6_HOPLIMIT
+IPV6_HOPOPTS
+IPV6_IPSEC_POLICY
+IPV6_JOIN_ANYCAST
+IPV6_LEAVE_ANYCAST
+IPV6_MTU
+IPV6_MTU_DISCOVER
+IPV6_MULTICAST_HOPS
+IPV6_MULTICAST_IF
+IPV6_MULTICAST_LOOP
+IPV6_PKTINFO
+IPV6_PMTUDISC_DO
+IPV6_PMTUDISC_DONT
+IPV6_PMTUDISC_PROBE
+IPV6_PMTUDISC_WANT
+IPV6_RECVDSTOPTS
+IPV6_RECVERR
+IPV6_RECVHOPLIMIT
+IPV6_RECVHOPOPTS
+IPV6_RECVPKTINFO
+IPV6_RECVRTHDR
+IPV6_RECVTCLASS
+IPV6_ROUTER_ALERT
+IPV6_RTHDR
+IPV6_RTHDRDSTOPTS
+IPV6_RTHDR_LOOSE
+IPV6_RTHDR_STRICT
+IPV6_TCLASS
+IPV6_UNICAST_HOPS
+IPV6_V6ONLY
+IPV6_XFRM_POLICY
+IPVERSION
+IP_ADD_MEMBERSHIP
+IP_ADD_SOURCE_MEMBERSHIP
+IP_DEFAULT_MULTICAST_LOOP
+IP_DEFAULT_MULTICAST_TTL
+IP_DROP_MEMBERSHIP
+IP_DROP_SOURCE_MEMBERSHIP
+IP_FREEBIND
+IP_HDRINCL
+IP_IPSEC_POLICY
+IP_MINTTL
+IP_MSFILTER
+IP_MTU
+IP_MTU_DISCOVER
+IP_MULTICAST_ALL
+IP_MULTICAST_IF
+IP_MULTICAST_LOOP
+IP_MULTICAST_TTL
+IP_OPTIONS
+IP_ORIGDSTADDR
+IP_PASSSEC
+IP_PKTINFO
+IP_PKTOPTIONS
+IP_PMTUDISC_DO
+IP_PMTUDISC_DONT
+IP_PMTUDISC_PROBE
+IP_PMTUDISC_WANT
+IP_RECVERR
+IP_RECVOPTS
+IP_RECVORIGDSTADDR
+IP_RECVTOS
+IP_RECVTTL
+IP_RETOPTS
+IP_ROUTER_ALERT
+IP_TOS
+IP_TRANSPARENT
+IP_TTL
+IP_UNBLOCK_SOURCE
+IP_UNICAST_IF
+IP_XFRM_POLICY
+ISIG
+ISTRIP
+ITIMER_PROF
+ITIMER_REAL
+ITIMER_VIRTUAL
+IUTF8
+IXANY
+IXOFF
+IXON
+LC_COLLATE
+LC_COLLATE_MASK
+LC_CTYPE
+LC_CTYPE_MASK
+LC_MESSAGES
+LC_MESSAGES_MASK
+LC_MONETARY
+LC_MONETARY_MASK
+LC_NUMERIC
+LC_NUMERIC_MASK
+LC_TIME
+LC_TIME_MASK
+LOG_ALERT
+LOG_AUTH
+LOG_AUTHPRIV
+LOG_CONS
+LOG_CRIT
+LOG_CRON
+LOG_DAEMON
+LOG_DEBUG
+LOG_EMERG
+LOG_ERR
+LOG_FACMASK
+LOG_FTP
+LOG_INFO
+LOG_KERN
+LOG_LOCAL0
+LOG_LOCAL1
+LOG_LOCAL2
+LOG_LOCAL3
+LOG_LOCAL4
+LOG_LOCAL5
+LOG_LOCAL6
+LOG_LOCAL7
+LOG_LPR
+LOG_MAIL
+LOG_NDELAY
+LOG_NEWS
+LOG_NFACILITIES
+LOG_NOTICE
+LOG_NOWAIT
+LOG_ODELAY
+LOG_PERROR
+LOG_PID
+LOG_PRIMASK
+LOG_SYSLOG
+LOG_USER
+LOG_UUCP
+LOG_WARNING
+L_tmpnam
+MADV_DODUMP
+MADV_DOFORK
+MADV_DONTDUMP
+MADV_DONTFORK
+MADV_DONTNEED
+MADV_FREE
+MADV_HUGEPAGE
+MADV_HWPOISON
+MADV_KEEPONFORK
+MADV_MERGEABLE
+MADV_NOHUGEPAGE
+MADV_NORMAL
+MADV_RANDOM
+MADV_REMOVE
+MADV_SEQUENTIAL
+MADV_UNMERGEABLE
+MADV_WILLNEED
+MADV_WIPEONFORK
+MAP_ANON
+MAP_ANONYMOUS
+MAP_DENYWRITE
+MAP_EXECUTABLE
+MAP_FAILED
+MAP_FILE
+MAP_FIXED
+MAP_FIXED_NOREPLACE
+MAP_GROWSDOWN
+MAP_HUGETLB
+MAP_HUGE_MASK
+MAP_HUGE_SHIFT
+MAP_LOCKED
+MAP_NONBLOCK
+MAP_NORESERVE
+MAP_POPULATE
+MAP_PRIVATE
+MAP_SHARED
+MAP_STACK
+MAP_TYPE
+MAXTTL
+MAX_ADDR_LEN
+MAX_IPOPTLEN
+MCAST_BLOCK_SOURCE
+MCAST_EXCLUDE
+MCAST_INCLUDE
+MCAST_JOIN_GROUP
+MCAST_JOIN_SOURCE_GROUP
+MCAST_LEAVE_GROUP
+MCAST_LEAVE_SOURCE_GROUP
+MCAST_MSFILTER
+MCAST_UNBLOCK_SOURCE
+MCL_CURRENT
+MCL_FUTURE
+MCL_ONFAULT
+MFD_ALLOW_SEALING
+MFD_CLOEXEC
+MINSIGSTKSZ
+MNT_DETACH
+MNT_EXPIRE
+MNT_FORCE
+MON_1
+MON_10
+MON_11
+MON_12
+MON_2
+MON_3
+MON_4
+MON_5
+MON_6
+MON_7
+MON_8
+MON_9
+MSG_CMSG_CLOEXEC
+MSG_CONFIRM
+MSG_CTRUNC
+MSG_DONTROUTE
+MSG_DONTWAIT
+MSG_EOR
+MSG_ERRQUEUE
+MSG_FASTOPEN
+MSG_FIN
+MSG_OOB
+MSG_PEEK
+MSG_SYN
+MSG_TRUNC
+MSG_WAITALL
+MSG_WAITFORONE
+MS_ACTIVE
+MS_ASYNC
+MS_BIND
+MS_DIRSYNC
+MS_INVALIDATE
+MS_I_VERSION
+MS_KERNMOUNT
+MS_LAZYTIME
+MS_MANDLOCK
+MS_MGC_MSK
+MS_MGC_VAL
+MS_MOVE
+MS_NOATIME
+MS_NODEV
+MS_NODIRATIME
+MS_NOEXEC
+MS_NOSUID
+MS_NOUSER
+MS_POSIXACL
+MS_PRIVATE
+MS_RDONLY
+MS_REC
+MS_REMOUNT
+MS_RMT_MASK
+MS_SHARED
+MS_SILENT
+MS_SLAVE
+MS_STRICTATIME
+MS_SYNC
+MS_SYNCHRONOUS
+MS_UNBINDABLE
+NCCS
+NI_DGRAM
+NI_MAXHOST
+NI_NAMEREQD
+NI_NOFQDN
+NI_NUMERICHOST
+NI_NUMERICSERV
+NL0
+NL1
+NOEXPR
+NOFLSH
+NOSTR
+NT_ASRS
+NT_AUXV
+NT_FPREGSET
+NT_GWINDOWS
+NT_LWPSINFO
+NT_LWPSTATUS
+NT_PLATFORM
+NT_PRCRED
+NT_PRFPXREG
+NT_PRPSINFO
+NT_PRSTATUS
+NT_PSINFO
+NT_PSTATUS
+NT_TASKSTRUCT
+NT_UTSNAME
+OCRNL
+OFDEL
+OFILL
+OLCUC
+ONLCR
+ONLRET
+ONOCR
+OPOST
+O_ACCMODE
+O_APPEND
+O_ASYNC
+O_CLOEXEC
+O_CREAT
+O_DIRECT
+O_DIRECTORY
+O_DSYNC
+O_EXCL
+O_LARGEFILE
+O_NDELAY
+O_NOATIME
+O_NOCTTY
+O_NOFOLLOW
+O_NONBLOCK
+O_PATH
+O_RDONLY
+O_RDWR
+O_RSYNC
+O_SYNC
+O_TMPFILE
+O_TRUNC
+O_WRONLY
+PACKET_ADD_MEMBERSHIP
+PACKET_BROADCAST
+PACKET_DROP_MEMBERSHIP
+PACKET_MR_ALLMULTI
+PACKET_MR_MULTICAST
+PACKET_MR_PROMISC
+PACKET_MULTICAST
+PACKET_OTHERHOST
+PACKET_OUTGOING
+PACKET_RX_RING
+PACKET_STATISTICS
+PARENB
+PARMRK
+PARODD
+PATH_MAX
+PENDIN
+PF_ALG
+PF_APPLETALK
+PF_ASH
+PF_ATMPVC
+PF_ATMSVC
+PF_AX25
+PF_BLUETOOTH
+PF_BRIDGE
+PF_CAIF
+PF_CAN
+PF_DECnet
+PF_INET
+PF_INET6
+PF_IPX
+PF_IRDA
+PF_ISDN
+PF_IUCV
+PF_KEY
+PF_LLC
+PF_LOCAL
+PF_MASKOS
+PF_MASKPROC
+PF_NETBEUI
+PF_NETLINK
+PF_NETROM
+PF_NFC
+PF_PACKET
+PF_PHONET
+PF_PPPOX
+PF_R
+PF_RDS
+PF_ROSE
+PF_ROUTE
+PF_RXRPC
+PF_SECURITY
+PF_UNIX
+PF_UNSPEC
+PF_VSOCK
+PF_W
+PF_WANPIPE
+PF_X
+PF_X25
+PM_STR
+POLLERR
+POLLHUP
+POLLIN
+POLLNVAL
+POLLOUT
+POLLPRI
+POLLRDBAND
+POLLRDNORM
+POLLWRBAND
+POLLWRNORM
+POSIX_FADV_DONTNEED
+POSIX_FADV_NOREUSE
+POSIX_FADV_NORMAL
+POSIX_FADV_RANDOM
+POSIX_FADV_SEQUENTIAL
+POSIX_FADV_WILLNEED
+POSIX_MADV_DONTNEED
+POSIX_MADV_NORMAL
+POSIX_MADV_RANDOM
+POSIX_MADV_SEQUENTIAL
+POSIX_MADV_WILLNEED
+PRIO_MAX
+PRIO_MIN
+PRIO_PGRP
+PRIO_PROCESS
+PRIO_USER
+PROT_EXEC
+PROT_GROWSDOWN
+PROT_GROWSUP
+PROT_NONE
+PROT_READ
+PROT_WRITE
+PR_CAPBSET_DROP
+PR_CAPBSET_READ
+PR_CAP_AMBIENT
+PR_CAP_AMBIENT_CLEAR_ALL
+PR_CAP_AMBIENT_IS_SET
+PR_CAP_AMBIENT_LOWER
+PR_CAP_AMBIENT_RAISE
+PR_ENDIAN_BIG
+PR_ENDIAN_LITTLE
+PR_ENDIAN_PPC_LITTLE
+PR_FPEMU_NOPRINT
+PR_FPEMU_SIGFPE
+PR_FP_EXC_ASYNC
+PR_FP_EXC_DISABLED
+PR_FP_EXC_DIV
+PR_FP_EXC_INV
+PR_FP_EXC_NONRECOV
+PR_FP_EXC_OVF
+PR_FP_EXC_PRECISE
+PR_FP_EXC_RES
+PR_FP_EXC_SW_ENABLE
+PR_FP_EXC_UND
+PR_FP_MODE_FR
+PR_FP_MODE_FRE
+PR_GET_CHILD_SUBREAPER
+PR_GET_DUMPABLE
+PR_GET_ENDIAN
+PR_GET_FPEMU
+PR_GET_FPEXC
+PR_GET_FP_MODE
+PR_GET_KEEPCAPS
+PR_GET_NAME
+PR_GET_NO_NEW_PRIVS
+PR_GET_PDEATHSIG
+PR_GET_SECCOMP
+PR_GET_SECUREBITS
+PR_GET_THP_DISABLE
+PR_GET_TID_ADDRESS
+PR_GET_TIMERSLACK
+PR_GET_TIMING
+PR_GET_TSC
+PR_GET_UNALIGN
+PR_MCE_KILL
+PR_MCE_KILL_CLEAR
+PR_MCE_KILL_DEFAULT
+PR_MCE_KILL_EARLY
+PR_MCE_KILL_GET
+PR_MCE_KILL_LATE
+PR_MCE_KILL_SET
+PR_MPX_DISABLE_MANAGEMENT
+PR_MPX_ENABLE_MANAGEMENT
+PR_SCHED_CORE
+PR_SCHED_CORE_CREATE
+PR_SCHED_CORE_GET
+PR_SCHED_CORE_MAX
+PR_SCHED_CORE_SCOPE_PROCESS_GROUP
+PR_SCHED_CORE_SCOPE_THREAD
+PR_SCHED_CORE_SCOPE_THREAD_GROUP
+PR_SCHED_CORE_SHARE_FROM
+PR_SCHED_CORE_SHARE_TO
+PR_SET_CHILD_SUBREAPER
+PR_SET_DUMPABLE
+PR_SET_ENDIAN
+PR_SET_FPEMU
+PR_SET_FPEXC
+PR_SET_FP_MODE
+PR_SET_KEEPCAPS
+PR_SET_MM
+PR_SET_MM_ARG_END
+PR_SET_MM_ARG_START
+PR_SET_MM_AUXV
+PR_SET_MM_BRK
+PR_SET_MM_END_CODE
+PR_SET_MM_END_DATA
+PR_SET_MM_ENV_END
+PR_SET_MM_ENV_START
+PR_SET_MM_EXE_FILE
+PR_SET_MM_MAP
+PR_SET_MM_MAP_SIZE
+PR_SET_MM_START_BRK
+PR_SET_MM_START_CODE
+PR_SET_MM_START_DATA
+PR_SET_MM_START_STACK
+PR_SET_NAME
+PR_SET_NO_NEW_PRIVS
+PR_SET_PDEATHSIG
+PR_SET_PTRACER
+PR_SET_PTRACER_ANY
+PR_SET_SECCOMP
+PR_SET_SECUREBITS
+PR_SET_THP_DISABLE
+PR_SET_TIMERSLACK
+PR_SET_TIMING
+PR_SET_TSC
+PR_SET_UNALIGN
+PR_TASK_PERF_EVENTS_DISABLE
+PR_TASK_PERF_EVENTS_ENABLE
+PR_TIMING_STATISTICAL
+PR_TIMING_TIMESTAMP
+PR_TSC_ENABLE
+PR_TSC_SIGSEGV
+PR_UNALIGN_NOPRINT
+PR_UNALIGN_SIGBUS
+PTHREAD_BARRIER_SERIAL_THREAD
+PTHREAD_COND_INITIALIZER
+PTHREAD_CREATE_DETACHED
+PTHREAD_CREATE_JOINABLE
+PTHREAD_EXPLICIT_SCHED
+PTHREAD_INHERIT_SCHED
+PTHREAD_MUTEX_DEFAULT
+PTHREAD_MUTEX_ERRORCHECK
+PTHREAD_MUTEX_INITIALIZER
+PTHREAD_MUTEX_NORMAL
+PTHREAD_MUTEX_RECURSIVE
+PTHREAD_ONCE_INIT
+PTHREAD_PROCESS_PRIVATE
+PTHREAD_PROCESS_SHARED
+PTHREAD_RWLOCK_INITIALIZER
+PTHREAD_STACK_MIN
+PT_DYNAMIC
+PT_GNU_EH_FRAME
+PT_GNU_RELRO
+PT_GNU_STACK
+PT_HIOS
+PT_HIPROC
+PT_HISUNW
+PT_INTERP
+PT_LOAD
+PT_LOOS
+PT_LOPROC
+PT_LOSUNW
+PT_NOTE
+PT_NULL
+PT_NUM
+PT_PHDR
+PT_SHLIB
+PT_SUNWBSS
+PT_SUNWSTACK
+PT_TLS
+P_ALL
+P_PGID
+P_PID
+RADIXCHAR
+RAND_MAX
+REG_BADBR
+REG_BADPAT
+REG_BADRPT
+REG_EBRACE
+REG_EBRACK
+REG_ECOLLATE
+REG_ECTYPE
+REG_EESCAPE
+REG_ENOSYS
+REG_EPAREN
+REG_ERANGE
+REG_ESPACE
+REG_ESUBREG
+REG_EXTENDED
+REG_ICASE
+REG_NEWLINE
+REG_NOMATCH
+REG_NOSUB
+REG_NOTBOL
+REG_NOTEOL
+RLIM64_INFINITY
+RLIMIT_AS
+RLIMIT_CORE
+RLIMIT_CPU
+RLIMIT_DATA
+RLIMIT_FSIZE
+RLIMIT_LOCKS
+RLIMIT_MEMLOCK
+RLIMIT_MSGQUEUE
+RLIMIT_NICE
+RLIMIT_NLIMITS
+RLIMIT_NOFILE
+RLIMIT_NPROC
+RLIMIT_RSS
+RLIMIT_RTPRIO
+RLIMIT_RTTIME
+RLIMIT_SIGPENDING
+RLIMIT_STACK
+RLIM_INFINITY
+RLIM_SAVED_CUR
+RLIM_SAVED_MAX
+RTCF_DIRECTSRC
+RTCF_DOREDIRECT
+RTCF_LOG
+RTCF_MASQ
+RTCF_NAT
+RTCF_VALVE
+RTF_ADDRCLASSMASK
+RTF_ADDRCONF
+RTF_ALLONLINK
+RTF_BROADCAST
+RTF_CACHE
+RTF_DEFAULT
+RTF_DYNAMIC
+RTF_FLOW
+RTF_GATEWAY
+RTF_HOST
+RTF_INTERFACE
+RTF_IRTT
+RTF_LINKRT
+RTF_LOCAL
+RTF_MODIFIED
+RTF_MSS
+RTF_MTU
+RTF_MULTICAST
+RTF_NAT
+RTF_NOFORWARD
+RTF_NONEXTHOP
+RTF_NOPMTUDISC
+RTF_POLICY
+RTF_REINSTATE
+RTF_REJECT
+RTF_STATIC
+RTF_THROW
+RTF_UP
+RTF_WINDOW
+RTF_XRESOLVE
+RTLD_DEFAULT
+RTLD_GLOBAL
+RTLD_LAZY
+RTLD_LOCAL
+RTLD_NEXT
+RTLD_NODELETE
+RTLD_NOLOAD
+RTLD_NOW
+RT_ADDRCLASS
+RT_CLASS_DEFAULT
+RT_CLASS_LOCAL
+RT_CLASS_MAIN
+RT_CLASS_MAX
+RT_CLASS_UNSPEC
+RT_LOCALADDR
+RT_TOS
+RUSAGE_CHILDREN
+RUSAGE_SELF
+RUSAGE_THREAD
+R_OK
+SA_NOCLDSTOP
+SA_NOCLDWAIT
+SA_NODEFER
+SA_ONSTACK
+SA_RESETHAND
+SA_RESTART
+SA_SIGINFO
+SCHED_BATCH
+SCHED_FIFO
+SCHED_IDLE
+SCHED_OTHER
+SCHED_RESET_ON_FORK
+SCHED_RR
+SCM_CREDENTIALS
+SCM_RIGHTS
+SCM_TIMESTAMP
+SEEK_CUR
+SEEK_END
+SEEK_SET
+SELFMAG
+SEM_FAILED
+SHM_HUGETLB
+SHM_LOCK
+SHM_NORESERVE
+SHM_R
+SHM_RDONLY
+SHM_REMAP
+SHM_RND
+SHM_UNLOCK
+SHM_W
+SHUT_RD
+SHUT_RDWR
+SHUT_WR
+SIGABRT
+SIGALRM
+SIGBUS
+SIGCHLD
+SIGCONT
+SIGEV_NONE
+SIGEV_SIGNAL
+SIGEV_THREAD
+SIGFPE
+SIGHUP
+SIGILL
+SIGINT
+SIGIO
+SIGIOT
+SIGKILL
+SIGPIPE
+SIGPOLL
+SIGPROF
+SIGPWR
+SIGQUIT
+SIGRTMAX
+SIGRTMIN
+SIGSEGV
+SIGSTKSZ
+SIGSTOP
+SIGSYS
+SIGTERM
+SIGTRAP
+SIGTSTP
+SIGTTIN
+SIGTTOU
+SIGURG
+SIGUSR1
+SIGUSR2
+SIGVTALRM
+SIGWINCH
+SIGXCPU
+SIGXFSZ
+SIG_BLOCK
+SIG_DFL
+SIG_ERR
+SIG_IGN
+SIG_SETMASK
+SIG_UNBLOCK
+SIOCADDMULTI
+SIOCADDRT
+SIOCDARP
+SIOCDELMULTI
+SIOCDELRT
+SIOCDIFADDR
+SIOCDRARP
+SIOCGIFADDR
+SIOCGIFBR
+SIOCGIFBRDADDR
+SIOCGIFCONF
+SIOCGIFCOUNT
+SIOCGIFDSTADDR
+SIOCGIFENCAP
+SIOCGIFFLAGS
+SIOCGIFHWADDR
+SIOCGIFINDEX
+SIOCGIFMAP
+SIOCGIFMEM
+SIOCGIFMETRIC
+SIOCGIFMTU
+SIOCGIFNAME
+SIOCGIFNETMASK
+SIOCGIFPFLAGS
+SIOCGIFSLAVE
+SIOCGIFTXQLEN
+SIOCSIFADDR
+SIOCSIFBR
+SIOCSIFBRDADDR
+SIOCSIFDSTADDR
+SIOCSIFENCAP
+SIOCSIFFLAGS
+SIOCSIFHWADDR
+SIOCSIFHWBROADCAST
+SIOCSIFLINK
+SIOCSIFMAP
+SIOCSIFMEM
+SIOCSIFMETRIC
+SIOCSIFMTU
+SIOCSIFNAME
+SIOCSIFNETMASK
+SIOCSIFPFLAGS
+SIOCSIFSLAVE
+SIOCSIFTXQLEN
+SIOGIFINDEX
+SI_ASYNCIO
+SI_ASYNCNL
+SI_KERNEL
+SI_LOAD_SHIFT
+SI_MESGQ
+SI_QUEUE
+SI_SIGIO
+SI_TIMER
+SI_TKILL
+SI_USER
+SOCK_CLOEXEC
+SOCK_DCCP
+SOCK_DGRAM
+SOCK_NONBLOCK
+SOCK_PACKET
+SOCK_RAW
+SOCK_RDM
+SOCK_SEQPACKET
+SOCK_STREAM
+SOL_AAL
+SOL_ALG
+SOL_ATM
+SOL_BLUETOOTH
+SOL_DCCP
+SOL_DECNET
+SOL_ICMPV6
+SOL_IP
+SOL_IPV6
+SOL_IRDA
+SOL_LLC
+SOL_NETBEUI
+SOL_NETLINK
+SOL_SOCKET
+SOL_TCP
+SOL_TIPC
+SOL_UDP
+SOL_X25
+SOMAXCONN
+SO_ACCEPTCONN
+SO_BINDTODEVICE
+SO_BROADCAST
+SO_BSDCOMPAT
+SO_DEBUG
+SO_DONTROUTE
+SO_ERROR
+SO_KEEPALIVE
+SO_LINGER
+SO_NO_CHECK
+SO_OOBINLINE
+SO_PRIORITY
+SO_RCVBUF
+SO_RCVLOWAT
+SO_RCVTIMEO
+SO_REUSEADDR
+SO_SNDBUF
+SO_SNDLOWAT
+SO_SNDTIMEO
+SO_TYPE
+SS_DISABLE
+SS_ONSTACK
+STDERR_FILENO
+STDIN_FILENO
+STDOUT_FILENO
+ST_APPEND
+ST_IMMUTABLE
+ST_MANDLOCK
+ST_NOATIME
+ST_NODEV
+ST_NODIRATIME
+ST_NOEXEC
+ST_NOSUID
+ST_RDONLY
+ST_SYNCHRONOUS
+ST_WRITE
+S_IEXEC
+S_IFBLK
+S_IFCHR
+S_IFDIR
+S_IFIFO
+S_IFLNK
+S_IFMT
+S_IFREG
+S_IFSOCK
+S_IREAD
+S_IRGRP
+S_IROTH
+S_IRUSR
+S_IRWXG
+S_IRWXO
+S_IRWXU
+S_ISGID
+S_ISUID
+S_ISVTX
+S_IWGRP
+S_IWOTH
+S_IWRITE
+S_IWUSR
+S_IXGRP
+S_IXOTH
+S_IXUSR
+TAB0
+TAB1
+TAB2
+TAB3
+TABDLY
+TCFLSH
+TCGETA
+TCGETS
+TCIFLUSH
+TCIOFF
+TCIOFLUSH
+TCION
+TCOFLUSH
+TCOOFF
+TCOON
+TCP_CONGESTION
+TCP_COOKIE_TRANSACTIONS
+TCP_CORK
+TCP_DEFER_ACCEPT
+TCP_FASTOPEN
+TCP_INFO
+TCP_KEEPCNT
+TCP_KEEPIDLE
+TCP_KEEPINTVL
+TCP_LINGER2
+TCP_MAXSEG
+TCP_MD5SIG
+TCP_NODELAY
+TCP_QUEUE_SEQ
+TCP_QUICKACK
+TCP_REPAIR
+TCP_REPAIR_OPTIONS
+TCP_REPAIR_QUEUE
+TCP_SYNCNT
+TCP_THIN_DUPACK
+TCP_THIN_LINEAR_TIMEOUTS
+TCP_TIMESTAMP
+TCP_USER_TIMEOUT
+TCP_WINDOW_CLAMP
+TCSADRAIN
+TCSAFLUSH
+TCSANOW
+TCSBRK
+TCSETA
+TCSETAF
+TCSETAW
+TCSETS
+TCSETSF
+TCSETSW
+TCXONC
+THOUSEP
+TIMER_ABSTIME
+TIOCCONS
+TIOCEXCL
+TIOCGPGRP
+TIOCGSERIAL
+TIOCGSOFTCAR
+TIOCGWINSZ
+TIOCINQ
+TIOCLINUX
+TIOCMBIC
+TIOCMBIS
+TIOCMGET
+TIOCMSET
+TIOCM_CAR
+TIOCM_CD
+TIOCM_CTS
+TIOCM_DSR
+TIOCM_DTR
+TIOCM_LE
+TIOCM_RI
+TIOCM_RNG
+TIOCM_RTS
+TIOCM_SR
+TIOCM_ST
+TIOCNXCL
+TIOCOUTQ
+TIOCSCTTY
+TIOCSPGRP
+TIOCSSOFTCAR
+TIOCSTI
+TIOCSWINSZ
+TOSTOP
+T_FMT
+T_FMT_AMPM
+UDP_CORK
+UDP_ENCAP
+UDP_NO_CHECK6_RX
+UDP_NO_CHECK6_TX
+UIO_MAXIOV
+UTIME_NOW
+UTIME_OMIT
+VDISCARD
+VEOF
+VEOL
+VEOL2
+VERASE
+VINTR
+VKILL
+VLNEXT
+VMIN
+VQUIT
+VREPRINT
+VSTART
+VSTOP
+VSUSP
+VSWTC
+VT0
+VT1
+VTDLY
+VTIME
+VWERASE
+WCONTINUED
+WCOREDUMP
+WEXITED
+WEXITSTATUS
+WIFCONTINUED
+WIFEXITED
+WIFSIGNALED
+WIFSTOPPED
+WNOHANG
+WNOWAIT
+WSTOPPED
+WSTOPSIG
+WTERMSIG
+WUNTRACED
+W_EXITCODE
+W_OK
+W_STOPCODE
+XTABS
+X_OK
+YESEXPR
+YESSTR
+_CS_PATH
+_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS
+_CS_POSIX_V6_ILP32_OFF32_CFLAGS
+_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
+_CS_POSIX_V6_ILP32_OFF32_LIBS
+_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
+_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
+_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
+_CS_POSIX_V6_ILP32_OFFBIG_LIBS
+_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
+_CS_POSIX_V6_LP64_OFF64_CFLAGS
+_CS_POSIX_V6_LP64_OFF64_LDFLAGS
+_CS_POSIX_V6_LP64_OFF64_LIBS
+_CS_POSIX_V6_LP64_OFF64_LINTFLAGS
+_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
+_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
+_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
+_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
+_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS
+_CS_POSIX_V7_ILP32_OFF32_CFLAGS
+_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+_CS_POSIX_V7_ILP32_OFF32_LIBS
+_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
+_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+_CS_POSIX_V7_ILP32_OFFBIG_LIBS
+_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
+_CS_POSIX_V7_LP64_OFF64_CFLAGS
+_CS_POSIX_V7_LP64_OFF64_LDFLAGS
+_CS_POSIX_V7_LP64_OFF64_LIBS
+_CS_POSIX_V7_LP64_OFF64_LINTFLAGS
+_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
+_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
+_IOFBF
+_IOLBF
+_IONBF
+_PC_2_SYMLINKS
+_PC_ALLOC_SIZE_MIN
+_PC_ASYNC_IO
+_PC_CHOWN_RESTRICTED
+_PC_FILESIZEBITS
+_PC_LINK_MAX
+_PC_MAX_CANON
+_PC_MAX_INPUT
+_PC_NAME_MAX
+_PC_NO_TRUNC
+_PC_PATH_MAX
+_PC_PIPE_BUF
+_PC_PRIO_IO
+_PC_REC_INCR_XFER_SIZE
+_PC_REC_MAX_XFER_SIZE
+_PC_REC_MIN_XFER_SIZE
+_PC_REC_XFER_ALIGN
+_PC_SOCK_MAXBUF
+_PC_SYMLINK_MAX
+_PC_SYNC_IO
+_PC_VDISABLE
+_POSIX_VDISABLE
+_SC_2_CHAR_TERM
+_SC_2_C_BIND
+_SC_2_C_DEV
+_SC_2_FORT_DEV
+_SC_2_FORT_RUN
+_SC_2_LOCALEDEF
+_SC_2_PBS
+_SC_2_PBS_ACCOUNTING
+_SC_2_PBS_CHECKPOINT
+_SC_2_PBS_LOCATE
+_SC_2_PBS_MESSAGE
+_SC_2_PBS_TRACK
+_SC_2_SW_DEV
+_SC_2_UPE
+_SC_2_VERSION
+_SC_ADVISORY_INFO
+_SC_AIO_LISTIO_MAX
+_SC_AIO_MAX
+_SC_AIO_PRIO_DELTA_MAX
+_SC_ARG_MAX
+_SC_ASYNCHRONOUS_IO
+_SC_ATEXIT_MAX
+_SC_AVPHYS_PAGES
+_SC_BARRIERS
+_SC_BC_BASE_MAX
+_SC_BC_DIM_MAX
+_SC_BC_SCALE_MAX
+_SC_BC_STRING_MAX
+_SC_CHILD_MAX
+_SC_CLK_TCK
+_SC_CLOCK_SELECTION
+_SC_COLL_WEIGHTS_MAX
+_SC_CPUTIME
+_SC_FSYNC
+_SC_GETGR_R_SIZE_MAX
+_SC_GETPW_R_SIZE_MAX
+_SC_HOST_NAME_MAX
+_SC_IOV_MAX
+_SC_IPV6
+_SC_JOB_CONTROL
+_SC_LOGIN_NAME_MAX
+_SC_MEMLOCK
+_SC_MEMLOCK_RANGE
+_SC_MEMORY_PROTECTION
+_SC_MESSAGE_PASSING
+_SC_MONOTONIC_CLOCK
+_SC_MQ_OPEN_MAX
+_SC_MQ_PRIO_MAX
+_SC_NGROUPS_MAX
+_SC_NPROCESSORS_CONF
+_SC_NPROCESSORS_ONLN
+_SC_NZERO
+_SC_OPEN_MAX
+_SC_PAGESIZE
+_SC_PAGE_SIZE
+_SC_PASS_MAX
+_SC_PHYS_PAGES
+_SC_PRIORITIZED_IO
+_SC_PRIORITY_SCHEDULING
+_SC_RAW_SOCKETS
+_SC_READER_WRITER_LOCKS
+_SC_REALTIME_SIGNALS
+_SC_REGEXP
+_SC_RE_DUP_MAX
+_SC_RTSIG_MAX
+_SC_SAVED_IDS
+_SC_SEMAPHORES
+_SC_SEM_NSEMS_MAX
+_SC_SEM_VALUE_MAX
+_SC_SHARED_MEMORY_OBJECTS
+_SC_SHELL
+_SC_SPAWN
+_SC_SPIN_LOCKS
+_SC_SPORADIC_SERVER
+_SC_SS_REPL_MAX
+_SC_STREAMS
+_SC_STREAM_MAX
+_SC_SYMLOOP_MAX
+_SC_SYNCHRONIZED_IO
+_SC_THREADS
+_SC_THREAD_ATTR_STACKADDR
+_SC_THREAD_ATTR_STACKSIZE
+_SC_THREAD_CPUTIME
+_SC_THREAD_DESTRUCTOR_ITERATIONS
+_SC_THREAD_KEYS_MAX
+_SC_THREAD_PRIORITY_SCHEDULING
+_SC_THREAD_PRIO_INHERIT
+_SC_THREAD_PRIO_PROTECT
+_SC_THREAD_PROCESS_SHARED
+_SC_THREAD_ROBUST_PRIO_INHERIT
+_SC_THREAD_ROBUST_PRIO_PROTECT
+_SC_THREAD_SAFE_FUNCTIONS
+_SC_THREAD_SPORADIC_SERVER
+_SC_THREAD_STACK_MIN
+_SC_THREAD_THREADS_MAX
+_SC_TIMEOUTS
+_SC_TIMERS
+_SC_TIMER_MAX
+_SC_TRACE
+_SC_TRACE_EVENT_FILTER
+_SC_TRACE_EVENT_NAME_MAX
+_SC_TRACE_INHERIT
+_SC_TRACE_LOG
+_SC_TRACE_NAME_MAX
+_SC_TRACE_SYS_MAX
+_SC_TRACE_USER_EVENT_MAX
+_SC_TTY_NAME_MAX
+_SC_TYPED_MEMORY_OBJECTS
+_SC_TZNAME_MAX
+_SC_V6_ILP32_OFF32
+_SC_V6_ILP32_OFFBIG
+_SC_V6_LP64_OFF64
+_SC_V6_LPBIG_OFFBIG
+_SC_V7_ILP32_OFF32
+_SC_V7_ILP32_OFFBIG
+_SC_V7_LP64_OFF64
+_SC_V7_LPBIG_OFFBIG
+_SC_VERSION
+_SC_XBS5_ILP32_OFF32
+_SC_XBS5_ILP32_OFFBIG
+_SC_XBS5_LP64_OFF64
+_SC_XBS5_LPBIG_OFFBIG
+_SC_XOPEN_CRYPT
+_SC_XOPEN_ENH_I18N
+_SC_XOPEN_LEGACY
+_SC_XOPEN_REALTIME
+_SC_XOPEN_REALTIME_THREADS
+_SC_XOPEN_SHM
+_SC_XOPEN_STREAMS
+_SC_XOPEN_UNIX
+_SC_XOPEN_VERSION
+_SC_XOPEN_XCU_VERSION
+_SC_XOPEN_XPG2
+_SC_XOPEN_XPG3
+_SC_XOPEN_XPG4
+__SIZEOF_PTHREAD_ATTR_T
+__SIZEOF_PTHREAD_BARRIERATTR_T
+__SIZEOF_PTHREAD_BARRIER_T
+__SIZEOF_PTHREAD_CONDATTR_T
+__SIZEOF_PTHREAD_COND_COMPAT_T
+__SIZEOF_PTHREAD_COND_T
+__SIZEOF_PTHREAD_MUTEXATTR_T
+__SIZEOF_PTHREAD_MUTEX_T
+__SIZEOF_PTHREAD_RWLOCKATTR_T
+__SIZEOF_PTHREAD_RWLOCK_T
+__WALL
+__WCLONE
+__WNOTHREAD
+__c_anonymous_ifc_ifcu
+__c_anonymous_ifr_ifru
+__c_anonymous_ifru_map
+__errno_location
+__exit_status
+_exit
+abort
+accept
+access
+addrinfo
+alarm
+aligned_alloc
+arpd_request
+arphdr
+arpreq
+arpreq_old
+atof
+atoi
+atol
+atoll
+bind
+blkcnt64_t
+blkcnt_t
+blksize_t
+c_char
+c_double
+c_float
+c_int
+c_long
+c_longlong
+c_schar
+c_short
+c_uchar
+c_uint
+c_ulong
+c_ulonglong
+c_ushort
+c_void
+calloc
+cc_t
+cfgetispeed
+cfgetospeed
+cfmakeraw
+cfsetospeed
+chdir
+chmod
+chown
+chroot
+clearenv
+clearerr
+clock_gettime
+clock_t
+clockid_t
+close
+closedir
+closelog
+cmsghdr
+confstr
+connect
+cpu_set_t
+creat
+creat64
+daemon
+dev_t
+difftime
+dirent
+dirent64
+dirfd
+dl_iterate_phdr
+dl_phdr_info
+dladdr
+dlclose
+dlerror
+dlopen
+dlsym
+dup
+dup2
+endgrent
+endmntent
+endpwent
+endservent
+execl
+execle
+execlp
+execv
+execve
+execvp
+fchdir
+fchmod
+fchmodat
+fclose
+fcntl
+fd_set
+fdatasync
+fdopen
+fdopendir
+feof
+ferror
+fflush
+fgetc
+fgetpos
+fgets
+fileno
+flock
+fnmatch
+fopen
+fork
+fpathconf
+fpos_t
+fprintf
+fputc
+fputs
+fread
+free
+freeaddrinfo
+freopen
+freopen64
+fsblkcnt64_t
+fsblkcnt_t
+fscanf
+fseek
+fseeko
+fseeko64
+fsetpos
+fsetpos64
+fsfilcnt64_t
+fsfilcnt_t
+fsid_t
+fstat64
+fstatvfs
+fstatvfs64
+fsync
+ftell
+ftello
+ftello64
+ftruncate
+fwrite
+gai_strerror
+getaddrinfo
+getchar
+getchar_unlocked
+getcwd
+getegid
+getenv
+geteuid
+getgid
+getgrent
+getgrgid
+getgrgid_r
+getgrnam
+getgrnam_r
+getgroups
+gethostname
+getline
+getlogin
+getmntent
+getnameinfo
+getopt
+getopt_long
+getpeername
+getpgid
+getpgrp
+getpid
+getppid
+getprotobyname
+getprotobynumber
+getpwnam
+getpwuid
+getrlimit
+getrlimit64
+getrusage
+getservbyname
+getservbyport
+getservent
+getsid
+getsockname
+getsockopt
+gettimeofday
+getuid
+gid_t
+gmtime
+gmtime_r
+group
+hostent
+hstrerror
+iconv
+iconv_close
+iconv_open
+iconv_t
+id_t
+idtype_t
+if_freenameindex
+if_indextoname
+if_nameindex
+if_nametoindex
+ifaddrs
+ifconf
+ifreq
+in6_addr
+in6_pktinfo
+in6_rtmsg
+in6addr_any
+in6addr_loopback
+in_addr
+in_addr_t
+in_pktinfo
+in_port_t
+initgroups
+ino64_t
+ino_t
+int16_t
+int32_t
+int64_t
+int8_t
+intmax_t
+intptr_t
+ioctl
+iovec
+ip_mreq
+ip_mreq_source
+ip_mreqn
+ipc_perm
+ipv6_mreq
+isalnum
+isalpha
+isatty
+isblank
+iscntrl
+isdigit
+isgraph
+islower
+isprint
+ispunct
+isspace
+isupper
+isxdigit
+itimerspec
+itimerval
+jrand48
+key_t
+kill
+killpg
+lchown
+lconv
+linger
+listen
+locale_t
+localeconv
+localtime
+localtime_r
+lockf
+loff_t
+lseek
+lstat
+makedev
+malloc
+memalign
+memccpy
+memchr
+memcmp
+memcpy
+memmem
+memmove
+memrchr
+memset
+mkdir
+mkdtemp
+mkfifo
+mknod
+mkstemp
+mktime
+mlock
+mlockall
+mmap
+mmap64
+mmsghdr
+mntent
+mode_t
+mount
+mprotect
+msghdr 
+msync
+munlock
+munlockall
+munmap
+nanosleep
+newlocale
+nfds_t
+nice
+nl_item
+nl_langinfo
+nl_langinfo_l
+nlink_t
+nrand48
+off64_t
+off_t
+open
+open64
+openat
+openat64
+opendir
+openlog
+openpty
+packet_mreq
+passwd
+pathconf
+pause
+pclose
+perror
+pid_t
+pipe
+poll
+pollfd
+popen
+posix_fadvise
+posix_fadvise64
+posix_memalign
+ppoll
+prctl
+pread
+pread64
+preadv
+printf
+protoent
+pthread_attr_destroy
+pthread_attr_getguardsize
+pthread_attr_getinheritsched
+pthread_attr_getschedparam
+pthread_attr_getschedpolicy
+pthread_attr_getstack
+pthread_attr_getstacksize
+pthread_attr_init
+pthread_attr_setdetachstate
+pthread_attr_setguardsize
+pthread_attr_setinheritsched
+pthread_attr_setschedparam
+pthread_attr_setschedpolicy
+pthread_attr_setstacksize
+pthread_attr_t
+pthread_barrier_destroy
+pthread_barrier_init
+pthread_barrier_t
+pthread_barrier_wait
+pthread_barrierattr_destroy
+pthread_barrierattr_init
+pthread_barrierattr_setpshared
+pthread_barrierattr_t
+pthread_cancel
+pthread_cond_broadcast
+pthread_cond_destroy
+pthread_cond_init
+pthread_cond_signal
+pthread_cond_t
+pthread_cond_timedwait
+pthread_cond_wait
+pthread_condattr_destroy
+pthread_condattr_init
+pthread_condattr_setpshared
+pthread_condattr_t
+pthread_create
+pthread_detach
+pthread_equal
+pthread_exit
+pthread_getaffinity_np
+pthread_getattr_np
+pthread_getschedparam
+pthread_getspecific
+pthread_join
+pthread_key_create
+pthread_key_delete
+pthread_key_t
+pthread_kill
+pthread_mutex_destroy
+pthread_mutex_init
+pthread_mutex_lock
+pthread_mutex_t
+pthread_mutex_trylock
+pthread_mutex_unlock
+pthread_mutexattr_destroy
+pthread_mutexattr_init
+pthread_mutexattr_settype
+pthread_mutexattr_t
+pthread_once
+pthread_once_t
+pthread_rwlock_destroy
+pthread_rwlock_init
+pthread_rwlock_rdlock
+pthread_rwlock_t
+pthread_rwlock_tryrdlock
+pthread_rwlock_trywrlock
+pthread_rwlock_unlock
+pthread_rwlock_wrlock
+pthread_rwlockattr_destroy
+pthread_rwlockattr_init
+pthread_rwlockattr_setpshared
+pthread_rwlockattr_t
+pthread_self
+pthread_setaffinity_np
+pthread_setspecific
+pthread_spin_destroy
+pthread_spin_init
+pthread_spin_lock
+pthread_spin_trylock
+pthread_spin_unlock
+pthread_spinlock_t
+pthread_t
+ptrdiff_t
+putchar
+putchar_unlocked
+putenv
+puts
+pwrite
+pwrite64
+pwritev
+qsort
+raise
+read
+readdir
+readdir64
+readdir64_r
+readdir_r
+readv
+realloc
+realpath
+recv
+recvfrom
+recvmsg
+regcomp
+regerror
+regex_t
+regexec
+regfree
+regmatch_t
+regoff_t
+remove
+rename
+rewind
+rewinddir
+rlim64_t
+rlim_t
+rlimit
+rlimit64
+rmdir
+rtentry
+rusage
+sa_family_t
+scanf
+sched_get_priority_max
+sched_get_priority_min
+sched_getaffinity
+sched_getcpu
+sched_yield
+seekdir
+sem_close
+sem_destroy
+sem_getvalue
+sem_init
+sem_open
+sem_post
+sem_t
+sem_timedwait
+sem_trywait
+sem_unlink
+sem_wait
+sembuf
+send
+sendto
+servent
+setbuf
+setegid
+setenv
+seteuid
+setgid
+setgrent
+setgroups
+sethostname
+setlocale
+setlogmask
+setmntent
+setpgid
+setregid
+setreuid
+setrlimit
+setrlimit64
+setservent
+setsid
+setsockopt
+settimeofday
+setuid
+setvbuf
+shmat
+shmatt_t
+shmctl
+shmdt
+shmget
+shmid_ds
+shutdown
+sigaction
+sigaddset
+sigdelset
+sigemptyset
+sigevent
+sigfillset
+sighandler_t
+siginfo_t
+sigismember
+signal
+sigpending
+sigprocmask
+sigset_t
+sigval
+size_t
+sleep
+snprintf
+sockaddr
+sockaddr_in
+sockaddr_in6
+sockaddr_storage
+sockaddr_un
+socket
+socketpair
+socklen_t
+speed_t
+sprintf
+spwd
+srand
+srand48
+sscanf
+ssize_t
+stack_t
+stat
+stat64
+statfs
+statfs64
+statvfs
+statvfs64
+strcasecmp
+strcasestr
+strcat
+strchr
+strchrnul
+strcmp
+strcoll
+strcpy
+strcspn
+strdup
+strerror
+strerror_r
+strftime
+strftime_l
+strlen
+strncasecmp
+strncat
+strncmp
+strncpy
+strndup
+strnlen
+strpbrk
+strptime
+strrchr
+strsignal
+strspn
+strstr
+strtod
+strtof
+strtok
+strtol
+strtoll
+strtoul
+strtoull
+strxfrm
+suseconds_t
+symlink
+sysconf
+sysinfo
+syslog
+system
+tcdrain
+tcflag_t
+tcflow
+tcflush
+tcgetattr
+tcgetpgrp
+tcgetsid
+tcsendbreak
+tcsetattr
+tcsetpgrp
+telldir
+termios
+time
+time_t
+timegm
+timer_create
+timer_delete
+timer_gettime
+timer_settime
+times
+timespec
+timeval
+timezone
+tm
+tmpfile
+tms
+tolower
+toupper
+truncate
+truncate64
+ttyname
+ttyname_r
+ucred
+uid_t
+uint16_t
+uint32_t
+uint64_t
+uint8_t
+uintmax_t
+uintptr_t
+umask
+uname
+ungetc
+unlink
+unsetenv
+useconds_t
+uselocale
+usleep
+utimbuf
+utime
+utimensat
+utsname
+wait
+waitpid
+wchar_t
+wcslen
+wcstombs
+winsize
+wmemchr
+write
+writev
diff --git a/src/unix/linux_like/android/mod.rs b/src/unix/linux_like/android/mod.rs
index 0c930f62f..c3115a112 100644
--- a/src/unix/linux_like/android/mod.rs
+++ b/src/unix/linux_like/android/mod.rs
@@ -19,7 +19,6 @@ pub type off_t = c_long;
 pub type blkcnt_t = c_ulong;
 pub type blksize_t = c_ulong;
 pub type nlink_t = u32;
-pub type useconds_t = u32;
 pub type pthread_t = c_long;
 pub type pthread_mutexattr_t = c_long;
 pub type pthread_rwlockattr_t = c_long;
@@ -492,11 +491,6 @@ s! {
         pub ifr6_prefixlen: u32,
         pub ifr6_ifindex: c_int,
     }
-
-    pub struct if_nameindex {
-        pub if_index: c_uint,
-        pub if_name: *mut c_char,
-    }
 }
 
 s_no_extra_traits! {
@@ -637,58 +631,6 @@ cfg_if! {
             }
         }
 
-        impl PartialEq for dirent {
-            fn eq(&self, other: &dirent) -> bool {
-                self.d_ino == other.d_ino
-                    && self.d_off == other.d_off
-                    && self.d_reclen == other.d_reclen
-                    && self.d_type == other.d_type
-                    && self
-                        .d_name
-                        .iter()
-                        .zip(other.d_name.iter())
-                        .all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for dirent {}
-
-        impl hash::Hash for dirent {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.d_ino.hash(state);
-                self.d_off.hash(state);
-                self.d_reclen.hash(state);
-                self.d_type.hash(state);
-                self.d_name.hash(state);
-            }
-        }
-
-        impl PartialEq for dirent64 {
-            fn eq(&self, other: &dirent64) -> bool {
-                self.d_ino == other.d_ino
-                    && self.d_off == other.d_off
-                    && self.d_reclen == other.d_reclen
-                    && self.d_type == other.d_type
-                    && self
-                        .d_name
-                        .iter()
-                        .zip(other.d_name.iter())
-                        .all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for dirent64 {}
-
-        impl hash::Hash for dirent64 {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.d_ino.hash(state);
-                self.d_off.hash(state);
-                self.d_reclen.hash(state);
-                self.d_type.hash(state);
-                self.d_name.hash(state);
-            }
-        }
-
         impl PartialEq for siginfo_t {
             fn eq(&self, other: &siginfo_t) -> bool {
                 self.si_signo == other.si_signo
@@ -3870,20 +3812,6 @@ extern "C" {
     pub fn pthread_kill(thread: crate::pthread_t, sig: c_int) -> c_int;
     pub fn sem_unlink(name: *const c_char) -> c_int;
     pub fn daemon(nochdir: c_int, noclose: c_int) -> c_int;
-    pub fn getpwnam_r(
-        name: *const c_char,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
-    pub fn getpwuid_r(
-        uid: crate::uid_t,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
     pub fn sigtimedwait(
         set: *const sigset_t,
         info: *mut siginfo_t,
@@ -4022,9 +3950,6 @@ extern "C" {
         newpath: *const c_char,
         flags: c_uint,
     ) -> c_int;
-
-    pub fn if_nameindex() -> *mut if_nameindex;
-    pub fn if_freenameindex(ptr: *mut if_nameindex);
 }
 
 cfg_if! {
diff --git a/src/unix/linux_like/emscripten/mod.rs b/src/unix/linux_like/emscripten/mod.rs
index 417e3e593..f6f79c914 100644
--- a/src/unix/linux_like/emscripten/mod.rs
+++ b/src/unix/linux_like/emscripten/mod.rs
@@ -1,7 +1,6 @@
 use crate::prelude::*;
 
 pub type wchar_t = i32;
-pub type useconds_t = u32;
 pub type dev_t = u32;
 pub type socklen_t = u32;
 pub type pthread_t = c_ulong;
@@ -135,11 +134,6 @@ s! {
         bits: [u32; 32],
     }
 
-    pub struct if_nameindex {
-        pub if_index: c_uint,
-        pub if_name: *mut c_char,
-    }
-
     // System V IPC
     pub struct msginfo {
         pub msgpool: c_int,
@@ -314,31 +308,6 @@ s! {
         pub updated: c_ulong,
         pub ha: [c_uchar; crate::MAX_ADDR_LEN],
     }
-
-    #[repr(align(4))]
-    pub struct pthread_mutex_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_MUTEX_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_rwlock_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCK_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_mutexattr_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_MUTEXATTR_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_rwlockattr_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCKATTR_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_condattr_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_CONDATTR_T],
-    }
 }
 
 s_no_extra_traits! {
@@ -375,12 +344,7 @@ s_no_extra_traits! {
         pad: [c_long; 4],
     }
 
-    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
-    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
-    pub struct pthread_cond_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_COND_T],
-    }
-
+    #[allow(missing_debug_implementations)]
     #[repr(align(8))]
     pub struct max_align_t {
         priv_: [f64; 3],
@@ -389,30 +353,6 @@ s_no_extra_traits! {
 
 cfg_if! {
     if #[cfg(feature = "extra_traits")] {
-        impl PartialEq for dirent {
-            fn eq(&self, other: &dirent) -> bool {
-                self.d_ino == other.d_ino
-                    && self.d_off == other.d_off
-                    && self.d_reclen == other.d_reclen
-                    && self.d_type == other.d_type
-                    && self
-                        .d_name
-                        .iter()
-                        .zip(other.d_name.iter())
-                        .all(|(a, b)| a == b)
-            }
-        }
-        impl Eq for dirent {}
-        impl hash::Hash for dirent {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.d_ino.hash(state);
-                self.d_off.hash(state);
-                self.d_reclen.hash(state);
-                self.d_type.hash(state);
-                self.d_name.hash(state);
-            }
-        }
-
         impl PartialEq for sysinfo {
             fn eq(&self, other: &sysinfo) -> bool {
                 self.uptime == other.uptime
@@ -472,18 +412,6 @@ cfg_if! {
                 self.mq_curmsgs.hash(state);
             }
         }
-
-        impl PartialEq for pthread_cond_t {
-            fn eq(&self, other: &pthread_cond_t) -> bool {
-                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
-            }
-        }
-        impl Eq for pthread_cond_t {}
-        impl hash::Hash for pthread_cond_t {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.size.hash(state);
-            }
-        }
     }
 }
 
@@ -776,16 +704,6 @@ pub const RTLD_DEFAULT: *mut c_void = ptr::null_mut();
 pub const RTLD_NODELETE: c_int = 0x1000;
 pub const RTLD_NOW: c_int = 0x2;
 
-pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
-    size: [0; __SIZEOF_PTHREAD_MUTEX_T],
-};
-pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
-    size: [0; __SIZEOF_PTHREAD_COND_T],
-};
-pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
-    size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
-};
-
 pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
 pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
 pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
@@ -1483,8 +1401,6 @@ extern "C" {
     pub fn getloadavg(loadavg: *mut c_double, nelem: c_int) -> c_int;
 
     pub fn mkfifoat(dirfd: c_int, pathname: *const c_char, mode: mode_t) -> c_int;
-    pub fn if_nameindex() -> *mut if_nameindex;
-    pub fn if_freenameindex(ptr: *mut if_nameindex);
 
     pub fn mremap(
         addr: *mut c_void,
@@ -1550,21 +1466,6 @@ extern "C" {
 
     pub fn getentropy(buf: *mut c_void, buflen: size_t) -> c_int;
 
-    pub fn getpwnam_r(
-        name: *const c_char,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
-    pub fn getpwuid_r(
-        uid: crate::uid_t,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
-
     // grp.h
     pub fn getgrgid(gid: crate::gid_t) -> *mut crate::group;
     pub fn getgrnam(name: *const c_char) -> *mut crate::group;
diff --git a/src/unix/linux_like/l4re/mod.rs b/src/unix/linux_like/l4re/mod.rs
new file mode 100644
index 000000000..913a25d6e
--- /dev/null
+++ b/src/unix/linux_like/l4re/mod.rs
@@ -0,0 +1,180 @@
+use crate::prelude::*;
+
+/// L4Re specifics
+/// This module contains definitions required by various L4Re libc backends.
+/// Some of them are formally not part of the libc, but are a dependency of the
+/// libc and hence we should provide them here.
+
+pub type l4_umword_t = c_ulong; // Unsigned machine word.
+pub type pthread_t = *mut c_void;
+
+s! {
+    /// CPU sets.
+    pub struct l4_sched_cpu_set_t {
+        // from the L4Re docs
+        /// Combination of granularity and offset.
+        ///
+        /// The granularity defines how many CPUs each bit in map describes.
+        /// The offset is the number of the first CPU described by the first
+        /// bit in the bitmap.
+        /// offset must be a multiple of 2^graularity.
+        ///
+        /// | MSB              |                 LSB |
+        /// | ---------------- | ------------------- |
+        /// | 8bit granularity | 24bit offset ..     |
+        gran_offset: l4_umword_t,
+        /// Bitmap of CPUs.
+        map: l4_umword_t,
+    }
+
+    pub struct pthread_attr_t {
+        pub __detachstate: c_int,
+        pub __schedpolicy: c_int,
+        pub __schedparam: super::__sched_param,
+        pub __inheritsched: c_int,
+        pub __scope: c_int,
+        pub __guardsize: size_t,
+        pub __stackaddr_set: c_int,
+        pub __stackaddr: *mut c_void, // better don't use it
+        pub __stacksize: size_t,
+        // L4Re specifics
+        pub affinity: l4_sched_cpu_set_t,
+        pub create_flags: c_uint,
+    }
+}
+
+// L4Re requires a min stack size of 64k; that isn't defined in uClibc, but
+// somewhere in the core libraries. uClibc wants 16k, but that's not enough.
+pub const PTHREAD_STACK_MIN: usize = 65536;
+
+pub const BOTHER: crate::speed_t = 0o010000;
+
+pub const RLIMIT_CPU: crate::__rlimit_resource_t = 0;
+pub const RLIMIT_FSIZE: crate::__rlimit_resource_t = 1;
+pub const RLIMIT_DATA: crate::__rlimit_resource_t = 2;
+pub const RLIMIT_STACK: crate::__rlimit_resource_t = 3;
+pub const RLIMIT_CORE: crate::__rlimit_resource_t = 4;
+pub const RLIMIT_RSS: crate::__rlimit_resource_t = 5;
+pub const RLIMIT_NPROC: crate::__rlimit_resource_t = 6;
+pub const RLIMIT_NOFILE: crate::__rlimit_resource_t = 7;
+pub const RLIMIT_MEMLOCK: crate::__rlimit_resource_t = 8;
+pub const RLIMIT_AS: crate::__rlimit_resource_t = 9;
+pub const RLIMIT_LOCKS: crate::__rlimit_resource_t = 10;
+pub const RLIMIT_SIGPENDING: crate::__rlimit_resource_t = 11;
+pub const RLIMIT_MSGQUEUE: crate::__rlimit_resource_t = 12;
+pub const RLIMIT_NICE: crate::__rlimit_resource_t = 13;
+pub const RLIMIT_RTPRIO: crate::__rlimit_resource_t = 14;
+pub const RLIMIT_RTTIME: crate::__rlimit_resource_t = 15;
+pub const RLIMIT_NLIMITS: crate::__rlimit_resource_t = RLIM_NLIMITS;
+pub const RLIM_NLIMITS: crate::__rlimit_resource_t = 16;
+
+pub const SOL_SOCKET: c_int = 1;
+
+// pub const SO_DEBUG: c_int = 1;
+pub const SO_REUSEADDR: c_int = 2;
+pub const SO_TYPE: c_int = 3;
+pub const SO_ERROR: c_int = 4;
+pub const SO_DONTROUTE: c_int = 5;
+pub const SO_BROADCAST: c_int = 6;
+pub const SO_SNDBUF: c_int = 7;
+pub const SO_RCVBUF: c_int = 8;
+pub const SO_KEEPALIVE: c_int = 9;
+pub const SO_OOBINLINE: c_int = 10;
+pub const SO_NO_CHECK: c_int = 11;
+pub const SO_PRIORITY: c_int = 12;
+pub const SO_LINGER: c_int = 13;
+pub const SO_BSDCOMPAT: c_int = 14;
+pub const SO_PASSCRED: c_int = 16;
+pub const SO_PEERCRED: c_int = 17;
+pub const SO_RCVLOWAT: c_int = 18;
+pub const SO_SNDLOWAT: c_int = 19;
+pub const SO_RCVTIMEO: c_int = 20;
+pub const SO_SNDTIMEO: c_int = 21;
+pub const SO_SECURITY_AUTHENTICATION: c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: c_int = 24;
+pub const SO_BINDTODEVICE: c_int = 25;
+pub const SO_ATTACH_FILTER: c_int = 26;
+pub const SO_DETACH_FILTER: c_int = 27;
+pub const SO_PEERNAME: c_int = 28;
+
+pub const SO_ACCEPTCONN: c_int = 30;
+pub const SO_PEERSEC: c_int = 31;
+
+pub const TCGETS: Ioctl = 0x5401;
+pub const TCSETS: Ioctl = 0x5402;
+pub const TCSETSW: Ioctl = 0x5403;
+pub const TCSETSF: Ioctl = 0x5404;
+pub const TCGETA: Ioctl = 0x5405;
+pub const TCSETA: Ioctl = 0x5406;
+pub const TCSETAW: Ioctl = 0x5407;
+pub const TCSETAF: Ioctl = 0x5408;
+pub const TCSBRK: Ioctl = 0x5409;
+pub const TCXONC: Ioctl = 0x540A;
+pub const TCFLSH: Ioctl = 0x540B;
+pub const TIOCM_LE: c_int = 0x001;
+pub const TIOCM_DTR: c_int = 0x002;
+pub const TIOCM_RTS: c_int = 0x004;
+pub const TIOCM_ST: c_int = 0x008;
+pub const TIOCM_SR: c_int = 0x010;
+pub const TIOCM_CTS: c_int = 0x020;
+pub const TIOCM_CAR: c_int = 0x040;
+pub const TIOCM_CD: c_int = TIOCM_CAR;
+pub const TIOCM_RNG: c_int = 0x080;
+pub const TIOCM_RI: c_int = TIOCM_RNG;
+pub const TIOCM_DSR: c_int = 0x100;
+pub const TIOCEXCL: Ioctl = 0x540C;
+pub const TIOCNXCL: Ioctl = 0x540D;
+pub const TIOCSCTTY: Ioctl = 0x540E;
+pub const TIOCGPGRP: Ioctl = 0x540F;
+pub const TIOCSPGRP: Ioctl = 0x5410;
+pub const TIOCOUTQ: Ioctl = 0x5411;
+pub const TIOCSTI: Ioctl = 0x5412;
+pub const TIOCGWINSZ: Ioctl = 0x5413;
+pub const TIOCSWINSZ: Ioctl = 0x5414;
+pub const TIOCMGET: Ioctl = 0x5415;
+pub const TIOCMBIS: Ioctl = 0x5416;
+pub const TIOCMBIC: Ioctl = 0x5417;
+pub const TIOCMSET: Ioctl = 0x5418;
+pub const TIOCGSOFTCAR: Ioctl = 0x5419;
+pub const TIOCSSOFTCAR: Ioctl = 0x541A;
+pub const FIONREAD: Ioctl = 0x541B;
+pub const TIOCINQ: Ioctl = FIONREAD;
+pub const TIOCLINUX: Ioctl = 0x541C;
+pub const TIOCCONS: Ioctl = 0x541D;
+pub const TIOCGSERIAL: Ioctl = 0x541E;
+pub const TIOCSSERIAL: Ioctl = 0x541F;
+pub const TIOCPKT: Ioctl = 0x5420;
+pub const FIONBIO: Ioctl = 0x5421;
+pub const TIOCNOTTY: Ioctl = 0x5422;
+pub const TIOCSETD: Ioctl = 0x5423;
+pub const TIOCGETD: Ioctl = 0x5424;
+pub const TCSBRKP: Ioctl = 0x5425;
+pub const TIOCSBRK: Ioctl = 0x5427;
+pub const TIOCCBRK: Ioctl = 0x5428;
+pub const TIOCGSID: Ioctl = 0x5429;
+pub const TIOCGPTN: Ioctl = 0x80045430;
+pub const TIOCSPTLCK: Ioctl = 0x40045431;
+pub const FIONCLEX: Ioctl = 0x5450;
+pub const FIOCLEX: Ioctl = 0x5451;
+pub const FIOASYNC: Ioctl = 0x5452;
+pub const TIOCSERCONFIG: Ioctl = 0x5453;
+pub const TIOCSERGWILD: Ioctl = 0x5454;
+pub const TIOCSERSWILD: Ioctl = 0x5455;
+pub const TIOCGLCKTRMIOS: Ioctl = 0x5456;
+pub const TIOCSLCKTRMIOS: Ioctl = 0x5457;
+pub const TIOCSERGSTRUCT: Ioctl = 0x5458;
+pub const TIOCSERGETLSR: Ioctl = 0x5459;
+pub const TIOCSERGETMULTI: Ioctl = 0x545A;
+pub const TIOCSERSETMULTI: Ioctl = 0x545B;
+pub const TIOCMIWAIT: Ioctl = 0x545C;
+pub const TIOCGICOUNT: Ioctl = 0x545D;
+
+pub const BLKSSZGET: Ioctl = 0x1268;
+
+cfg_if! {
+    if #[cfg(target_env = "uclibc")] {
+        mod uclibc;
+        pub use self::uclibc::*;
+    }
+}
diff --git a/src/unix/linux_like/l4re/uclibc/aarch64/mod.rs b/src/unix/linux_like/l4re/uclibc/aarch64/mod.rs
new file mode 100644
index 000000000..3a471700f
--- /dev/null
+++ b/src/unix/linux_like/l4re/uclibc/aarch64/mod.rs
@@ -0,0 +1,414 @@
+use crate::prelude::*;
+
+pub type wchar_t = c_uint;
+pub type time_t = c_long;
+
+pub type clock_t = c_long;
+pub type fsblkcnt_t = c_ulong;
+pub type fsfilcnt_t = c_ulong;
+pub type ino_t = c_ulong;
+pub type nlink_t = c_ulong;
+pub type off_t = c_long;
+pub type fsword_t = c_long;
+pub type suseconds_t = c_long;
+
+pub type blksize_t = c_long;
+pub type blkcnt_t = c_long;
+
+pub type fsblkcnt64_t = c_ulong;
+pub type fsfilcnt64_t = c_ulong;
+pub type __u64 = c_ulong;
+
+s! {
+    pub struct stat {
+        pub st_dev: c_ulong,
+        pub __pad1: c_ushort,
+        pub st_ino: crate::ino_t,
+        pub st_mode: crate::mode_t,
+        pub st_nlink: nlink_t,
+        pub st_uid: crate::uid_t,
+        pub st_gid: crate::gid_t,
+        pub st_rdev: c_ulong,
+        pub __pad2: c_ushort,
+        pub st_size: crate::off64_t,
+        pub st_blksize: blksize_t,
+        pub st_blocks: crate::blkcnt64_t,
+        pub st_atim: crate::timespec,
+        pub st_mtim: crate::timespec,
+        pub st_ctim: crate::timespec,
+        pub __uclibc_unused4: c_ulong,
+        pub __uclibc_unused5: c_ulong,
+    }
+
+    pub struct stat64 {
+        pub st_dev: c_ulong,
+        pub __pad1: c_uint,
+        pub __st_ino: crate::ino_t,
+        pub st_mode: crate::mode_t,
+        pub st_nlink: nlink_t,
+        pub st_uid: crate::uid_t,
+        pub st_gid: crate::gid_t,
+        pub st_rdev: c_ulong,
+        pub __pad2: c_uint,
+        pub st_size: crate::off64_t,
+        pub st_blksize: blksize_t,
+        pub st_blocks: crate::blkcnt64_t,
+        pub st_atim: crate::timespec,
+        pub st_mtim: crate::timespec,
+        pub st_ctim: crate::timespec,
+        pub st_ino: crate::ino64_t,
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: crate::ipc_perm,
+        pub shm_segsz: crate::size_t,
+        pub shm_atime: crate::time_t,
+        __unused1: c_ulong,
+        pub shm_dtime: crate::time_t,
+        __unused2: c_ulong,
+        pub shm_ctime: crate::time_t,
+        __unused3: c_ulong,
+        pub shm_cpid: crate::pid_t,
+        pub shm_lpid: crate::pid_t,
+        pub shm_nattch: crate::shmatt_t,
+        __unused4: c_ulong,
+        __unused5: c_ulong,
+    }
+
+    #[allow(unpredictable_function_pointer_comparisons)]
+    pub struct sigaction {
+        pub sa_handler: crate::sighandler_t,
+        pub sa_flags: c_ulong,
+        pub sa_restorer: Option<extern "C" fn()>,
+        pub sa_mask: sigset_t,
+    }
+
+    pub struct sigset_t {
+        __val: [c_ulong; 1],
+    }
+
+    #[repr(align(8))]
+    pub struct siginfo_t {
+        pub si_signo: c_int,
+        pub si_errno: c_int,
+        pub si_code: c_int,
+        pub _pad: [c_int; 28],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut c_void,
+        pub ss_flags: c_int,
+        pub ss_size: crate::size_t,
+    }
+
+    pub struct flock {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: off_t,
+        pub l_len: off_t,
+        pub l_pid: crate::pid_t,
+    }
+
+    pub struct termios {
+        pub c_iflag: crate::tcflag_t,
+        pub c_oflag: crate::tcflag_t,
+        pub c_cflag: crate::tcflag_t,
+        pub c_lflag: crate::tcflag_t,
+        pub c_line: crate::cc_t,
+        pub c_cc: [crate::cc_t; crate::NCCS],
+        pub c_ispeed: crate::speed_t,
+        pub c_ospeed: crate::speed_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub union sem_t {
+        __size: [c_char; 32],
+        __align: c_longlong,
+    }
+}
+
+pub const O_CLOEXEC: c_int = 0o2000000;
+pub const __SIZEOF_PTHREAD_ATTR_T: usize = 36;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+pub const __SIZEOF_PTHREAD_COND_COMPAT_T: usize = 12;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_BARRIER_T: usize = 32;
+pub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;
+
+pub const NCCS: usize = 32;
+
+pub const FIOQSIZE: crate::Ioctl = 0x545E;
+
+// I wasn't able to find those constants
+// in uclibc build environment for armv7
+pub const MAP_HUGETLB: c_int = 0x040000; // from linux/other/mod.rs
+
+// autogenerated constants with hand tuned types
+pub const B0: crate::speed_t = 0;
+pub const B1000000: crate::speed_t = 0x1008;
+pub const B110: crate::speed_t = 0x3;
+pub const B115200: crate::speed_t = 0x1002;
+pub const B1152000: crate::speed_t = 0x1009;
+pub const B1200: crate::speed_t = 0x9;
+pub const B134: crate::speed_t = 0x4;
+pub const B150: crate::speed_t = 0x5;
+pub const B1500000: crate::speed_t = 0x100a;
+pub const B1800: crate::speed_t = 0xa;
+pub const B19200: crate::speed_t = 0xe;
+pub const B200: crate::speed_t = 0x6;
+pub const B2000000: crate::speed_t = 0x100b;
+pub const B230400: crate::speed_t = 0x1003;
+pub const B2400: crate::speed_t = 0xb;
+pub const B2500000: crate::speed_t = 0x100c;
+pub const B300: crate::speed_t = 0x7;
+pub const B3000000: crate::speed_t = 0x100d;
+pub const B3500000: crate::speed_t = 0x100e;
+pub const B38400: crate::speed_t = 0xf;
+pub const B4000000: crate::speed_t = 0x100f;
+pub const B460800: crate::speed_t = 0x1004;
+pub const B4800: crate::speed_t = 0xc;
+pub const B50: crate::speed_t = 0x1;
+pub const B500000: crate::speed_t = 0x1005;
+pub const B57600: crate::speed_t = 0x1001;
+pub const B576000: crate::speed_t = 0x1006;
+pub const B600: crate::speed_t = 0x8;
+pub const B75: crate::speed_t = 0x2;
+pub const B921600: crate::speed_t = 0x1007;
+pub const B9600: crate::speed_t = 0xd;
+pub const BS1: c_int = 0x2000;
+pub const BSDLY: c_int = 0x2000;
+pub const CBAUD: crate::tcflag_t = 0x100f;
+pub const CBAUDEX: crate::tcflag_t = 0x1000;
+pub const CIBAUD: crate::tcflag_t = 0x100f0000;
+pub const CLOCAL: crate::tcflag_t = 0x800;
+pub const CPU_SETSIZE: c_int = 0x400;
+pub const CR1: c_int = 0x200;
+pub const CR2: c_int = 0x400;
+pub const CR3: c_int = 0x600;
+pub const CRDLY: c_int = 0x600;
+pub const CREAD: crate::tcflag_t = 0x80;
+pub const CS6: crate::tcflag_t = 0x10;
+pub const CS7: crate::tcflag_t = 0x20;
+pub const CS8: crate::tcflag_t = 0x30;
+pub const CSIZE: crate::tcflag_t = 0x30;
+pub const CSTOPB: crate::tcflag_t = 0x40;
+pub const EADDRINUSE: c_int = 0x62;
+pub const EADDRNOTAVAIL: c_int = 0x63;
+pub const EADV: c_int = 0x44;
+pub const EAFNOSUPPORT: c_int = 0x61;
+pub const EALREADY: c_int = 0x72;
+pub const EBADE: c_int = 0x34;
+pub const EBADFD: c_int = 0x4d;
+pub const EBADMSG: c_int = 0x4a;
+pub const EBADR: c_int = 0x35;
+pub const EBADRQC: c_int = 0x38;
+pub const EBADSLT: c_int = 0x39;
+pub const EBFONT: c_int = 0x3b;
+pub const ECANCELED: c_int = 0x7d;
+pub const ECHOCTL: crate::tcflag_t = 0x200;
+pub const ECHOE: crate::tcflag_t = 0x10;
+pub const ECHOK: crate::tcflag_t = 0x20;
+pub const ECHOKE: crate::tcflag_t = 0x800;
+pub const ECHONL: crate::tcflag_t = 0x40;
+pub const ECHOPRT: crate::tcflag_t = 0x400;
+pub const ECHRNG: c_int = 0x2c;
+pub const ECOMM: c_int = 0x46;
+pub const ECONNABORTED: c_int = 0x67;
+pub const ECONNREFUSED: c_int = 0x6f;
+pub const ECONNRESET: c_int = 0x68;
+pub const EDESTADDRREQ: c_int = 0x59;
+pub const EDOTDOT: c_int = 0x49;
+pub const EDQUOT: c_int = 0x7a;
+pub const EHOSTDOWN: c_int = 0x70;
+pub const EHOSTUNREACH: c_int = 0x71;
+pub const EIDRM: c_int = 0x2b;
+pub const EILSEQ: c_int = 0x54;
+pub const EINPROGRESS: c_int = 0x73;
+pub const EISCONN: c_int = 0x6a;
+pub const EISNAM: c_int = 0x78;
+pub const EKEYEXPIRED: c_int = 0x7f;
+pub const EKEYREJECTED: c_int = 0x81;
+pub const EKEYREVOKED: c_int = 0x80;
+pub const EL2HLT: c_int = 0x33;
+pub const EL2NSYNC: c_int = 0x2d;
+pub const EL3HLT: c_int = 0x2e;
+pub const EL3RST: c_int = 0x2f;
+pub const ELIBACC: c_int = 0x4f;
+pub const ELIBBAD: c_int = 0x50;
+pub const ELIBEXEC: c_int = 0x53;
+pub const ELIBMAX: c_int = 0x52;
+pub const ELIBSCN: c_int = 0x51;
+pub const ELNRNG: c_int = 0x30;
+pub const ELOOP: c_int = 0x28;
+pub const EMEDIUMTYPE: c_int = 0x7c;
+pub const EMSGSIZE: c_int = 0x5a;
+pub const EMULTIHOP: c_int = 0x48;
+pub const ENAMETOOLONG: c_int = 0x24;
+pub const ENAVAIL: c_int = 0x77;
+pub const ENETDOWN: c_int = 0x64;
+pub const ENETRESET: c_int = 0x66;
+pub const ENETUNREACH: c_int = 0x65;
+pub const ENOANO: c_int = 0x37;
+pub const ENOBUFS: c_int = 0x69;
+pub const ENOCSI: c_int = 0x32;
+pub const ENODATA: c_int = 0x3d;
+pub const ENOKEY: c_int = 0x7e;
+pub const ENOLCK: c_int = 0x25;
+pub const ENOLINK: c_int = 0x43;
+pub const ENOMEDIUM: c_int = 0x7b;
+pub const ENOMSG: c_int = 0x2a;
+pub const ENONET: c_int = 0x40;
+pub const ENOPKG: c_int = 0x41;
+pub const ENOPROTOOPT: c_int = 0x5c;
+pub const ENOSR: c_int = 0x3f;
+pub const ENOSTR: c_int = 0x3c;
+pub const ENOSYS: c_int = 0x26;
+pub const ENOTCONN: c_int = 0x6b;
+pub const ENOTEMPTY: c_int = 0x27;
+pub const ENOTNAM: c_int = 0x76;
+pub const ENOTRECOVERABLE: c_int = 0x83;
+pub const ENOTSOCK: c_int = 0x58;
+pub const ENOTUNIQ: c_int = 0x4c;
+pub const EOPNOTSUPP: c_int = 0x5f;
+pub const EOVERFLOW: c_int = 0x4b;
+pub const EOWNERDEAD: c_int = 0x82;
+pub const EPFNOSUPPORT: c_int = 0x60;
+pub const EPOLL_CLOEXEC: c_int = 0x80000;
+pub const EPROTO: c_int = 0x47;
+pub const EPROTONOSUPPORT: c_int = 0x5d;
+pub const EPROTOTYPE: c_int = 0x5b;
+pub const EREMCHG: c_int = 0x4e;
+pub const EREMOTE: c_int = 0x42;
+pub const EREMOTEIO: c_int = 0x79;
+pub const ERESTART: c_int = 0x55;
+pub const ESHUTDOWN: c_int = 0x6c;
+pub const ESOCKTNOSUPPORT: c_int = 0x5e;
+pub const ESRMNT: c_int = 0x45;
+pub const ESTALE: c_int = 0x74;
+pub const ESTRPIPE: c_int = 0x56;
+pub const ETIME: c_int = 0x3e;
+pub const ETIMEDOUT: c_int = 0x6e;
+pub const ETOOMANYREFS: c_int = 0x6d;
+pub const EUCLEAN: c_int = 0x75;
+pub const EUNATCH: c_int = 0x31;
+pub const EUSERS: c_int = 0x57;
+pub const EXFULL: c_int = 0x36;
+pub const FF1: c_int = 0x8000;
+pub const FFDLY: c_int = 0x8000;
+pub const FLUSHO: crate::tcflag_t = 0x1000;
+pub const F_GETLK: c_int = 0x5;
+pub const F_SETLK: c_int = 0x6;
+pub const F_SETLKW: c_int = 0x7;
+pub const HUPCL: crate::tcflag_t = 0x400;
+pub const ICANON: crate::tcflag_t = 0x2;
+pub const IEXTEN: crate::tcflag_t = 0x8000;
+pub const ISIG: crate::tcflag_t = 0x1;
+pub const IXOFF: crate::tcflag_t = 0x1000;
+pub const IXON: crate::tcflag_t = 0x400;
+pub const MAP_ANON: c_int = 0x20;
+pub const MAP_ANONYMOUS: c_int = 0x20;
+pub const MAP_DENYWRITE: c_int = 0x800;
+pub const MAP_EXECUTABLE: c_int = 0x1000;
+pub const MAP_GROWSDOWN: c_int = 0x100;
+pub const MAP_LOCKED: c_int = 0x2000;
+pub const MAP_NONBLOCK: c_int = 0x10000;
+pub const MAP_NORESERVE: c_int = 0x4000;
+pub const MAP_POPULATE: c_int = 0x8000;
+pub const MAP_STACK: c_int = 0x20000;
+pub const MINSIGSTKSZ: c_int = 5120;
+pub const NLDLY: crate::tcflag_t = 0x100;
+pub const NOFLSH: crate::tcflag_t = 0x80;
+pub const OLCUC: crate::tcflag_t = 0x2;
+pub const ONLCR: crate::tcflag_t = 0x4;
+pub const O_ACCMODE: c_int = 0x3;
+pub const O_APPEND: c_int = 0x400;
+pub const O_ASYNC: c_int = 0o20000;
+pub const O_CREAT: c_int = 0x40;
+pub const O_DIRECT: c_int = 0x10000;
+pub const O_DIRECTORY: c_int = 0x4000;
+pub const O_DSYNC: c_int = O_SYNC;
+pub const O_EXCL: c_int = 0x80;
+pub const O_FSYNC: c_int = O_SYNC;
+pub const O_LARGEFILE: c_int = 0o400000;
+pub const O_NDELAY: c_int = O_NONBLOCK;
+pub const O_NOATIME: c_int = 0o1000000;
+pub const O_NOCTTY: c_int = 0x100;
+pub const O_NOFOLLOW: c_int = 0x8000;
+pub const O_NONBLOCK: c_int = 0x800;
+pub const O_PATH: c_int = 0o10000000;
+pub const O_RSYNC: c_int = O_SYNC;
+pub const O_SYNC: c_int = 0o10000;
+pub const O_TRUNC: c_int = 0x200;
+pub const PARENB: crate::tcflag_t = 0x100;
+pub const PARODD: crate::tcflag_t = 0x200;
+pub const PENDIN: crate::tcflag_t = 0x4000;
+pub const POLLWRBAND: c_short = 0x200;
+pub const POLLWRNORM: c_short = 0x100;
+pub const RTLD_GLOBAL: c_int = 0x00100;
+
+// These are typed unsigned to match sigaction
+pub const SA_NOCLDSTOP: c_ulong = 0x1;
+pub const SA_NOCLDWAIT: c_ulong = 0x2;
+pub const SA_SIGINFO: c_ulong = 0x4;
+pub const SA_NODEFER: c_ulong = 0x40000000;
+pub const SA_ONSTACK: c_ulong = 0x8000000;
+pub const SA_RESETHAND: c_ulong = 0x80000000;
+pub const SA_RESTART: c_ulong = 0x10000000;
+
+pub const SIGBUS: c_int = 0x7;
+pub const SIGCHLD: c_int = 0x11;
+pub const SIGCONT: c_int = 0x12;
+pub const SIGIO: c_int = 0x1d;
+pub const SIGPOLL: c_int = SIGIO;
+pub const SIGPROF: c_int = 0x1b;
+pub const SIGPWR: c_int = 0x1e;
+pub const SIGSTKFLT: c_int = 0x10;
+pub const SIGSTKSZ: c_int = 16384;
+pub const SIGSTOP: c_int = 0x13;
+pub const SIGSYS: c_int = 0x1f;
+pub const SIGTSTP: c_int = 0x14;
+pub const SIGTTIN: c_int = 0x15;
+pub const SIGTTOU: c_int = 0x16;
+pub const SIGURG: c_int = 0x17;
+pub const SIGUSR1: c_int = 0xa;
+pub const SIGUSR2: c_int = 0xc;
+pub const SIGVTALRM: c_int = 0x1a;
+pub const SIGWINCH: c_int = 0x1c;
+pub const SIGXCPU: c_int = 0x18;
+pub const SIGXFSZ: c_int = 0x19;
+pub const SIG_BLOCK: c_int = 0;
+pub const SIG_UNBLOCK: c_int = 0x1;
+pub const SIG_SETMASK: c_int = 0x2;
+pub const SOCK_DGRAM: c_int = 0x2;
+pub const SOCK_NONBLOCK: c_int = 0o0004000;
+pub const SOCK_SEQPACKET: c_int = 0x5;
+pub const SOCK_STREAM: c_int = 0x1;
+
+pub const TAB1: c_int = 0x800;
+pub const TAB2: c_int = 0x1000;
+pub const TAB3: c_int = 0x1800;
+pub const TABDLY: c_int = 0x1800;
+pub const TCSADRAIN: c_int = 0x1;
+pub const TCSAFLUSH: c_int = 0x2;
+pub const TCSANOW: c_int = 0;
+pub const TOSTOP: crate::tcflag_t = 0x100;
+pub const VDISCARD: usize = 0xd;
+pub const VEOF: usize = 0x4;
+pub const VEOL: usize = 0xb;
+pub const VEOL2: usize = 0x10;
+pub const VMIN: usize = 0x6;
+pub const VREPRINT: usize = 0xc;
+pub const VSTART: usize = 0x8;
+pub const VSTOP: usize = 0x9;
+pub const VSUSP: usize = 0xa;
+pub const VSWTC: usize = 0x7;
+pub const VT1: c_int = 0x4000;
+pub const VTDLY: c_int = 0x4000;
+pub const VTIME: usize = 0x5;
+pub const VWERASE: usize = 0xe;
+pub const XTABS: crate::tcflag_t = 0x1800;
diff --git a/src/unix/linux_like/l4re/uclibc/mod.rs b/src/unix/linux_like/l4re/uclibc/mod.rs
new file mode 100644
index 000000000..d176123da
--- /dev/null
+++ b/src/unix/linux_like/l4re/uclibc/mod.rs
@@ -0,0 +1,450 @@
+use crate::off64_t;
+use crate::prelude::*;
+
+pub type shmatt_t = c_ulong;
+pub type regoff_t = c_int;
+pub type rlim_t = c_ulong;
+pub type __rlimit_resource_t = c_int;
+pub type __priority_which_t = c_uint;
+
+cfg_if! {
+    if #[cfg(doc)] {
+        // Used in `linux::arch` to define ioctl constants.
+        pub(crate) type Ioctl = c_ulong;
+    } else {
+        #[doc(hidden)]
+        pub type Ioctl = c_ulong;
+    }
+}
+
+s! {
+    pub struct cmsghdr {
+        pub cmsg_len: crate::size_t,
+        pub cmsg_level: c_int,
+        pub cmsg_type: c_int,
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut c_void,
+        pub msg_namelen: crate::socklen_t,
+        pub msg_iov: *mut crate::iovec,
+        #[cfg(target_pointer_width = "32")]
+        pub msg_iovlen: c_int,
+        #[cfg(target_pointer_width = "64")]
+        pub msg_iovlen: crate::size_t,
+        pub msg_control: *mut c_void,
+        #[cfg(target_pointer_width = "32")]
+        pub msg_controllen: crate::socklen_t,
+        #[cfg(target_pointer_width = "64")]
+        pub msg_controllen: crate::size_t,
+        pub msg_flags: c_int,
+    }
+
+    pub struct statfs {
+        pub f_type: fsword_t,
+        pub f_bsize: fsword_t,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_fsid: crate::fsid_t,
+        pub f_namelen: fsword_t,
+        pub f_frsize: fsword_t,
+        pub f_flags: fsword_t,
+        pub f_spare: [fsword_t; 4],
+    }
+
+    pub struct statfs64 {
+        pub f_type: fsword_t,
+        pub f_bsize: fsword_t,
+        pub f_blocks: crate::fsblkcnt64_t,
+        pub f_bfree: crate::fsblkcnt64_t,
+        pub f_bavail: crate::fsblkcnt64_t,
+        pub f_files: crate::fsfilcnt64_t,
+        pub f_ffree: crate::fsfilcnt64_t,
+        pub f_fsid: crate::fsid_t,
+        pub f_namelen: fsword_t,
+        pub f_frsize: fsword_t,
+        pub f_flags: fsword_t,
+        pub f_spare: [fsword_t; 4],
+    }
+
+    pub struct statvfs64 {
+        pub f_bsize: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_blocks: crate::fsfilcnt64_t,
+        pub f_bfree: crate::fsfilcnt64_t,
+        pub f_bavail: crate::fsfilcnt64_t,
+        pub f_files: crate::fsfilcnt64_t,
+        pub f_ffree: crate::fsfilcnt64_t,
+        pub f_favail: crate::fsfilcnt64_t,
+        pub f_fsid: c_ulong,
+        pub f_flag: c_ulong,
+        pub f_namemax: c_ulong,
+        pub __f_spare: [c_int; 6],
+    }
+
+    pub struct ipc_perm {
+        pub __key: crate::key_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+        pub cuid: crate::uid_t,
+        pub cgid: crate::gid_t,
+        #[cfg(target_pointer_width = "32")]
+        pub mode: c_ushort,
+        #[cfg(target_pointer_width = "64")]
+        pub mode: c_uint,
+        #[cfg(target_pointer_width = "32")]
+        __pad1: c_ushort,
+        pub __seq: c_ushort,
+        __pad2: c_ushort,
+        __unused1: c_ulong,
+        __unused2: c_ulong,
+    }
+
+    pub struct statvfs {
+        // Different than GNU!
+        pub f_bsize: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_favail: crate::fsfilcnt_t,
+        #[cfg(target_endian = "little")]
+        pub f_fsid: c_ulong,
+        #[cfg(target_pointer_width = "32")]
+        __f_unused: c_int,
+        #[cfg(target_endian = "big")]
+        pub f_fsid: c_ulong,
+        pub f_flag: c_ulong,
+        pub f_namemax: c_ulong,
+        __f_spare: [c_int; 6],
+    }
+
+    pub struct sysinfo {
+        pub uptime: c_long,
+        pub loads: [c_ulong; 3],
+        pub totalram: c_ulong,
+        pub freeram: c_ulong,
+        pub sharedram: c_ulong,
+        pub bufferram: c_ulong,
+        pub totalswap: c_ulong,
+        pub freeswap: c_ulong,
+        pub procs: c_ushort,
+        pub pad: c_ushort,
+        pub totalhigh: c_ulong,
+        pub freehigh: c_ulong,
+        pub mem_unit: c_uint,
+        #[cfg(target_pointer_width = "32")]
+        pub _f: [c_char; 8],
+        #[cfg(target_pointer_width = "64")]
+        pub _f: [c_char; 0],
+    }
+
+    pub struct regex_t {
+        __buffer: *mut c_void,
+        __allocated: size_t,
+        __used: size_t,
+        __syntax: c_ulong,
+        __fastmap: *mut c_char,
+        __translate: *mut c_char,
+        __re_nsub: size_t,
+        __bitfield: u8,
+    }
+
+    pub struct rtentry {
+        pub rt_pad1: c_ulong,
+        pub rt_dst: crate::sockaddr,
+        pub rt_gateway: crate::sockaddr,
+        pub rt_genmask: crate::sockaddr,
+        pub rt_flags: c_ushort,
+        pub rt_pad2: c_short,
+        pub rt_pad3: c_ulong,
+        pub rt_tos: c_uchar,
+        pub rt_class: c_uchar,
+        #[cfg(target_pointer_width = "64")]
+        pub rt_pad4: [c_short; 3usize],
+        #[cfg(not(target_pointer_width = "64"))]
+        pub rt_pad4: c_short,
+        pub rt_metric: c_short,
+        pub rt_dev: *mut c_char,
+        pub rt_mtu: c_ulong,
+        pub rt_window: c_ulong,
+        pub rt_irtt: c_ushort,
+    }
+
+    pub struct __exit_status {
+        pub e_termination: c_short,
+        pub e_exit: c_short,
+    }
+
+    pub struct tcp_info {
+        pub tcpi_state: u8,
+        pub tcpi_ca_state: u8,
+        pub tcpi_retransmits: u8,
+        pub tcpi_probes: u8,
+        pub tcpi_backoff: u8,
+        pub tcpi_options: u8,
+        /// This contains the bitfields `tcpi_snd_wscale` and `tcpi_rcv_wscale`.
+        /// Each is 4 bits.
+        pub tcpi_snd_rcv_wscale: u8,
+        pub tcpi_rto: u32,
+        pub tcpi_ato: u32,
+        pub tcpi_snd_mss: u32,
+        pub tcpi_rcv_mss: u32,
+        pub tcpi_unacked: u32,
+        pub tcpi_sacked: u32,
+        pub tcpi_lost: u32,
+        pub tcpi_retrans: u32,
+        pub tcpi_fackets: u32,
+        pub tcpi_last_data_sent: u32,
+        pub tcpi_last_ack_sent: u32,
+        pub tcpi_last_data_recv: u32,
+        pub tcpi_last_ack_recv: u32,
+        pub tcpi_pmtu: u32,
+        pub tcpi_rcv_ssthresh: u32,
+        pub tcpi_rtt: u32,
+        pub tcpi_rttvar: u32,
+        pub tcpi_snd_ssthresh: u32,
+        pub tcpi_snd_cwnd: u32,
+        pub tcpi_advmss: u32,
+        pub tcpi_reordering: u32,
+        pub tcpi_rcv_rtt: u32,
+        pub tcpi_rcv_space: u32,
+        pub tcpi_total_retrans: u32,
+    }
+
+    pub struct __sched_param {
+        __sched_priority: c_int,
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_addr(&self) -> *mut c_void {
+        #[repr(C)]
+        struct siginfo_sigfault {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            si_addr: *mut c_void,
+        }
+        (*core::ptr::from_ref(self).cast::<siginfo_sigfault>()).si_addr
+    }
+
+    pub unsafe fn si_value(&self) -> crate::sigval {
+        #[repr(C)]
+        struct siginfo_si_value {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            _si_timerid: c_int,
+            _si_overrun: c_int,
+            si_value: crate::sigval,
+        }
+        (*core::ptr::from_ref(self).cast::<siginfo_si_value>()).si_value
+    }
+}
+
+// Internal, for casts to access union fields
+#[repr(C)]
+struct sifields_sigchld {
+    si_pid: crate::pid_t,
+    si_uid: crate::uid_t,
+    si_status: c_int,
+    si_utime: c_long,
+    si_stime: c_long,
+}
+impl Copy for sifields_sigchld {}
+impl Clone for sifields_sigchld {
+    fn clone(&self) -> sifields_sigchld {
+        *self
+    }
+}
+
+// Internal, for casts to access union fields
+#[repr(C)]
+union sifields {
+    _align_pointer: *mut c_void,
+    sigchld: sifields_sigchld,
+}
+
+// Internal, for casts to access union fields. Note that some variants
+// of sifields start with a pointer, which makes the alignment of
+// sifields vary on 32-bit and 64-bit architectures.
+#[repr(C)]
+struct siginfo_f {
+    _siginfo_base: [c_int; 3],
+    sifields: sifields,
+}
+
+impl siginfo_t {
+    unsafe fn sifields(&self) -> &sifields {
+        &(*core::ptr::from_ref(self).cast::<siginfo_f>()).sifields
+    }
+
+    pub unsafe fn si_pid(&self) -> crate::pid_t {
+        self.sifields().sigchld.si_pid
+    }
+
+    pub unsafe fn si_uid(&self) -> crate::uid_t {
+        self.sifields().sigchld.si_uid
+    }
+
+    pub unsafe fn si_status(&self) -> c_int {
+        self.sifields().sigchld.si_status
+    }
+
+    pub unsafe fn si_utime(&self) -> c_long {
+        self.sifields().sigchld.si_utime
+    }
+
+    pub unsafe fn si_stime(&self) -> c_long {
+        self.sifields().sigchld.si_stime
+    }
+}
+
+pub const MCL_CURRENT: c_int = 0x0001;
+pub const MCL_FUTURE: c_int = 0x0002;
+pub const MCL_ONFAULT: c_int = 0x0004;
+
+pub const SIGEV_THREAD_ID: c_int = 4;
+
+pub const AF_VSOCK: c_int = 40;
+
+pub const POSIX_FADV_DONTNEED: c_int = 4;
+pub const POSIX_FADV_NOREUSE: c_int = 5;
+
+// These are different than GNU!
+pub const LC_CTYPE: c_int = 0;
+pub const LC_NUMERIC: c_int = 1;
+pub const LC_TIME: c_int = 3;
+pub const LC_COLLATE: c_int = 4;
+pub const LC_MONETARY: c_int = 2;
+pub const LC_MESSAGES: c_int = 5;
+pub const LC_ALL: c_int = 6;
+// end different section
+
+// MS_ flags for mount(2)
+pub const MS_RMT_MASK: c_ulong =
+    crate::MS_RDONLY | crate::MS_SYNCHRONOUS | crate::MS_MANDLOCK | crate::MS_I_VERSION;
+
+pub const ENOTSUP: c_int = EOPNOTSUPP;
+
+pub const IPV6_JOIN_GROUP: c_int = 20;
+pub const IPV6_LEAVE_GROUP: c_int = 21;
+
+// Different than Gnu.
+pub const FILENAME_MAX: c_uint = 4095;
+
+pub const PRIO_PROCESS: c_int = 0;
+pub const PRIO_PGRP: c_int = 1;
+pub const PRIO_USER: c_int = 2;
+
+pub const SOMAXCONN: c_int = 128;
+
+pub const ST_RELATIME: c_ulong = 4096;
+
+pub const SO_TIMESTAMP: c_int = 29;
+
+pub const RLIM_INFINITY: crate::rlim_t = !0;
+
+pub const AF_NFC: c_int = PF_NFC;
+pub const BUFSIZ: c_int = 256;
+pub const EDEADLK: c_int = 0x23;
+pub const EDEADLOCK: c_int = EDEADLK;
+pub const EXTA: c_uint = B19200;
+pub const EXTB: c_uint = B38400;
+pub const EXTPROC: crate::tcflag_t = 0o200000;
+pub const FOPEN_MAX: c_int = 16;
+pub const F_GETOWN: c_int = 9;
+pub const F_OFD_GETLK: c_int = 36;
+pub const F_OFD_SETLK: c_int = 37;
+pub const F_OFD_SETLKW: c_int = 38;
+pub const F_RDLCK: c_int = 0;
+pub const F_SETOWN: c_int = 8;
+pub const F_UNLCK: c_int = 2;
+pub const F_WRLCK: c_int = 1;
+pub const IPV6_MULTICAST_ALL: c_int = 29;
+pub const IPV6_ROUTER_ALERT_ISOLATE: c_int = 30;
+pub const MAP_HUGE_SHIFT: c_int = 26;
+pub const MAP_HUGE_MASK: c_int = 0x3f;
+pub const MSG_COPY: c_int = 0o40000;
+pub const NI_MAXHOST: crate::socklen_t = 1025;
+pub const O_TMPFILE: c_int = 0o20000000 | O_DIRECTORY;
+pub const PACKET_MR_UNICAST: c_int = 3;
+pub const PF_NFC: c_int = 39;
+pub const PF_VSOCK: c_int = 40;
+pub const RTLD_NOLOAD: c_int = 0x00004;
+pub const RUSAGE_THREAD: c_int = 1;
+pub const SHM_EXEC: c_int = 0o100000;
+pub const SOCK_DCCP: c_int = 6;
+#[deprecated(since = "0.2.70", note = "AF_PACKET must be used instead")]
+pub const SOCK_PACKET: c_int = 10;
+pub const TCP_COOKIE_TRANSACTIONS: c_int = 15;
+pub const UDP_GRO: c_int = 104;
+pub const UDP_SEGMENT: c_int = 103;
+
+pub const PTHREAD_RWLOCK_INITIALIZER: crate::pthread_rwlock_t = crate::pthread_rwlock_t {
+    size: {
+        let mut arr = [0; __SIZEOF_PTHREAD_RWLOCK_T];
+        arr[__SIZEOF_PTHREAD_RWLOCK_T - 8] = 1;
+        arr
+    },
+};
+
+extern "C" {
+    pub fn gettimeofday(tp: *mut crate::timeval, tz: *mut crate::timezone) -> c_int;
+
+    pub fn pthread_rwlockattr_getkind_np(
+        attr: *const crate::pthread_rwlockattr_t,
+        val: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_rwlockattr_setkind_np(
+        attr: *mut crate::pthread_rwlockattr_t,
+        val: c_int,
+    ) -> c_int;
+
+    pub fn openpty(
+        amaster: *mut c_int,
+        aslave: *mut c_int,
+        name: *mut c_char,
+        termp: *mut termios,
+        winp: *mut crate::winsize,
+    ) -> c_int;
+
+    pub fn getnameinfo(
+        sa: *const crate::sockaddr,
+        salen: crate::socklen_t,
+        host: *mut c_char,
+        hostlen: crate::socklen_t,
+        serv: *mut c_char,
+        servlen: crate::socklen_t,
+        flags: c_int,
+    ) -> c_int;
+
+    pub fn pwritev(fd: c_int, iov: *const crate::iovec, iovcnt: c_int, offset: off64_t) -> ssize_t;
+    pub fn preadv(fd: c_int, iov: *const crate::iovec, iovcnt: c_int, offset: off64_t) -> ssize_t;
+
+    pub fn getrlimit64(resource: crate::__rlimit_resource_t, rlim: *mut crate::rlimit64) -> c_int;
+    pub fn setrlimit64(resource: crate::__rlimit_resource_t, rlim: *const crate::rlimit64)
+        -> c_int;
+    pub fn getrlimit(resource: crate::__rlimit_resource_t, rlim: *mut crate::rlimit) -> c_int;
+    pub fn setrlimit(resource: crate::__rlimit_resource_t, rlim: *const crate::rlimit) -> c_int;
+    pub fn getauxval(type_: c_ulong) -> c_ulong;
+
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else {
+        pub use unsupported_target;
+    }
+}
diff --git a/src/unix/linux_like/l4re/uclibc/x86_64/mod.rs b/src/unix/linux_like/l4re/uclibc/x86_64/mod.rs
new file mode 100644
index 000000000..bb4b2ed4a
--- /dev/null
+++ b/src/unix/linux_like/l4re/uclibc/x86_64/mod.rs
@@ -0,0 +1,416 @@
+//! Definitions for uclibc on 64bit systems
+
+use crate::prelude::*;
+
+pub type wchar_t = c_int;
+pub type time_t = c_long;
+
+pub type clock_t = c_long;
+pub type fsblkcnt_t = c_ulong;
+pub type fsfilcnt_t = c_ulong;
+pub type ino_t = c_ulong;
+pub type nlink_t = c_ulong;
+pub type off_t = c_long;
+pub type fsword_t = c_long;
+pub type suseconds_t = c_long;
+
+pub type blksize_t = c_long;
+pub type blkcnt_t = c_long;
+
+pub type fsblkcnt64_t = c_ulong;
+pub type fsfilcnt64_t = c_ulong;
+
+pub type __u32 = c_uint;
+pub type __u64 = c_ulong;
+
+s! {
+    pub struct stat {
+        pub st_dev: c_ulong,
+        pub st_ino: crate::ino_t,
+        // According to uclibc/libc/sysdeps/linux/x86_64/bits/stat.h, order of
+        // nlink and mode are swapped on 64 bit systems.
+        pub st_nlink: nlink_t,
+        pub st_mode: crate::mode_t,
+        pub st_uid: crate::uid_t,
+        pub st_gid: crate::gid_t,
+        __pad0: c_int,
+        pub st_rdev: c_ulong,
+        pub st_size: crate::off_t,
+        pub st_blksize: crate::blksize_t,
+        pub st_blocks: crate::blkcnt64_t,
+        pub st_atim: crate::timespec,
+        pub st_mtim: crate::timespec,
+        pub st_ctim: crate::timespec,
+        __uclibc_unused: [c_long; 3],
+    }
+
+    pub struct stat64 {
+        pub st_dev: c_ulong,
+        pub st_ino: crate::ino_t,
+        pub st_nlink: nlink_t,
+        pub st_mode: crate::mode_t,
+        pub st_uid: crate::uid_t,
+        pub st_gid: crate::gid_t,
+        __pad0: c_int,
+        pub st_rdev: c_ulong,
+        pub st_size: crate::off_t,
+        pub st_blksize: crate::blksize_t,
+        pub st_blocks: crate::blkcnt64_t,
+        pub st_atim: crate::timespec,
+        pub st_mtim: crate::timespec,
+        pub st_ctim: crate::timespec,
+        st_pad4: [c_long; 3],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: crate::ipc_perm,
+        pub shm_segsz: crate::size_t,
+        pub shm_atime: crate::time_t,
+        pub shm_dtime: crate::time_t,
+        pub shm_ctime: crate::time_t,
+        pub shm_cpid: crate::pid_t,
+        pub shm_lpid: crate::pid_t,
+        pub shm_nattch: crate::shmatt_t,
+        __unused4: c_ulong,
+        __unused5: c_ulong,
+    }
+
+    #[allow(unpredictable_function_pointer_comparisons)]
+    pub struct sigaction {
+        pub sa_handler: crate::sighandler_t,
+        pub sa_flags: c_ulong,
+        pub sa_restorer: Option<extern "C" fn()>,
+        pub sa_mask: sigset_t,
+    }
+
+    pub struct sigset_t {
+        __val: [c_ulong; 1],
+    }
+
+    #[repr(align(8))]
+    pub struct siginfo_t {
+        pub si_signo: c_int,
+        pub si_errno: c_int,
+        pub si_code: c_int,
+        pub _pad: [c_int; 28],
+    }
+
+    pub struct stack_t {
+        pub ss_sp: *mut c_void,
+        pub ss_flags: c_int,
+        pub ss_size: crate::size_t,
+    }
+
+    pub struct flock {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: off_t,
+        pub l_len: off_t,
+        pub l_pid: crate::pid_t,
+    }
+
+    pub struct termios {
+        pub c_iflag: crate::tcflag_t,
+        pub c_oflag: crate::tcflag_t,
+        pub c_cflag: crate::tcflag_t,
+        pub c_lflag: crate::tcflag_t,
+        pub c_line: crate::cc_t,
+        pub c_cc: [crate::cc_t; crate::NCCS],
+        pub c_ispeed: crate::speed_t,
+        pub c_ospeed: crate::speed_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub union sem_t {
+        #[cfg(target_pointer_width = "32")]
+        __size: [c_char; 16],
+        #[cfg(target_pointer_width = "64")]
+        __size: [c_char; 32],
+        __align: [c_long; 0],
+    }
+}
+
+pub const O_CLOEXEC: c_int = 0o2000000;
+pub const __SIZEOF_PTHREAD_ATTR_T: usize = 36;
+pub const __SIZEOF_PTHREAD_MUTEX_T: usize = 40;
+pub const __SIZEOF_PTHREAD_MUTEXATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+pub const __SIZEOF_PTHREAD_COND_COMPAT_T: usize = 12;
+pub const __SIZEOF_PTHREAD_CONDATTR_T: usize = 4;
+pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
+pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
+pub const __SIZEOF_PTHREAD_BARRIER_T: usize = 32;
+pub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;
+
+pub const NCCS: usize = 32;
+
+pub const FIOQSIZE: crate::Ioctl = 0x5460;
+
+// I wasn't able to find those constants
+// in uclibc build environment for armv7
+pub const MAP_HUGETLB: c_int = 0x040000; // from linux/other/mod.rs
+
+// autogenerated constants with hand tuned types
+pub const B0: crate::speed_t = 0;
+pub const B1000000: crate::speed_t = 0x1008;
+pub const B110: crate::speed_t = 0x3;
+pub const B115200: crate::speed_t = 0x1002;
+pub const B1152000: crate::speed_t = 0x1009;
+pub const B1200: crate::speed_t = 0x9;
+pub const B134: crate::speed_t = 0x4;
+pub const B150: crate::speed_t = 0x5;
+pub const B1500000: crate::speed_t = 0x100a;
+pub const B1800: crate::speed_t = 0xa;
+pub const B19200: crate::speed_t = 0xe;
+pub const B200: crate::speed_t = 0x6;
+pub const B2000000: crate::speed_t = 0x100b;
+pub const B230400: crate::speed_t = 0x1003;
+pub const B2400: crate::speed_t = 0xb;
+pub const B2500000: crate::speed_t = 0x100c;
+pub const B300: crate::speed_t = 0x7;
+pub const B3000000: crate::speed_t = 0x100d;
+pub const B3500000: crate::speed_t = 0x100e;
+pub const B38400: crate::speed_t = 0xf;
+pub const B4000000: crate::speed_t = 0x100f;
+pub const B460800: crate::speed_t = 0x1004;
+pub const B4800: crate::speed_t = 0xc;
+pub const B50: crate::speed_t = 0x1;
+pub const B500000: crate::speed_t = 0x1005;
+pub const B57600: crate::speed_t = 0x1001;
+pub const B576000: crate::speed_t = 0x1006;
+pub const B600: crate::speed_t = 0x8;
+pub const B75: crate::speed_t = 0x2;
+pub const B921600: crate::speed_t = 0x1007;
+pub const B9600: crate::speed_t = 0xd;
+pub const BS1: c_int = 0x2000;
+pub const BSDLY: c_int = 0x2000;
+pub const CBAUD: crate::tcflag_t = 0x100f;
+pub const CBAUDEX: crate::tcflag_t = 0x1000;
+pub const CIBAUD: crate::tcflag_t = 0x100f0000;
+pub const CLOCAL: crate::tcflag_t = 0x800;
+pub const CPU_SETSIZE: c_int = 0x400;
+pub const CR1: c_int = 0x200;
+pub const CR2: c_int = 0x400;
+pub const CR3: c_int = 0x600;
+pub const CRDLY: c_int = 0x600;
+pub const CREAD: crate::tcflag_t = 0x80;
+pub const CS6: crate::tcflag_t = 0x10;
+pub const CS7: crate::tcflag_t = 0x20;
+pub const CS8: crate::tcflag_t = 0x30;
+pub const CSIZE: crate::tcflag_t = 0x30;
+pub const CSTOPB: crate::tcflag_t = 0x40;
+pub const EADDRINUSE: c_int = 0x62;
+pub const EADDRNOTAVAIL: c_int = 0x63;
+pub const EADV: c_int = 0x44;
+pub const EAFNOSUPPORT: c_int = 0x61;
+pub const EALREADY: c_int = 0x72;
+pub const EBADE: c_int = 0x34;
+pub const EBADFD: c_int = 0x4d;
+pub const EBADMSG: c_int = 0x4a;
+pub const EBADR: c_int = 0x35;
+pub const EBADRQC: c_int = 0x38;
+pub const EBADSLT: c_int = 0x39;
+pub const EBFONT: c_int = 0x3b;
+pub const ECANCELED: c_int = 0x7d;
+pub const ECHOCTL: crate::tcflag_t = 0x200;
+pub const ECHOE: crate::tcflag_t = 0x10;
+pub const ECHOK: crate::tcflag_t = 0x20;
+pub const ECHOKE: crate::tcflag_t = 0x800;
+pub const ECHONL: crate::tcflag_t = 0x40;
+pub const ECHOPRT: crate::tcflag_t = 0x400;
+pub const ECHRNG: c_int = 0x2c;
+pub const ECOMM: c_int = 0x46;
+pub const ECONNABORTED: c_int = 0x67;
+pub const ECONNREFUSED: c_int = 0x6f;
+pub const ECONNRESET: c_int = 0x68;
+pub const EDESTADDRREQ: c_int = 0x59;
+pub const EDOTDOT: c_int = 0x49;
+pub const EDQUOT: c_int = 0x7a;
+pub const EHOSTDOWN: c_int = 0x70;
+pub const EHOSTUNREACH: c_int = 0x71;
+pub const EIDRM: c_int = 0x2b;
+pub const EILSEQ: c_int = 0x54;
+pub const EINPROGRESS: c_int = 0x73;
+pub const EISCONN: c_int = 0x6a;
+pub const EISNAM: c_int = 0x78;
+pub const EKEYEXPIRED: c_int = 0x7f;
+pub const EKEYREJECTED: c_int = 0x81;
+pub const EKEYREVOKED: c_int = 0x80;
+pub const EL2HLT: c_int = 0x33;
+pub const EL2NSYNC: c_int = 0x2d;
+pub const EL3HLT: c_int = 0x2e;
+pub const EL3RST: c_int = 0x2f;
+pub const ELIBACC: c_int = 0x4f;
+pub const ELIBBAD: c_int = 0x50;
+pub const ELIBEXEC: c_int = 0x53;
+pub const ELIBMAX: c_int = 0x52;
+pub const ELIBSCN: c_int = 0x51;
+pub const ELNRNG: c_int = 0x30;
+pub const ELOOP: c_int = 0x28;
+pub const EMEDIUMTYPE: c_int = 0x7c;
+pub const EMSGSIZE: c_int = 0x5a;
+pub const EMULTIHOP: c_int = 0x48;
+pub const ENAMETOOLONG: c_int = 0x24;
+pub const ENAVAIL: c_int = 0x77;
+pub const ENETDOWN: c_int = 0x64;
+pub const ENETRESET: c_int = 0x66;
+pub const ENETUNREACH: c_int = 0x65;
+pub const ENOANO: c_int = 0x37;
+pub const ENOBUFS: c_int = 0x69;
+pub const ENOCSI: c_int = 0x32;
+pub const ENODATA: c_int = 0x3d;
+pub const ENOKEY: c_int = 0x7e;
+pub const ENOLCK: c_int = 0x25;
+pub const ENOLINK: c_int = 0x43;
+pub const ENOMEDIUM: c_int = 0x7b;
+pub const ENOMSG: c_int = 0x2a;
+pub const ENONET: c_int = 0x40;
+pub const ENOPKG: c_int = 0x41;
+pub const ENOPROTOOPT: c_int = 0x5c;
+pub const ENOSR: c_int = 0x3f;
+pub const ENOSTR: c_int = 0x3c;
+pub const ENOSYS: c_int = 0x26;
+pub const ENOTCONN: c_int = 0x6b;
+pub const ENOTEMPTY: c_int = 0x27;
+pub const ENOTNAM: c_int = 0x76;
+pub const ENOTRECOVERABLE: c_int = 0x83;
+pub const ENOTSOCK: c_int = 0x58;
+pub const ENOTUNIQ: c_int = 0x4c;
+pub const EOPNOTSUPP: c_int = 0x5f;
+pub const EOVERFLOW: c_int = 0x4b;
+pub const EOWNERDEAD: c_int = 0x82;
+pub const EPFNOSUPPORT: c_int = 0x60;
+pub const EPOLL_CLOEXEC: c_int = 0x80000;
+pub const EPROTO: c_int = 0x47;
+pub const EPROTONOSUPPORT: c_int = 0x5d;
+pub const EPROTOTYPE: c_int = 0x5b;
+pub const EREMCHG: c_int = 0x4e;
+pub const EREMOTE: c_int = 0x42;
+pub const EREMOTEIO: c_int = 0x79;
+pub const ERESTART: c_int = 0x55;
+pub const ESHUTDOWN: c_int = 0x6c;
+pub const ESOCKTNOSUPPORT: c_int = 0x5e;
+pub const ESRMNT: c_int = 0x45;
+pub const ESTALE: c_int = 0x74;
+pub const ESTRPIPE: c_int = 0x56;
+pub const ETIME: c_int = 0x3e;
+pub const ETIMEDOUT: c_int = 0x6e;
+pub const ETOOMANYREFS: c_int = 0x6d;
+pub const EUCLEAN: c_int = 0x75;
+pub const EUNATCH: c_int = 0x31;
+pub const EUSERS: c_int = 0x57;
+pub const EXFULL: c_int = 0x36;
+pub const FF1: c_int = 0x8000;
+pub const FFDLY: c_int = 0x8000;
+pub const FLUSHO: crate::tcflag_t = 0x1000;
+pub const F_GETLK: c_int = 0x5;
+pub const F_SETLK: c_int = 0x6;
+pub const F_SETLKW: c_int = 0x7;
+pub const HUPCL: crate::tcflag_t = 0x400;
+pub const ICANON: crate::tcflag_t = 0x2;
+pub const IEXTEN: crate::tcflag_t = 0x8000;
+pub const ISIG: crate::tcflag_t = 0x1;
+pub const IXOFF: crate::tcflag_t = 0x1000;
+pub const IXON: crate::tcflag_t = 0x400;
+pub const MAP_ANON: c_int = 0x20;
+pub const MAP_ANONYMOUS: c_int = 0x20;
+pub const MAP_DENYWRITE: c_int = 0x800;
+pub const MAP_EXECUTABLE: c_int = 0x1000;
+pub const MAP_GROWSDOWN: c_int = 0x100;
+pub const MAP_LOCKED: c_int = 0x2000;
+pub const MAP_NONBLOCK: c_int = 0x10000;
+pub const MAP_NORESERVE: c_int = 0x4000;
+pub const MAP_POPULATE: c_int = 0x8000;
+pub const MAP_STACK: c_int = 0x20000;
+pub const MINSIGSTKSZ: c_int = 2048;
+pub const NLDLY: crate::tcflag_t = 0x100;
+pub const NOFLSH: crate::tcflag_t = 0x80;
+pub const OLCUC: crate::tcflag_t = 0x2;
+pub const ONLCR: crate::tcflag_t = 0x4;
+pub const O_ACCMODE: c_int = 0x3;
+pub const O_APPEND: c_int = 0x400;
+pub const O_ASYNC: c_int = 0o20000;
+pub const O_CREAT: c_int = 0x40;
+pub const O_DIRECT: c_int = 0o40000;
+pub const O_DIRECTORY: c_int = 0o200000;
+pub const O_DSYNC: c_int = O_SYNC;
+pub const O_EXCL: c_int = 0x80;
+pub const O_FSYNC: c_int = O_SYNC;
+pub const O_LARGEFILE: c_int = 0;
+pub const O_NDELAY: c_int = O_NONBLOCK;
+pub const O_NOATIME: c_int = 0o1000000;
+pub const O_NOCTTY: c_int = 0x100;
+pub const O_NOFOLLOW: c_int = 0o400000;
+pub const O_NONBLOCK: c_int = 0x800;
+pub const O_PATH: c_int = 0o10000000;
+pub const O_RSYNC: c_int = O_SYNC;
+pub const O_SYNC: c_int = 0o10000;
+pub const O_TRUNC: c_int = 0x200;
+pub const PARENB: crate::tcflag_t = 0x100;
+pub const PARODD: crate::tcflag_t = 0x200;
+pub const PENDIN: crate::tcflag_t = 0x4000;
+pub const POLLWRBAND: c_short = 0x200;
+pub const POLLWRNORM: c_short = 0x100;
+pub const RTLD_GLOBAL: c_int = 0x00100;
+
+// These are typed unsigned to match sigaction
+pub const SA_NOCLDSTOP: c_ulong = 0x1;
+pub const SA_NOCLDWAIT: c_ulong = 0x2;
+pub const SA_SIGINFO: c_ulong = 0x4;
+pub const SA_NODEFER: c_ulong = 0x40000000;
+pub const SA_ONSTACK: c_ulong = 0x8000000;
+pub const SA_RESETHAND: c_ulong = 0x80000000;
+pub const SA_RESTART: c_ulong = 0x10000000;
+
+pub const SIGBUS: c_int = 0x7;
+pub const SIGCHLD: c_int = 0x11;
+pub const SIGCONT: c_int = 0x12;
+pub const SIGIO: c_int = 0x1d;
+pub const SIGPOLL: c_int = SIGIO;
+pub const SIGPROF: c_int = 0x1b;
+pub const SIGPWR: c_int = 0x1e;
+pub const SIGSTKFLT: c_int = 0x10;
+pub const SIGSTKSZ: c_int = 8192;
+pub const SIGSTOP: c_int = 0x13;
+pub const SIGSYS: c_int = 0x1f;
+pub const SIGTSTP: c_int = 0x14;
+pub const SIGTTIN: c_int = 0x15;
+pub const SIGTTOU: c_int = 0x16;
+pub const SIGURG: c_int = 0x17;
+pub const SIGUSR1: c_int = 0xa;
+pub const SIGUSR2: c_int = 0xc;
+pub const SIGVTALRM: c_int = 0x1a;
+pub const SIGWINCH: c_int = 0x1c;
+pub const SIGXCPU: c_int = 0x18;
+pub const SIGXFSZ: c_int = 0x19;
+pub const SIG_BLOCK: c_int = 0;
+pub const SIG_UNBLOCK: c_int = 0x1;
+pub const SIG_SETMASK: c_int = 0x2;
+pub const SOCK_DGRAM: c_int = 0x2;
+pub const SOCK_NONBLOCK: c_int = 0o0004000;
+pub const SOCK_SEQPACKET: c_int = 0x5;
+pub const SOCK_STREAM: c_int = 0x1;
+pub const TAB1: c_int = 0x800;
+pub const TAB2: c_int = 0x1000;
+pub const TAB3: c_int = 0x1800;
+pub const TABDLY: c_int = 0x1800;
+pub const TCSADRAIN: c_int = 0x1;
+pub const TCSAFLUSH: c_int = 0x2;
+pub const TCSANOW: c_int = 0;
+pub const TOSTOP: crate::tcflag_t = 0x100;
+pub const VDISCARD: usize = 0xd;
+pub const VEOF: usize = 0x4;
+pub const VEOL: usize = 0xb;
+pub const VEOL2: usize = 0x10;
+pub const VMIN: usize = 0x6;
+pub const VREPRINT: usize = 0xc;
+pub const VSTART: usize = 0x8;
+pub const VSTOP: usize = 0x9;
+pub const VSUSP: usize = 0xa;
+pub const VSWTC: usize = 0x7;
+pub const VT1: c_int = 0x4000;
+pub const VTDLY: c_int = 0x4000;
+pub const VTIME: usize = 0x5;
+pub const VWERASE: usize = 0xe;
+pub const XTABS: crate::tcflag_t = 0x1800;
diff --git a/src/unix/linux_like/linux/gnu/mod.rs b/src/unix/linux_like/linux/gnu/mod.rs
index 86ade8f04..747fd16ac 100644
--- a/src/unix/linux_like/linux/gnu/mod.rs
+++ b/src/unix/linux_like/linux/gnu/mod.rs
@@ -713,7 +713,6 @@ pub const BUFSIZ: c_uint = 8192;
 pub const TMP_MAX: c_uint = 238328;
 pub const FOPEN_MAX: c_uint = 16;
 pub const FILENAME_MAX: c_uint = 4096;
-pub const POSIX_MADV_DONTNEED: c_int = 4;
 pub const _CS_GNU_LIBC_VERSION: c_int = 2;
 pub const _CS_GNU_LIBPTHREAD_VERSION: c_int = 3;
 pub const _CS_V6_ENV: c_int = 1148;
diff --git a/src/unix/linux_like/linux/mod.rs b/src/unix/linux_like/linux/mod.rs
index 770ff4fe7..512e07d5b 100644
--- a/src/unix/linux_like/linux/mod.rs
+++ b/src/unix/linux_like/linux/mod.rs
@@ -3,22 +3,7 @@
 use crate::prelude::*;
 use crate::{sock_filter, _IO, _IOR, _IOW, _IOWR};
 
-pub type useconds_t = u32;
-pub type dev_t = u64;
-pub type socklen_t = u32;
-pub type mode_t = u32;
-pub type ino64_t = u64;
-pub type off64_t = i64;
-pub type blkcnt64_t = i64;
-pub type rlim64_t = u64;
 pub type mqd_t = c_int;
-pub type nfds_t = c_ulong;
-pub type nl_item = c_int;
-pub type idtype_t = c_uint;
-pub type loff_t = c_longlong;
-pub type pthread_key_t = c_uint;
-pub type pthread_once_t = c_int;
-pub type pthread_spinlock_t = c_int;
 pub type __kernel_fsid_t = __c_anonymous__kernel_fsid_t;
 pub type __kernel_clockid_t = c_int;
 
@@ -28,52 +13,11 @@ pub type __s16 = c_short;
 pub type __u32 = c_uint;
 pub type __s32 = c_int;
 
-pub type Elf32_Half = u16;
-pub type Elf32_Word = u32;
-pub type Elf32_Off = u32;
-pub type Elf32_Addr = u32;
-pub type Elf32_Xword = u64;
-pub type Elf32_Sword = i32;
-
-pub type Elf64_Half = u16;
-pub type Elf64_Word = u32;
-pub type Elf64_Off = u64;
-pub type Elf64_Addr = u64;
-pub type Elf64_Xword = u64;
-pub type Elf64_Sxword = i64;
-pub type Elf64_Sword = i32;
-
-pub type Elf32_Section = u16;
-pub type Elf64_Section = u16;
-
-pub type Elf32_Relr = Elf32_Word;
-pub type Elf64_Relr = Elf32_Xword;
-pub type Elf32_Rel = __c_anonymous_elf32_rel;
-pub type Elf64_Rel = __c_anonymous_elf64_rel;
-
-cfg_if! {
-    if #[cfg(not(target_arch = "sparc64"))] {
-        pub type Elf32_Rela = __c_anonymous_elf32_rela;
-        pub type Elf64_Rela = __c_anonymous_elf64_rela;
-    }
-}
-
-pub type iconv_t = *mut c_void;
-
 // linux/sctp.h
 pub type sctp_assoc_t = __s32;
 
 pub type eventfd_t = u64;
 
-cfg_if! {
-    if #[cfg(not(target_env = "gnu"))] {
-        missing! {
-            #[derive(Debug)]
-            pub enum fpos64_t {} // FIXME(linux): fill this out with a struct
-        }
-    }
-}
-
 c_enum! {
     pub enum tpacket_versions {
         TPACKET_V1,
@@ -93,41 +37,6 @@ c_enum! {
 }
 
 s! {
-    pub struct glob_t {
-        pub gl_pathc: size_t,
-        pub gl_pathv: *mut *mut c_char,
-        pub gl_offs: size_t,
-        pub gl_flags: c_int,
-
-        __unused1: *mut c_void,
-        __unused2: *mut c_void,
-        __unused3: *mut c_void,
-        __unused4: *mut c_void,
-        __unused5: *mut c_void,
-    }
-
-    pub struct passwd {
-        pub pw_name: *mut c_char,
-        pub pw_passwd: *mut c_char,
-        pub pw_uid: crate::uid_t,
-        pub pw_gid: crate::gid_t,
-        pub pw_gecos: *mut c_char,
-        pub pw_dir: *mut c_char,
-        pub pw_shell: *mut c_char,
-    }
-
-    pub struct spwd {
-        pub sp_namp: *mut c_char,
-        pub sp_pwdp: *mut c_char,
-        pub sp_lstchg: c_long,
-        pub sp_min: c_long,
-        pub sp_max: c_long,
-        pub sp_warn: c_long,
-        pub sp_inact: c_long,
-        pub sp_expire: c_long,
-        pub sp_flag: c_ulong,
-    }
-
     pub struct dqblk {
         pub dqb_bhardlimit: u64,
         pub dqb_bsoftlimit: u64,
@@ -165,15 +74,6 @@ s! {
         _pad: [u8; 28],
     }
 
-    pub struct itimerspec {
-        pub it_interval: crate::timespec,
-        pub it_value: crate::timespec,
-    }
-
-    pub struct fsid_t {
-        __val: [c_int; 2],
-    }
-
     pub struct fanout_args {
         #[cfg(target_endian = "little")]
         pub id: __u16,
@@ -183,13 +83,6 @@ s! {
         pub max_num_members: __u32,
     }
 
-    pub struct packet_mreq {
-        pub mr_ifindex: c_int,
-        pub mr_type: c_ushort,
-        pub mr_alen: c_ushort,
-        pub mr_address: [c_uchar; 8],
-    }
-
     #[deprecated(since = "0.2.70", note = "sockaddr_ll type must be used instead")]
     pub struct sockaddr_pkt {
         pub spkt_family: c_ushort,
@@ -301,18 +194,6 @@ s! {
         pub ts_last_pkt: crate::tpacket_bd_ts,
     }
 
-    pub struct cpu_set_t {
-        #[cfg(all(target_pointer_width = "32", not(target_arch = "x86_64")))]
-        bits: [u32; 32],
-        #[cfg(not(all(target_pointer_width = "32", not(target_arch = "x86_64"))))]
-        bits: [u64; 16],
-    }
-
-    pub struct if_nameindex {
-        pub if_index: c_uint,
-        pub if_name: *mut c_char,
-    }
-
     // System V IPC
     pub struct msginfo {
         pub msgpool: c_int,
@@ -325,12 +206,6 @@ s! {
         pub msgseg: c_ushort,
     }
 
-    pub struct sembuf {
-        pub sem_num: c_ushort,
-        pub sem_op: c_short,
-        pub sem_flg: c_short,
-    }
-
     pub struct input_event {
         // FIXME(1.0): Change to the commented variant, see https://github.com/rust-lang/libc/pull/4148#discussion_r1857511742
         #[cfg(any(target_pointer_width = "64", not(linux_time_bits64)))]
@@ -470,169 +345,10 @@ s! {
         pub absinfo: input_absinfo,
     }
 
-    pub struct dl_phdr_info {
-        #[cfg(target_pointer_width = "64")]
-        pub dlpi_addr: Elf64_Addr,
-        #[cfg(target_pointer_width = "32")]
-        pub dlpi_addr: Elf32_Addr,
-
-        pub dlpi_name: *const c_char,
-
-        #[cfg(target_pointer_width = "64")]
-        pub dlpi_phdr: *const Elf64_Phdr,
-        #[cfg(target_pointer_width = "32")]
-        pub dlpi_phdr: *const Elf32_Phdr,
-
-        #[cfg(target_pointer_width = "64")]
-        pub dlpi_phnum: Elf64_Half,
-        #[cfg(target_pointer_width = "32")]
-        pub dlpi_phnum: Elf32_Half,
-
-        // As of uClibc 1.0.36, the following fields are
-        // gated behind a "#if 0" block which always evaluates
-        // to false. So I'm just removing these, and if uClibc changes
-        // the #if block in the future to include the following fields, these
-        // will probably need including here. tsidea, skrap
-        // QNX (NTO) platform does not define these fields
-        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
-        pub dlpi_adds: c_ulonglong,
-        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
-        pub dlpi_subs: c_ulonglong,
-        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
-        pub dlpi_tls_modid: size_t,
-        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
-        pub dlpi_tls_data: *mut c_void,
-    }
-
-    pub struct Elf32_Ehdr {
-        pub e_ident: [c_uchar; 16],
-        pub e_type: Elf32_Half,
-        pub e_machine: Elf32_Half,
-        pub e_version: Elf32_Word,
-        pub e_entry: Elf32_Addr,
-        pub e_phoff: Elf32_Off,
-        pub e_shoff: Elf32_Off,
-        pub e_flags: Elf32_Word,
-        pub e_ehsize: Elf32_Half,
-        pub e_phentsize: Elf32_Half,
-        pub e_phnum: Elf32_Half,
-        pub e_shentsize: Elf32_Half,
-        pub e_shnum: Elf32_Half,
-        pub e_shstrndx: Elf32_Half,
-    }
-
-    pub struct Elf64_Ehdr {
-        pub e_ident: [c_uchar; 16],
-        pub e_type: Elf64_Half,
-        pub e_machine: Elf64_Half,
-        pub e_version: Elf64_Word,
-        pub e_entry: Elf64_Addr,
-        pub e_phoff: Elf64_Off,
-        pub e_shoff: Elf64_Off,
-        pub e_flags: Elf64_Word,
-        pub e_ehsize: Elf64_Half,
-        pub e_phentsize: Elf64_Half,
-        pub e_phnum: Elf64_Half,
-        pub e_shentsize: Elf64_Half,
-        pub e_shnum: Elf64_Half,
-        pub e_shstrndx: Elf64_Half,
-    }
-
-    pub struct Elf32_Sym {
-        pub st_name: Elf32_Word,
-        pub st_value: Elf32_Addr,
-        pub st_size: Elf32_Word,
-        pub st_info: c_uchar,
-        pub st_other: c_uchar,
-        pub st_shndx: Elf32_Section,
-    }
-
-    pub struct Elf64_Sym {
-        pub st_name: Elf64_Word,
-        pub st_info: c_uchar,
-        pub st_other: c_uchar,
-        pub st_shndx: Elf64_Section,
-        pub st_value: Elf64_Addr,
-        pub st_size: Elf64_Xword,
-    }
-
-    pub struct Elf32_Phdr {
-        pub p_type: Elf32_Word,
-        pub p_offset: Elf32_Off,
-        pub p_vaddr: Elf32_Addr,
-        pub p_paddr: Elf32_Addr,
-        pub p_filesz: Elf32_Word,
-        pub p_memsz: Elf32_Word,
-        pub p_flags: Elf32_Word,
-        pub p_align: Elf32_Word,
-    }
-
-    pub struct Elf64_Phdr {
-        pub p_type: Elf64_Word,
-        pub p_flags: Elf64_Word,
-        pub p_offset: Elf64_Off,
-        pub p_vaddr: Elf64_Addr,
-        pub p_paddr: Elf64_Addr,
-        pub p_filesz: Elf64_Xword,
-        pub p_memsz: Elf64_Xword,
-        pub p_align: Elf64_Xword,
-    }
-
-    pub struct Elf32_Shdr {
-        pub sh_name: Elf32_Word,
-        pub sh_type: Elf32_Word,
-        pub sh_flags: Elf32_Word,
-        pub sh_addr: Elf32_Addr,
-        pub sh_offset: Elf32_Off,
-        pub sh_size: Elf32_Word,
-        pub sh_link: Elf32_Word,
-        pub sh_info: Elf32_Word,
-        pub sh_addralign: Elf32_Word,
-        pub sh_entsize: Elf32_Word,
-    }
-
-    pub struct Elf64_Shdr {
-        pub sh_name: Elf64_Word,
-        pub sh_type: Elf64_Word,
-        pub sh_flags: Elf64_Xword,
-        pub sh_addr: Elf64_Addr,
-        pub sh_offset: Elf64_Off,
-        pub sh_size: Elf64_Xword,
-        pub sh_link: Elf64_Word,
-        pub sh_info: Elf64_Word,
-        pub sh_addralign: Elf64_Xword,
-        pub sh_entsize: Elf64_Xword,
-    }
-
-    pub struct __c_anonymous_elf32_rel {
-        pub r_offset: Elf32_Addr,
-        pub r_info: Elf32_Word,
-    }
-
-    pub struct __c_anonymous_elf64_rel {
-        pub r_offset: Elf64_Addr,
-        pub r_info: Elf64_Xword,
-    }
-
     pub struct __c_anonymous__kernel_fsid_t {
         pub val: [c_int; 2],
     }
 
-    pub struct ucred {
-        pub pid: crate::pid_t,
-        pub uid: crate::uid_t,
-        pub gid: crate::gid_t,
-    }
-
-    pub struct mntent {
-        pub mnt_fsname: *mut c_char,
-        pub mnt_dir: *mut c_char,
-        pub mnt_type: *mut c_char,
-        pub mnt_opts: *mut c_char,
-        pub mnt_freq: c_int,
-        pub mnt_passno: c_int,
-    }
-
     pub struct posix_spawn_file_actions_t {
         __allocated: c_int,
         __used: c_int,
@@ -659,20 +375,6 @@ s! {
         pub reserved: u16,
     }
 
-    pub struct in6_pktinfo {
-        pub ipi6_addr: crate::in6_addr,
-        pub ipi6_ifindex: c_uint,
-    }
-
-    pub struct arpd_request {
-        pub req: c_ushort,
-        pub ip: u32,
-        pub dev: c_ulong,
-        pub stamp: c_ulong,
-        pub updated: c_ulong,
-        pub ha: [c_uchar; crate::MAX_ADDR_LEN],
-    }
-
     pub struct inotify_event {
         pub wd: c_int,
         pub mask: u32,
@@ -706,11 +408,6 @@ s! {
         pub svm_zero: [u8; 3],
     }
 
-    pub struct regmatch_t {
-        pub rm_so: regoff_t,
-        pub rm_eo: regoff_t,
-    }
-
     pub struct sock_extended_err {
         pub ee_errno: u32,
         pub ee_origin: u8,
@@ -775,28 +472,12 @@ s! {
         pub nla_type: u16,
     }
 
-    pub struct __c_anonymous_ifru_map {
-        pub mem_start: c_ulong,
-        pub mem_end: c_ulong,
-        pub base_addr: c_ushort,
-        pub irq: c_uchar,
-        pub dma: c_uchar,
-        pub port: c_uchar,
-    }
-
     pub struct in6_ifreq {
         pub ifr6_addr: crate::in6_addr,
         pub ifr6_prefixlen: u32,
         pub ifr6_ifindex: c_int,
     }
 
-    pub struct option {
-        pub name: *const c_char,
-        pub has_arg: c_int,
-        pub flag: *mut c_int,
-        pub val: c_int,
-    }
-
     // linux/openat2.h
     #[non_exhaustive]
     pub struct open_how {
@@ -896,11 +577,6 @@ s! {
         pub auth_keynumber: __u16,
     }
 
-    pub struct rlimit64 {
-        pub rlim_cur: rlim64_t,
-        pub rlim_max: rlim64_t,
-    }
-
     // linux/tls.h
 
     pub struct tls_crypto_info {
@@ -1116,72 +792,6 @@ s! {
         pub __pad: u8, // Must be zero
     }
 
-    #[cfg_attr(
-        any(
-            target_pointer_width = "32",
-            target_arch = "x86_64",
-            target_arch = "powerpc64",
-            target_arch = "mips64",
-            target_arch = "mips64r6",
-            target_arch = "s390x",
-            target_arch = "sparc64",
-            target_arch = "aarch64",
-            target_arch = "riscv64",
-            target_arch = "riscv32",
-            target_arch = "loongarch64"
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        not(any(
-            target_pointer_width = "32",
-            target_arch = "x86_64",
-            target_arch = "powerpc64",
-            target_arch = "mips64",
-            target_arch = "mips64r6",
-            target_arch = "s390x",
-            target_arch = "sparc64",
-            target_arch = "aarch64",
-            target_arch = "riscv64",
-            target_arch = "riscv32",
-            target_arch = "loongarch64"
-        )),
-        repr(align(8))
-    )]
-    pub struct pthread_mutexattr_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_MUTEXATTR_T],
-    }
-
-    #[cfg_attr(
-        any(target_env = "musl", target_env = "ohos", target_pointer_width = "32"),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        all(
-            not(target_env = "musl"),
-            not(target_env = "ohos"),
-            target_pointer_width = "64"
-        ),
-        repr(align(8))
-    )]
-    pub struct pthread_rwlockattr_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCKATTR_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_condattr_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_CONDATTR_T],
-    }
-
-    #[repr(align(4))]
-    pub struct pthread_barrierattr_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_BARRIERATTR_T],
-    }
-
     #[cfg(not(target_env = "musl"))]
     #[repr(align(8))]
     pub struct fanotify_event_metadata {
@@ -1384,18 +994,6 @@ cfg_if! {
                 pub src_addr: crate::sockaddr,
                 pub tsc: [__u8; IW_ENCODE_SEQ_MAX_SIZE],
             }
-
-            pub struct __c_anonymous_elf32_rela {
-                pub r_offset: Elf32_Addr,
-                pub r_info: Elf32_Word,
-                pub r_addend: Elf32_Sword,
-            }
-
-            pub struct __c_anonymous_elf64_rela {
-                pub r_offset: Elf64_Addr,
-                pub r_info: Elf64_Xword,
-                pub r_addend: Elf64_Sxword,
-            }
         }
     }
 }
@@ -1408,14 +1006,6 @@ s_no_extra_traits! {
         pub nl_groups: u32,
     }
 
-    pub struct dirent {
-        pub d_ino: crate::ino_t,
-        pub d_off: off_t,
-        pub d_reclen: c_ushort,
-        pub d_type: c_uchar,
-        pub d_name: [c_char; 256],
-    }
-
     pub struct sockaddr_alg {
         pub salg_family: crate::sa_family_t,
         pub salg_type: [c_uchar; 14],
@@ -1471,55 +1061,12 @@ s_no_extra_traits! {
         pad: [c_long; 4],
     }
 
-    pub union __c_anonymous_ifr_ifru {
-        pub ifru_addr: crate::sockaddr,
-        pub ifru_dstaddr: crate::sockaddr,
-        pub ifru_broadaddr: crate::sockaddr,
-        pub ifru_netmask: crate::sockaddr,
-        pub ifru_hwaddr: crate::sockaddr,
-        pub ifru_flags: c_short,
-        pub ifru_ifindex: c_int,
-        pub ifru_metric: c_int,
-        pub ifru_mtu: c_int,
-        pub ifru_map: __c_anonymous_ifru_map,
-        pub ifru_slave: [c_char; crate::IFNAMSIZ],
-        pub ifru_newname: [c_char; crate::IFNAMSIZ],
-        pub ifru_data: *mut c_char,
-    }
-
-    pub struct ifreq {
-        /// interface name, e.g. "en0"
-        pub ifr_name: [c_char; crate::IFNAMSIZ],
-        pub ifr_ifru: __c_anonymous_ifr_ifru,
-    }
-
-    pub union __c_anonymous_ifc_ifcu {
-        pub ifcu_buf: *mut c_char,
-        pub ifcu_req: *mut crate::ifreq,
-    }
-
-    /// Structure used in SIOCGIFCONF request.  Used to retrieve interface configuration for
-    /// machine (useful for programs which must know all networks accessible).
-    pub struct ifconf {
-        /// Size of buffer
-        pub ifc_len: c_int,
-        pub ifc_ifcu: __c_anonymous_ifc_ifcu,
-    }
-
     pub struct hwtstamp_config {
         pub flags: c_int,
         pub tx_type: c_int,
         pub rx_filter: c_int,
     }
 
-    pub struct dirent64 {
-        pub d_ino: crate::ino64_t,
-        pub d_off: off64_t,
-        pub d_reclen: c_ushort,
-        pub d_type: c_uchar,
-        pub d_name: [c_char; 256],
-    }
-
     pub struct sched_attr {
         pub size: __u32,
         pub sched_policy: __u32,
@@ -1546,159 +1093,6 @@ s_no_extra_traits! {
         pub hdr: crate::tpacket_bd_header_u,
     }
 
-    #[cfg_attr(
-        all(
-            any(target_env = "musl", target_env = "ohos"),
-            target_pointer_width = "32"
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        all(
-            any(target_env = "musl", target_env = "ohos"),
-            target_pointer_width = "64"
-        ),
-        repr(align(8))
-    )]
-    #[cfg_attr(
-        all(
-            not(any(target_env = "musl", target_env = "ohos")),
-            target_arch = "x86"
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        all(
-            not(any(target_env = "musl", target_env = "ohos")),
-            not(target_arch = "x86")
-        ),
-        repr(align(8))
-    )]
-    pub struct pthread_cond_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_COND_T],
-    }
-
-    #[cfg_attr(
-        all(
-            target_pointer_width = "32",
-            any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "csky",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            )
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        any(
-            target_pointer_width = "64",
-            not(any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "csky",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            ))
-        ),
-        repr(align(8))
-    )]
-    pub struct pthread_mutex_t {
-        #[doc(hidden)]
-        size: [u8; crate::__SIZEOF_PTHREAD_MUTEX_T],
-    }
-
-    #[cfg_attr(
-        all(
-            target_pointer_width = "32",
-            any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "csky",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            )
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        any(
-            target_pointer_width = "64",
-            not(any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            ))
-        ),
-        repr(align(8))
-    )]
-    pub struct pthread_rwlock_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCK_T],
-    }
-
-    #[cfg_attr(
-        all(
-            target_pointer_width = "32",
-            any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "csky",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            )
-        ),
-        repr(align(4))
-    )]
-    #[cfg_attr(
-        any(
-            target_pointer_width = "64",
-            not(any(
-                target_arch = "mips",
-                target_arch = "mips32r6",
-                target_arch = "arm",
-                target_arch = "hexagon",
-                target_arch = "m68k",
-                target_arch = "csky",
-                target_arch = "powerpc",
-                target_arch = "sparc",
-                target_arch = "x86_64",
-                target_arch = "x86"
-            ))
-        ),
-        repr(align(8))
-    )]
-    pub struct pthread_barrier_t {
-        size: [u8; crate::__SIZEOF_PTHREAD_BARRIER_T],
-    }
-
     // linux/net_tstamp.h
     pub struct sock_txtime {
         pub clockid: crate::clockid_t,
@@ -1791,114 +1185,6 @@ cfg_if! {
             }
         }
 
-        impl PartialEq for dirent {
-            fn eq(&self, other: &dirent) -> bool {
-                self.d_ino == other.d_ino
-                    && self.d_off == other.d_off
-                    && self.d_reclen == other.d_reclen
-                    && self.d_type == other.d_type
-                    && self
-                        .d_name
-                        .iter()
-                        .zip(other.d_name.iter())
-                        .all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for dirent {}
-
-        impl hash::Hash for dirent {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.d_ino.hash(state);
-                self.d_off.hash(state);
-                self.d_reclen.hash(state);
-                self.d_type.hash(state);
-                self.d_name.hash(state);
-            }
-        }
-
-        impl PartialEq for dirent64 {
-            fn eq(&self, other: &dirent64) -> bool {
-                self.d_ino == other.d_ino
-                    && self.d_off == other.d_off
-                    && self.d_reclen == other.d_reclen
-                    && self.d_type == other.d_type
-                    && self
-                        .d_name
-                        .iter()
-                        .zip(other.d_name.iter())
-                        .all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for dirent64 {}
-
-        impl hash::Hash for dirent64 {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.d_ino.hash(state);
-                self.d_off.hash(state);
-                self.d_reclen.hash(state);
-                self.d_type.hash(state);
-                self.d_name.hash(state);
-            }
-        }
-
-        impl PartialEq for pthread_cond_t {
-            fn eq(&self, other: &pthread_cond_t) -> bool {
-                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for pthread_cond_t {}
-
-        impl hash::Hash for pthread_cond_t {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.size.hash(state);
-            }
-        }
-
-        impl PartialEq for pthread_mutex_t {
-            fn eq(&self, other: &pthread_mutex_t) -> bool {
-                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for pthread_mutex_t {}
-
-        impl hash::Hash for pthread_mutex_t {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.size.hash(state);
-            }
-        }
-
-        impl PartialEq for pthread_rwlock_t {
-            fn eq(&self, other: &pthread_rwlock_t) -> bool {
-                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for pthread_rwlock_t {}
-
-        impl hash::Hash for pthread_rwlock_t {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.size.hash(state);
-            }
-        }
-
-        impl PartialEq for pthread_barrier_t {
-            fn eq(&self, other: &pthread_barrier_t) -> bool {
-                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
-            }
-        }
-
-        impl Eq for pthread_barrier_t {}
-
-        impl hash::Hash for pthread_barrier_t {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                self.size.hash(state);
-            }
-        }
-
         impl PartialEq for sockaddr_alg {
             fn eq(&self, other: &sockaddr_alg) -> bool {
                 self.salg_family == other.salg_family
@@ -1988,6 +1274,7 @@ cfg_if! {
                 self.mq_curmsgs.hash(state);
             }
         }
+
         impl PartialEq for hwtstamp_config {
             fn eq(&self, other: &hwtstamp_config) -> bool {
                 self.flags == other.flags
@@ -2032,524 +1319,9 @@ cfg_if! {
     }
 }
 
-cfg_if! {
-    if #[cfg(any(
-        target_env = "gnu",
-        target_env = "musl",
-        target_env = "ohos"
-    ))] {
-        pub const ABDAY_1: crate::nl_item = 0x20000;
-        pub const ABDAY_2: crate::nl_item = 0x20001;
-        pub const ABDAY_3: crate::nl_item = 0x20002;
-        pub const ABDAY_4: crate::nl_item = 0x20003;
-        pub const ABDAY_5: crate::nl_item = 0x20004;
-        pub const ABDAY_6: crate::nl_item = 0x20005;
-        pub const ABDAY_7: crate::nl_item = 0x20006;
-
-        pub const DAY_1: crate::nl_item = 0x20007;
-        pub const DAY_2: crate::nl_item = 0x20008;
-        pub const DAY_3: crate::nl_item = 0x20009;
-        pub const DAY_4: crate::nl_item = 0x2000A;
-        pub const DAY_5: crate::nl_item = 0x2000B;
-        pub const DAY_6: crate::nl_item = 0x2000C;
-        pub const DAY_7: crate::nl_item = 0x2000D;
-
-        pub const ABMON_1: crate::nl_item = 0x2000E;
-        pub const ABMON_2: crate::nl_item = 0x2000F;
-        pub const ABMON_3: crate::nl_item = 0x20010;
-        pub const ABMON_4: crate::nl_item = 0x20011;
-        pub const ABMON_5: crate::nl_item = 0x20012;
-        pub const ABMON_6: crate::nl_item = 0x20013;
-        pub const ABMON_7: crate::nl_item = 0x20014;
-        pub const ABMON_8: crate::nl_item = 0x20015;
-        pub const ABMON_9: crate::nl_item = 0x20016;
-        pub const ABMON_10: crate::nl_item = 0x20017;
-        pub const ABMON_11: crate::nl_item = 0x20018;
-        pub const ABMON_12: crate::nl_item = 0x20019;
-
-        pub const MON_1: crate::nl_item = 0x2001A;
-        pub const MON_2: crate::nl_item = 0x2001B;
-        pub const MON_3: crate::nl_item = 0x2001C;
-        pub const MON_4: crate::nl_item = 0x2001D;
-        pub const MON_5: crate::nl_item = 0x2001E;
-        pub const MON_6: crate::nl_item = 0x2001F;
-        pub const MON_7: crate::nl_item = 0x20020;
-        pub const MON_8: crate::nl_item = 0x20021;
-        pub const MON_9: crate::nl_item = 0x20022;
-        pub const MON_10: crate::nl_item = 0x20023;
-        pub const MON_11: crate::nl_item = 0x20024;
-        pub const MON_12: crate::nl_item = 0x20025;
-
-        pub const AM_STR: crate::nl_item = 0x20026;
-        pub const PM_STR: crate::nl_item = 0x20027;
-
-        pub const D_T_FMT: crate::nl_item = 0x20028;
-        pub const D_FMT: crate::nl_item = 0x20029;
-        pub const T_FMT: crate::nl_item = 0x2002A;
-        pub const T_FMT_AMPM: crate::nl_item = 0x2002B;
-
-        pub const ERA: crate::nl_item = 0x2002C;
-        pub const ERA_D_FMT: crate::nl_item = 0x2002E;
-        pub const ALT_DIGITS: crate::nl_item = 0x2002F;
-        pub const ERA_D_T_FMT: crate::nl_item = 0x20030;
-        pub const ERA_T_FMT: crate::nl_item = 0x20031;
-
-        pub const CODESET: crate::nl_item = 14;
-        pub const CRNCYSTR: crate::nl_item = 0x4000F;
-        pub const RADIXCHAR: crate::nl_item = 0x10000;
-        pub const THOUSEP: crate::nl_item = 0x10001;
-        pub const YESEXPR: crate::nl_item = 0x50000;
-        pub const NOEXPR: crate::nl_item = 0x50001;
-        pub const YESSTR: crate::nl_item = 0x50002;
-        pub const NOSTR: crate::nl_item = 0x50003;
-    }
-}
-
-pub const RUSAGE_CHILDREN: c_int = -1;
-pub const L_tmpnam: c_uint = 20;
-pub const _PC_LINK_MAX: c_int = 0;
-pub const _PC_MAX_CANON: c_int = 1;
-pub const _PC_MAX_INPUT: c_int = 2;
-pub const _PC_NAME_MAX: c_int = 3;
-pub const _PC_PATH_MAX: c_int = 4;
-pub const _PC_PIPE_BUF: c_int = 5;
-pub const _PC_CHOWN_RESTRICTED: c_int = 6;
-pub const _PC_NO_TRUNC: c_int = 7;
-pub const _PC_VDISABLE: c_int = 8;
-pub const _PC_SYNC_IO: c_int = 9;
-pub const _PC_ASYNC_IO: c_int = 10;
-pub const _PC_PRIO_IO: c_int = 11;
-pub const _PC_SOCK_MAXBUF: c_int = 12;
-pub const _PC_FILESIZEBITS: c_int = 13;
-pub const _PC_REC_INCR_XFER_SIZE: c_int = 14;
-pub const _PC_REC_MAX_XFER_SIZE: c_int = 15;
-pub const _PC_REC_MIN_XFER_SIZE: c_int = 16;
-pub const _PC_REC_XFER_ALIGN: c_int = 17;
-pub const _PC_ALLOC_SIZE_MIN: c_int = 18;
-pub const _PC_SYMLINK_MAX: c_int = 19;
-pub const _PC_2_SYMLINKS: c_int = 20;
-
-pub const MS_NOUSER: c_ulong = 0xffffffff80000000;
-
-pub const _SC_ARG_MAX: c_int = 0;
-pub const _SC_CHILD_MAX: c_int = 1;
-pub const _SC_CLK_TCK: c_int = 2;
-pub const _SC_NGROUPS_MAX: c_int = 3;
-pub const _SC_OPEN_MAX: c_int = 4;
-pub const _SC_STREAM_MAX: c_int = 5;
-pub const _SC_TZNAME_MAX: c_int = 6;
-pub const _SC_JOB_CONTROL: c_int = 7;
-pub const _SC_SAVED_IDS: c_int = 8;
-pub const _SC_REALTIME_SIGNALS: c_int = 9;
-pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
-pub const _SC_TIMERS: c_int = 11;
-pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
-pub const _SC_PRIORITIZED_IO: c_int = 13;
-pub const _SC_SYNCHRONIZED_IO: c_int = 14;
-pub const _SC_FSYNC: c_int = 15;
-pub const _SC_MAPPED_FILES: c_int = 16;
-pub const _SC_MEMLOCK: c_int = 17;
-pub const _SC_MEMLOCK_RANGE: c_int = 18;
-pub const _SC_MEMORY_PROTECTION: c_int = 19;
-pub const _SC_MESSAGE_PASSING: c_int = 20;
-pub const _SC_SEMAPHORES: c_int = 21;
-pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
-pub const _SC_AIO_LISTIO_MAX: c_int = 23;
-pub const _SC_AIO_MAX: c_int = 24;
-pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
-pub const _SC_DELAYTIMER_MAX: c_int = 26;
-pub const _SC_MQ_OPEN_MAX: c_int = 27;
-pub const _SC_MQ_PRIO_MAX: c_int = 28;
-pub const _SC_VERSION: c_int = 29;
-pub const _SC_PAGESIZE: c_int = 30;
-pub const _SC_PAGE_SIZE: c_int = _SC_PAGESIZE;
-pub const _SC_RTSIG_MAX: c_int = 31;
-pub const _SC_SEM_NSEMS_MAX: c_int = 32;
-pub const _SC_SEM_VALUE_MAX: c_int = 33;
-pub const _SC_SIGQUEUE_MAX: c_int = 34;
-pub const _SC_TIMER_MAX: c_int = 35;
-pub const _SC_BC_BASE_MAX: c_int = 36;
-pub const _SC_BC_DIM_MAX: c_int = 37;
-pub const _SC_BC_SCALE_MAX: c_int = 38;
-pub const _SC_BC_STRING_MAX: c_int = 39;
-pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
-pub const _SC_EXPR_NEST_MAX: c_int = 42;
-pub const _SC_LINE_MAX: c_int = 43;
-pub const _SC_RE_DUP_MAX: c_int = 44;
-pub const _SC_2_VERSION: c_int = 46;
-pub const _SC_2_C_BIND: c_int = 47;
-pub const _SC_2_C_DEV: c_int = 48;
-pub const _SC_2_FORT_DEV: c_int = 49;
-pub const _SC_2_FORT_RUN: c_int = 50;
-pub const _SC_2_SW_DEV: c_int = 51;
-pub const _SC_2_LOCALEDEF: c_int = 52;
-pub const _SC_UIO_MAXIOV: c_int = 60;
-pub const _SC_IOV_MAX: c_int = 60;
-pub const _SC_THREADS: c_int = 67;
-pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
-pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
-pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
-pub const _SC_LOGIN_NAME_MAX: c_int = 71;
-pub const _SC_TTY_NAME_MAX: c_int = 72;
-pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
-pub const _SC_THREAD_KEYS_MAX: c_int = 74;
-pub const _SC_THREAD_STACK_MIN: c_int = 75;
-pub const _SC_THREAD_THREADS_MAX: c_int = 76;
-pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
-pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
-pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
-pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
-pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
-pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
-pub const _SC_NPROCESSORS_CONF: c_int = 83;
-pub const _SC_NPROCESSORS_ONLN: c_int = 84;
-pub const _SC_PHYS_PAGES: c_int = 85;
-pub const _SC_AVPHYS_PAGES: c_int = 86;
-pub const _SC_ATEXIT_MAX: c_int = 87;
-pub const _SC_PASS_MAX: c_int = 88;
-pub const _SC_XOPEN_VERSION: c_int = 89;
-pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
-pub const _SC_XOPEN_UNIX: c_int = 91;
-pub const _SC_XOPEN_CRYPT: c_int = 92;
-pub const _SC_XOPEN_ENH_I18N: c_int = 93;
-pub const _SC_XOPEN_SHM: c_int = 94;
-pub const _SC_2_CHAR_TERM: c_int = 95;
-pub const _SC_2_UPE: c_int = 97;
-pub const _SC_XOPEN_XPG2: c_int = 98;
-pub const _SC_XOPEN_XPG3: c_int = 99;
-pub const _SC_XOPEN_XPG4: c_int = 100;
-pub const _SC_NZERO: c_int = 109;
-pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
-pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
-pub const _SC_XBS5_LP64_OFF64: c_int = 127;
-pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
-pub const _SC_XOPEN_LEGACY: c_int = 129;
-pub const _SC_XOPEN_REALTIME: c_int = 130;
-pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
-pub const _SC_ADVISORY_INFO: c_int = 132;
-pub const _SC_BARRIERS: c_int = 133;
-pub const _SC_CLOCK_SELECTION: c_int = 137;
-pub const _SC_CPUTIME: c_int = 138;
-pub const _SC_THREAD_CPUTIME: c_int = 139;
-pub const _SC_MONOTONIC_CLOCK: c_int = 149;
-pub const _SC_READER_WRITER_LOCKS: c_int = 153;
-pub const _SC_SPIN_LOCKS: c_int = 154;
-pub const _SC_REGEXP: c_int = 155;
-pub const _SC_SHELL: c_int = 157;
-pub const _SC_SPAWN: c_int = 159;
-pub const _SC_SPORADIC_SERVER: c_int = 160;
-pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
-pub const _SC_TIMEOUTS: c_int = 164;
-pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
-pub const _SC_2_PBS: c_int = 168;
-pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
-pub const _SC_2_PBS_LOCATE: c_int = 170;
-pub const _SC_2_PBS_MESSAGE: c_int = 171;
-pub const _SC_2_PBS_TRACK: c_int = 172;
-pub const _SC_SYMLOOP_MAX: c_int = 173;
-pub const _SC_STREAMS: c_int = 174;
-pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
-pub const _SC_V6_ILP32_OFF32: c_int = 176;
-pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
-pub const _SC_V6_LP64_OFF64: c_int = 178;
-pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
-pub const _SC_HOST_NAME_MAX: c_int = 180;
-pub const _SC_TRACE: c_int = 181;
-pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
-pub const _SC_TRACE_INHERIT: c_int = 183;
-pub const _SC_TRACE_LOG: c_int = 184;
-pub const _SC_IPV6: c_int = 235;
-pub const _SC_RAW_SOCKETS: c_int = 236;
-pub const _SC_V7_ILP32_OFF32: c_int = 237;
-pub const _SC_V7_ILP32_OFFBIG: c_int = 238;
-pub const _SC_V7_LP64_OFF64: c_int = 239;
-pub const _SC_V7_LPBIG_OFFBIG: c_int = 240;
-pub const _SC_SS_REPL_MAX: c_int = 241;
-pub const _SC_TRACE_EVENT_NAME_MAX: c_int = 242;
-pub const _SC_TRACE_NAME_MAX: c_int = 243;
-pub const _SC_TRACE_SYS_MAX: c_int = 244;
-pub const _SC_TRACE_USER_EVENT_MAX: c_int = 245;
-pub const _SC_XOPEN_STREAMS: c_int = 246;
-pub const _SC_THREAD_ROBUST_PRIO_INHERIT: c_int = 247;
-pub const _SC_THREAD_ROBUST_PRIO_PROTECT: c_int = 248;
-
-pub const _CS_PATH: c_int = 0;
-pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
-pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
-pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
-pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
-pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
-pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
-pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
-pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
-pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
-pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
-pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
-pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
-pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
-pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
-pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
-pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
-pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
-pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
-pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
-pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
-pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
-pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
-pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
-pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
-pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
-pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
-pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
-pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
-pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
-pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
-pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
-pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
-pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
-pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
-pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
-
-pub const RLIM_SAVED_MAX: crate::rlim_t = RLIM_INFINITY;
-pub const RLIM_SAVED_CUR: crate::rlim_t = RLIM_INFINITY;
-
-// elf.h - Fields in the e_ident array.
-pub const EI_NIDENT: usize = 16;
-
-pub const EI_MAG0: usize = 0;
-pub const ELFMAG0: u8 = 0x7f;
-pub const EI_MAG1: usize = 1;
-pub const ELFMAG1: u8 = b'E';
-pub const EI_MAG2: usize = 2;
-pub const ELFMAG2: u8 = b'L';
-pub const EI_MAG3: usize = 3;
-pub const ELFMAG3: u8 = b'F';
-pub const SELFMAG: usize = 4;
-
-pub const EI_CLASS: usize = 4;
-pub const ELFCLASSNONE: u8 = 0;
-pub const ELFCLASS32: u8 = 1;
-pub const ELFCLASS64: u8 = 2;
-pub const ELFCLASSNUM: usize = 3;
-
-pub const EI_DATA: usize = 5;
-pub const ELFDATANONE: u8 = 0;
-pub const ELFDATA2LSB: u8 = 1;
-pub const ELFDATA2MSB: u8 = 2;
-pub const ELFDATANUM: usize = 3;
-
-pub const EI_VERSION: usize = 6;
-
-pub const EI_OSABI: usize = 7;
-pub const ELFOSABI_NONE: u8 = 0;
-pub const ELFOSABI_SYSV: u8 = 0;
-pub const ELFOSABI_HPUX: u8 = 1;
-pub const ELFOSABI_NETBSD: u8 = 2;
-pub const ELFOSABI_GNU: u8 = 3;
-pub const ELFOSABI_LINUX: u8 = ELFOSABI_GNU;
-pub const ELFOSABI_SOLARIS: u8 = 6;
-pub const ELFOSABI_AIX: u8 = 7;
-pub const ELFOSABI_IRIX: u8 = 8;
-pub const ELFOSABI_FREEBSD: u8 = 9;
-pub const ELFOSABI_TRU64: u8 = 10;
-pub const ELFOSABI_MODESTO: u8 = 11;
-pub const ELFOSABI_OPENBSD: u8 = 12;
-pub const ELFOSABI_ARM: u8 = 97;
-pub const ELFOSABI_STANDALONE: u8 = 255;
-
-pub const EI_ABIVERSION: usize = 8;
-
-pub const EI_PAD: usize = 9;
-
-// elf.h - Legal values for e_type (object file type).
-pub const ET_NONE: u16 = 0;
-pub const ET_REL: u16 = 1;
-pub const ET_EXEC: u16 = 2;
-pub const ET_DYN: u16 = 3;
-pub const ET_CORE: u16 = 4;
-pub const ET_NUM: u16 = 5;
-pub const ET_LOOS: u16 = 0xfe00;
-pub const ET_HIOS: u16 = 0xfeff;
-pub const ET_LOPROC: u16 = 0xff00;
-pub const ET_HIPROC: u16 = 0xffff;
-
-// elf.h - Legal values for e_machine (architecture).
-pub const EM_NONE: u16 = 0;
-pub const EM_M32: u16 = 1;
-pub const EM_SPARC: u16 = 2;
-pub const EM_386: u16 = 3;
-pub const EM_68K: u16 = 4;
-pub const EM_88K: u16 = 5;
-pub const EM_860: u16 = 7;
-pub const EM_MIPS: u16 = 8;
-pub const EM_S370: u16 = 9;
-pub const EM_MIPS_RS3_LE: u16 = 10;
-pub const EM_PARISC: u16 = 15;
-pub const EM_VPP500: u16 = 17;
-pub const EM_SPARC32PLUS: u16 = 18;
-pub const EM_960: u16 = 19;
-pub const EM_PPC: u16 = 20;
-pub const EM_PPC64: u16 = 21;
-pub const EM_S390: u16 = 22;
-pub const EM_V800: u16 = 36;
-pub const EM_FR20: u16 = 37;
-pub const EM_RH32: u16 = 38;
-pub const EM_RCE: u16 = 39;
-pub const EM_ARM: u16 = 40;
-pub const EM_FAKE_ALPHA: u16 = 41;
-pub const EM_SH: u16 = 42;
-pub const EM_SPARCV9: u16 = 43;
-pub const EM_TRICORE: u16 = 44;
-pub const EM_ARC: u16 = 45;
-pub const EM_H8_300: u16 = 46;
-pub const EM_H8_300H: u16 = 47;
-pub const EM_H8S: u16 = 48;
-pub const EM_H8_500: u16 = 49;
-pub const EM_IA_64: u16 = 50;
-pub const EM_MIPS_X: u16 = 51;
-pub const EM_COLDFIRE: u16 = 52;
-pub const EM_68HC12: u16 = 53;
-pub const EM_MMA: u16 = 54;
-pub const EM_PCP: u16 = 55;
-pub const EM_NCPU: u16 = 56;
-pub const EM_NDR1: u16 = 57;
-pub const EM_STARCORE: u16 = 58;
-pub const EM_ME16: u16 = 59;
-pub const EM_ST100: u16 = 60;
-pub const EM_TINYJ: u16 = 61;
-pub const EM_X86_64: u16 = 62;
-pub const EM_PDSP: u16 = 63;
-pub const EM_FX66: u16 = 66;
-pub const EM_ST9PLUS: u16 = 67;
-pub const EM_ST7: u16 = 68;
-pub const EM_68HC16: u16 = 69;
-pub const EM_68HC11: u16 = 70;
-pub const EM_68HC08: u16 = 71;
-pub const EM_68HC05: u16 = 72;
-pub const EM_SVX: u16 = 73;
-pub const EM_ST19: u16 = 74;
-pub const EM_VAX: u16 = 75;
-pub const EM_CRIS: u16 = 76;
-pub const EM_JAVELIN: u16 = 77;
-pub const EM_FIREPATH: u16 = 78;
-pub const EM_ZSP: u16 = 79;
-pub const EM_MMIX: u16 = 80;
-pub const EM_HUANY: u16 = 81;
-pub const EM_PRISM: u16 = 82;
-pub const EM_AVR: u16 = 83;
-pub const EM_FR30: u16 = 84;
-pub const EM_D10V: u16 = 85;
-pub const EM_D30V: u16 = 86;
-pub const EM_V850: u16 = 87;
-pub const EM_M32R: u16 = 88;
-pub const EM_MN10300: u16 = 89;
-pub const EM_MN10200: u16 = 90;
-pub const EM_PJ: u16 = 91;
-pub const EM_OPENRISC: u16 = 92;
-pub const EM_ARC_A5: u16 = 93;
-pub const EM_XTENSA: u16 = 94;
-pub const EM_AARCH64: u16 = 183;
-pub const EM_TILEPRO: u16 = 188;
-pub const EM_TILEGX: u16 = 191;
-pub const EM_RISCV: u16 = 243;
-pub const EM_ALPHA: u16 = 0x9026;
-
-// elf.h - Legal values for e_version (version).
-pub const EV_NONE: u32 = 0;
-pub const EV_CURRENT: u32 = 1;
-pub const EV_NUM: u32 = 2;
-
-// elf.h - Legal values for p_type (segment type).
-pub const PT_NULL: u32 = 0;
-pub const PT_LOAD: u32 = 1;
-pub const PT_DYNAMIC: u32 = 2;
-pub const PT_INTERP: u32 = 3;
-pub const PT_NOTE: u32 = 4;
-pub const PT_SHLIB: u32 = 5;
-pub const PT_PHDR: u32 = 6;
-pub const PT_TLS: u32 = 7;
-pub const PT_NUM: u32 = 8;
-pub const PT_LOOS: u32 = 0x60000000;
-pub const PT_GNU_EH_FRAME: u32 = 0x6474e550;
-pub const PT_GNU_STACK: u32 = 0x6474e551;
-pub const PT_GNU_RELRO: u32 = 0x6474e552;
-pub const PT_LOSUNW: u32 = 0x6ffffffa;
-pub const PT_SUNWBSS: u32 = 0x6ffffffa;
-pub const PT_SUNWSTACK: u32 = 0x6ffffffb;
-pub const PT_HISUNW: u32 = 0x6fffffff;
-pub const PT_HIOS: u32 = 0x6fffffff;
-pub const PT_LOPROC: u32 = 0x70000000;
-pub const PT_HIPROC: u32 = 0x7fffffff;
-
-// Legal values for p_flags (segment flags).
-pub const PF_X: u32 = 1 << 0;
-pub const PF_W: u32 = 1 << 1;
-pub const PF_R: u32 = 1 << 2;
-pub const PF_MASKOS: u32 = 0x0ff00000;
-pub const PF_MASKPROC: u32 = 0xf0000000;
-
-// elf.h - Legal values for a_type (entry type).
-pub const AT_NULL: c_ulong = 0;
-pub const AT_IGNORE: c_ulong = 1;
-pub const AT_EXECFD: c_ulong = 2;
-pub const AT_PHDR: c_ulong = 3;
-pub const AT_PHENT: c_ulong = 4;
-pub const AT_PHNUM: c_ulong = 5;
-pub const AT_PAGESZ: c_ulong = 6;
-pub const AT_BASE: c_ulong = 7;
-pub const AT_FLAGS: c_ulong = 8;
-pub const AT_ENTRY: c_ulong = 9;
-pub const AT_NOTELF: c_ulong = 10;
-pub const AT_UID: c_ulong = 11;
-pub const AT_EUID: c_ulong = 12;
-pub const AT_GID: c_ulong = 13;
-pub const AT_EGID: c_ulong = 14;
-pub const AT_PLATFORM: c_ulong = 15;
-pub const AT_HWCAP: c_ulong = 16;
-pub const AT_CLKTCK: c_ulong = 17;
-
-pub const AT_SECURE: c_ulong = 23;
-pub const AT_BASE_PLATFORM: c_ulong = 24;
-pub const AT_RANDOM: c_ulong = 25;
-pub const AT_HWCAP2: c_ulong = 26;
-
-pub const AT_HWCAP3: c_ulong = 29;
-pub const AT_HWCAP4: c_ulong = 30;
-pub const AT_EXECFN: c_ulong = 31;
-
-// defined in arch/<arch>/include/uapi/asm/auxvec.h but has the same value
-// wherever it is defined.
-pub const AT_SYSINFO_EHDR: c_ulong = 33;
-pub const AT_MINSIGSTKSZ: c_ulong = 51;
-
-pub const GLOB_ERR: c_int = 1 << 0;
-pub const GLOB_MARK: c_int = 1 << 1;
-pub const GLOB_NOSORT: c_int = 1 << 2;
-pub const GLOB_DOOFFS: c_int = 1 << 3;
-pub const GLOB_NOCHECK: c_int = 1 << 4;
-pub const GLOB_APPEND: c_int = 1 << 5;
-pub const GLOB_NOESCAPE: c_int = 1 << 6;
-
-pub const GLOB_NOSPACE: c_int = 1;
-pub const GLOB_ABORTED: c_int = 2;
-pub const GLOB_NOMATCH: c_int = 3;
-
-pub const POSIX_MADV_NORMAL: c_int = 0;
-pub const POSIX_MADV_RANDOM: c_int = 1;
-pub const POSIX_MADV_SEQUENTIAL: c_int = 2;
-pub const POSIX_MADV_WILLNEED: c_int = 3;
 pub const POSIX_SPAWN_USEVFORK: c_short = 64;
 pub const POSIX_SPAWN_SETSID: c_short = 128;
 
-pub const S_IEXEC: mode_t = 0o0100;
-pub const S_IWRITE: mode_t = 0o0200;
-pub const S_IREAD: mode_t = 0o0400;
-
-pub const F_LOCK: c_int = 1;
-pub const F_TEST: c_int = 3;
-pub const F_TLOCK: c_int = 2;
-pub const F_ULOCK: c_int = 0;
-
 pub const F_SEAL_FUTURE_WRITE: c_int = 0x0010;
 pub const F_SEAL_EXEC: c_int = 0x0020;
 
@@ -2557,6 +1329,9 @@ pub const IFF_LOWER_UP: c_int = 0x10000;
 pub const IFF_DORMANT: c_int = 0x20000;
 pub const IFF_ECHO: c_int = 0x40000;
 
+pub const CLONE_CLEAR_SIGHAND: c_ulonglong = 0x100000000;
+pub const CLONE_INTO_CGROUP: c_ulonglong = 0x200000000;
+
 // linux/if_addr.h
 pub const IFA_UNSPEC: c_ushort = 0;
 pub const IFA_ADDRESS: c_ushort = 1;
@@ -2670,25 +1445,6 @@ pub const IFLA_INFO_SLAVE_DATA: c_ushort = 5;
 pub const SEEK_DATA: c_int = 3;
 pub const SEEK_HOLE: c_int = 4;
 
-pub const ST_RDONLY: c_ulong = 1;
-pub const ST_NOSUID: c_ulong = 2;
-pub const ST_NODEV: c_ulong = 4;
-pub const ST_NOEXEC: c_ulong = 8;
-pub const ST_SYNCHRONOUS: c_ulong = 16;
-pub const ST_MANDLOCK: c_ulong = 64;
-pub const ST_WRITE: c_ulong = 128;
-pub const ST_APPEND: c_ulong = 256;
-pub const ST_IMMUTABLE: c_ulong = 512;
-pub const ST_NOATIME: c_ulong = 1024;
-pub const ST_NODIRATIME: c_ulong = 2048;
-
-pub const RTLD_NEXT: *mut c_void = -1i64 as *mut c_void;
-pub const RTLD_DEFAULT: *mut c_void = ptr::null_mut();
-pub const RTLD_NODELETE: c_int = 0x1000;
-pub const RTLD_NOW: c_int = 0x2;
-
-pub const AT_EACCESS: c_int = 0x200;
-
 // linux/mempolicy.h
 pub const MPOL_DEFAULT: c_int = 0;
 pub const MPOL_PREFERRED: c_int = 1;
@@ -2711,59 +1467,10 @@ pub const MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE: c_int = 1 << 6;
 pub const MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ: c_int = 1 << 7;
 pub const MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ: c_int = 1 << 8;
 
-pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
-    size: [0; __SIZEOF_PTHREAD_MUTEX_T],
-};
-pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
-    size: [0; __SIZEOF_PTHREAD_COND_T],
-};
-pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
-    size: [0; __SIZEOF_PTHREAD_RWLOCK_T],
-};
-
-pub const PTHREAD_BARRIER_SERIAL_THREAD: c_int = -1;
-pub const PTHREAD_ONCE_INIT: pthread_once_t = 0;
-pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
-pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
-pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
-pub const PTHREAD_MUTEX_DEFAULT: c_int = PTHREAD_MUTEX_NORMAL;
-pub const PTHREAD_MUTEX_STALLED: c_int = 0;
-pub const PTHREAD_MUTEX_ROBUST: c_int = 1;
-pub const PTHREAD_PRIO_NONE: c_int = 0;
-pub const PTHREAD_PRIO_INHERIT: c_int = 1;
-pub const PTHREAD_PRIO_PROTECT: c_int = 2;
-pub const PTHREAD_PROCESS_PRIVATE: c_int = 0;
-pub const PTHREAD_PROCESS_SHARED: c_int = 1;
-pub const PTHREAD_INHERIT_SCHED: c_int = 0;
-pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
-pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
-
 pub const RENAME_NOREPLACE: c_uint = 1;
 pub const RENAME_EXCHANGE: c_uint = 2;
 pub const RENAME_WHITEOUT: c_uint = 4;
 
-// netinet/in.h
-// NOTE: These are in addition to the constants defined in src/unix/mod.rs
-
-#[deprecated(
-    since = "0.2.80",
-    note = "This value was increased in the newer kernel \
-            and we'll change this following upstream in the future release. \
-            See #1896 for more info."
-)]
-pub const IPPROTO_MAX: c_int = 256;
-
-// System V IPC
-pub const IPC_PRIVATE: crate::key_t = 0;
-
-pub const IPC_CREAT: c_int = 0o1000;
-pub const IPC_EXCL: c_int = 0o2000;
-pub const IPC_NOWAIT: c_int = 0o4000;
-
-pub const IPC_RMID: c_int = 0;
-pub const IPC_SET: c_int = 1;
-pub const IPC_STAT: c_int = 2;
-pub const IPC_INFO: c_int = 3;
 pub const MSG_STAT: c_int = 11;
 pub const MSG_INFO: c_int = 12;
 pub const MSG_NOTIFICATION: c_int = 0x8000;
@@ -2785,30 +1492,12 @@ pub const SEM_STAT: c_int = 18;
 pub const SEM_INFO: c_int = 19;
 pub const SEM_STAT_ANY: c_int = 20;
 
-pub const SHM_R: c_int = 0o400;
-pub const SHM_W: c_int = 0o200;
-
-pub const SHM_RDONLY: c_int = 0o10000;
-pub const SHM_RND: c_int = 0o20000;
-pub const SHM_REMAP: c_int = 0o40000;
-
-pub const SHM_LOCK: c_int = 11;
-pub const SHM_UNLOCK: c_int = 12;
-
-pub const SHM_HUGETLB: c_int = 0o4000;
-#[cfg(not(all(target_env = "uclibc", target_arch = "mips")))]
-pub const SHM_NORESERVE: c_int = 0o10000;
-
 pub const QFMT_VFS_OLD: c_int = 1;
 pub const QFMT_VFS_V0: c_int = 2;
 pub const QFMT_VFS_V1: c_int = 4;
 
 pub const EFD_SEMAPHORE: c_int = 0x1;
 
-pub const LOG_NFACILITIES: c_int = 24;
-
-pub const SEM_FAILED: *mut crate::sem_t = ptr::null_mut();
-
 pub const RB_AUTOBOOT: c_int = 0x01234567u32 as i32;
 pub const RB_HALT_SYSTEM: c_int = 0xcdef0123u32 as i32;
 pub const RB_ENABLE_CAD: c_int = 0x89abcdefu32 as i32;
@@ -2817,60 +1506,10 @@ pub const RB_POWER_OFF: c_int = 0x4321fedcu32 as i32;
 pub const RB_SW_SUSPEND: c_int = 0xd000fce2u32 as i32;
 pub const RB_KEXEC: c_int = 0x45584543u32 as i32;
 
-pub const AI_PASSIVE: c_int = 0x0001;
-pub const AI_CANONNAME: c_int = 0x0002;
-pub const AI_NUMERICHOST: c_int = 0x0004;
-pub const AI_V4MAPPED: c_int = 0x0008;
-pub const AI_ALL: c_int = 0x0010;
-pub const AI_ADDRCONFIG: c_int = 0x0020;
-
-pub const AI_NUMERICSERV: c_int = 0x0400;
-
-pub const EAI_BADFLAGS: c_int = -1;
-pub const EAI_NONAME: c_int = -2;
-pub const EAI_AGAIN: c_int = -3;
-pub const EAI_FAIL: c_int = -4;
-pub const EAI_NODATA: c_int = -5;
-pub const EAI_FAMILY: c_int = -6;
-pub const EAI_SOCKTYPE: c_int = -7;
-pub const EAI_SERVICE: c_int = -8;
-pub const EAI_MEMORY: c_int = -10;
-pub const EAI_SYSTEM: c_int = -11;
-pub const EAI_OVERFLOW: c_int = -12;
-
-pub const NI_NUMERICHOST: c_int = 1;
-pub const NI_NUMERICSERV: c_int = 2;
-pub const NI_NOFQDN: c_int = 4;
-pub const NI_NAMEREQD: c_int = 8;
-pub const NI_DGRAM: c_int = 16;
-pub const NI_IDN: c_int = 32;
-
 pub const SYNC_FILE_RANGE_WAIT_BEFORE: c_uint = 1;
 pub const SYNC_FILE_RANGE_WRITE: c_uint = 2;
 pub const SYNC_FILE_RANGE_WAIT_AFTER: c_uint = 4;
 
-cfg_if! {
-    if #[cfg(not(target_env = "uclibc"))] {
-        pub const AIO_CANCELED: c_int = 0;
-        pub const AIO_NOTCANCELED: c_int = 1;
-        pub const AIO_ALLDONE: c_int = 2;
-        pub const LIO_READ: c_int = 0;
-        pub const LIO_WRITE: c_int = 1;
-        pub const LIO_NOP: c_int = 2;
-        pub const LIO_WAIT: c_int = 0;
-        pub const LIO_NOWAIT: c_int = 1;
-        pub const RUSAGE_THREAD: c_int = 1;
-        pub const MSG_COPY: c_int = 0o40000;
-        pub const SHM_EXEC: c_int = 0o100000;
-        pub const IPV6_MULTICAST_ALL: c_int = 29;
-        pub const IPV6_ROUTER_ALERT_ISOLATE: c_int = 30;
-        pub const PACKET_MR_UNICAST: c_int = 3;
-        pub const PTRACE_EVENT_STOP: c_int = 128;
-        pub const UDP_SEGMENT: c_int = 103;
-        pub const UDP_GRO: c_int = 104;
-    }
-}
-
 pub const MREMAP_MAYMOVE: c_int = 1;
 pub const MREMAP_FIXED: c_int = 2;
 pub const MREMAP_DONTUNMAP: c_int = 4;
@@ -2924,146 +1563,11 @@ pub const PIDFD_GET_USER_NAMESPACE: Ioctl = _IO(PIDFS_IOCTL_MAGIC, 9);
 pub const PIDFD_GET_UTS_NAMESPACE: Ioctl = _IO(PIDFS_IOCTL_MAGIC, 10);
 pub const PIDFD_GET_INFO: Ioctl = _IOWR::<pidfd_info>(PIDFS_IOCTL_MAGIC, 11);
 
-// linux/prctl.h
-pub const PR_SET_PDEATHSIG: c_int = 1;
-pub const PR_GET_PDEATHSIG: c_int = 2;
-
-pub const PR_GET_DUMPABLE: c_int = 3;
-pub const PR_SET_DUMPABLE: c_int = 4;
-
-pub const PR_GET_UNALIGN: c_int = 5;
-pub const PR_SET_UNALIGN: c_int = 6;
-pub const PR_UNALIGN_NOPRINT: c_int = 1;
-pub const PR_UNALIGN_SIGBUS: c_int = 2;
-
-pub const PR_GET_KEEPCAPS: c_int = 7;
-pub const PR_SET_KEEPCAPS: c_int = 8;
-
-pub const PR_GET_FPEMU: c_int = 9;
-pub const PR_SET_FPEMU: c_int = 10;
-pub const PR_FPEMU_NOPRINT: c_int = 1;
-pub const PR_FPEMU_SIGFPE: c_int = 2;
-
-pub const PR_GET_FPEXC: c_int = 11;
-pub const PR_SET_FPEXC: c_int = 12;
-pub const PR_FP_EXC_SW_ENABLE: c_int = 0x80;
-pub const PR_FP_EXC_DIV: c_int = 0x010000;
-pub const PR_FP_EXC_OVF: c_int = 0x020000;
-pub const PR_FP_EXC_UND: c_int = 0x040000;
-pub const PR_FP_EXC_RES: c_int = 0x080000;
-pub const PR_FP_EXC_INV: c_int = 0x100000;
-pub const PR_FP_EXC_DISABLED: c_int = 0;
-pub const PR_FP_EXC_NONRECOV: c_int = 1;
-pub const PR_FP_EXC_ASYNC: c_int = 2;
-pub const PR_FP_EXC_PRECISE: c_int = 3;
-
-pub const PR_GET_TIMING: c_int = 13;
-pub const PR_SET_TIMING: c_int = 14;
-pub const PR_TIMING_STATISTICAL: c_int = 0;
-pub const PR_TIMING_TIMESTAMP: c_int = 1;
-
-pub const PR_SET_NAME: c_int = 15;
-pub const PR_GET_NAME: c_int = 16;
-
-pub const PR_GET_ENDIAN: c_int = 19;
-pub const PR_SET_ENDIAN: c_int = 20;
-pub const PR_ENDIAN_BIG: c_int = 0;
-pub const PR_ENDIAN_LITTLE: c_int = 1;
-pub const PR_ENDIAN_PPC_LITTLE: c_int = 2;
-
-pub const PR_GET_SECCOMP: c_int = 21;
-pub const PR_SET_SECCOMP: c_int = 22;
-
-pub const PR_CAPBSET_READ: c_int = 23;
-pub const PR_CAPBSET_DROP: c_int = 24;
-
-pub const PR_GET_TSC: c_int = 25;
-pub const PR_SET_TSC: c_int = 26;
-pub const PR_TSC_ENABLE: c_int = 1;
-pub const PR_TSC_SIGSEGV: c_int = 2;
-
-pub const PR_GET_SECUREBITS: c_int = 27;
-pub const PR_SET_SECUREBITS: c_int = 28;
-
-pub const PR_SET_TIMERSLACK: c_int = 29;
-pub const PR_GET_TIMERSLACK: c_int = 30;
-
-pub const PR_TASK_PERF_EVENTS_DISABLE: c_int = 31;
-pub const PR_TASK_PERF_EVENTS_ENABLE: c_int = 32;
-
-pub const PR_MCE_KILL: c_int = 33;
-pub const PR_MCE_KILL_CLEAR: c_int = 0;
-pub const PR_MCE_KILL_SET: c_int = 1;
-
-pub const PR_MCE_KILL_LATE: c_int = 0;
-pub const PR_MCE_KILL_EARLY: c_int = 1;
-pub const PR_MCE_KILL_DEFAULT: c_int = 2;
-
-pub const PR_MCE_KILL_GET: c_int = 34;
-
-pub const PR_SET_MM: c_int = 35;
-pub const PR_SET_MM_START_CODE: c_int = 1;
-pub const PR_SET_MM_END_CODE: c_int = 2;
-pub const PR_SET_MM_START_DATA: c_int = 3;
-pub const PR_SET_MM_END_DATA: c_int = 4;
-pub const PR_SET_MM_START_STACK: c_int = 5;
-pub const PR_SET_MM_START_BRK: c_int = 6;
-pub const PR_SET_MM_BRK: c_int = 7;
-pub const PR_SET_MM_ARG_START: c_int = 8;
-pub const PR_SET_MM_ARG_END: c_int = 9;
-pub const PR_SET_MM_ENV_START: c_int = 10;
-pub const PR_SET_MM_ENV_END: c_int = 11;
-pub const PR_SET_MM_AUXV: c_int = 12;
-pub const PR_SET_MM_EXE_FILE: c_int = 13;
-pub const PR_SET_MM_MAP: c_int = 14;
-pub const PR_SET_MM_MAP_SIZE: c_int = 15;
-
-pub const PR_SET_PTRACER: c_int = 0x59616d61;
-pub const PR_SET_PTRACER_ANY: c_ulong = 0xffffffffffffffff;
-
-pub const PR_SET_CHILD_SUBREAPER: c_int = 36;
-pub const PR_GET_CHILD_SUBREAPER: c_int = 37;
-
-pub const PR_SET_NO_NEW_PRIVS: c_int = 38;
-pub const PR_GET_NO_NEW_PRIVS: c_int = 39;
-
 pub const PR_SET_MDWE: c_int = 65;
 pub const PR_GET_MDWE: c_int = 66;
 pub const PR_MDWE_REFUSE_EXEC_GAIN: c_uint = 1 << 0;
 pub const PR_MDWE_NO_INHERIT: c_uint = 1 << 1;
 
-pub const PR_GET_TID_ADDRESS: c_int = 40;
-
-pub const PR_SET_THP_DISABLE: c_int = 41;
-pub const PR_GET_THP_DISABLE: c_int = 42;
-
-pub const PR_MPX_ENABLE_MANAGEMENT: c_int = 43;
-pub const PR_MPX_DISABLE_MANAGEMENT: c_int = 44;
-
-pub const PR_SET_FP_MODE: c_int = 45;
-pub const PR_GET_FP_MODE: c_int = 46;
-pub const PR_FP_MODE_FR: c_int = 1 << 0;
-pub const PR_FP_MODE_FRE: c_int = 1 << 1;
-
-pub const PR_CAP_AMBIENT: c_int = 47;
-pub const PR_CAP_AMBIENT_IS_SET: c_int = 1;
-pub const PR_CAP_AMBIENT_RAISE: c_int = 2;
-pub const PR_CAP_AMBIENT_LOWER: c_int = 3;
-pub const PR_CAP_AMBIENT_CLEAR_ALL: c_int = 4;
-
-pub const PR_SET_VMA: c_int = 0x53564d41;
-pub const PR_SET_VMA_ANON_NAME: c_int = 0;
-
-pub const PR_SCHED_CORE: c_int = 62;
-pub const PR_SCHED_CORE_GET: c_int = 0;
-pub const PR_SCHED_CORE_CREATE: c_int = 1;
-pub const PR_SCHED_CORE_SHARE_TO: c_int = 2;
-pub const PR_SCHED_CORE_SHARE_FROM: c_int = 3;
-pub const PR_SCHED_CORE_MAX: c_int = 4;
-pub const PR_SCHED_CORE_SCOPE_THREAD: c_int = 0;
-pub const PR_SCHED_CORE_SCOPE_THREAD_GROUP: c_int = 1;
-pub const PR_SCHED_CORE_SCOPE_PROCESS_GROUP: c_int = 2;
-
 pub const GRND_NONBLOCK: c_uint = 0x0001;
 pub const GRND_RANDOM: c_uint = 0x0002;
 pub const GRND_INSECURE: c_uint = 0x0004;
@@ -3104,17 +1608,11 @@ pub const SECCOMP_USER_NOTIF_FLAG_CONTINUE: c_ulong = 1;
 pub const SECCOMP_ADDFD_FLAG_SETFD: c_ulong = 1;
 pub const SECCOMP_ADDFD_FLAG_SEND: c_ulong = 2;
 
-pub const ITIMER_REAL: c_int = 0;
-pub const ITIMER_VIRTUAL: c_int = 1;
-pub const ITIMER_PROF: c_int = 2;
-
 pub const TFD_CLOEXEC: c_int = O_CLOEXEC;
 pub const TFD_NONBLOCK: c_int = O_NONBLOCK;
 pub const TFD_TIMER_ABSTIME: c_int = 1;
 pub const TFD_TIMER_CANCEL_ON_SET: c_int = 2;
 
-pub const _POSIX_VDISABLE: crate::cc_t = 0;
-
 pub const FALLOC_FL_KEEP_SIZE: c_int = 0x01;
 pub const FALLOC_FL_PUNCH_HOLE: c_int = 0x02;
 pub const FALLOC_FL_COLLAPSE_RANGE: c_int = 0x08;
@@ -3140,9 +1638,6 @@ pub const IPV6_FREEBIND: c_int = 78;
 pub const IPV6_FLOWINFO_FLOWLABEL: c_int = 0x000fffff;
 pub const IPV6_FLOWINFO_PRIORITY: c_int = 0x0ff00000;
 
-pub const IPV6_RTHDR_LOOSE: c_int = 0;
-pub const IPV6_RTHDR_STRICT: c_int = 1;
-
 // SO_MEMINFO offsets
 pub const SK_MEMINFO_RMEM_ALLOC: c_int = 0;
 pub const SK_MEMINFO_RCVBUF: c_int = 1;
@@ -3154,30 +1649,6 @@ pub const SK_MEMINFO_OPTMEM: c_int = 6;
 pub const SK_MEMINFO_BACKLOG: c_int = 7;
 pub const SK_MEMINFO_DROPS: c_int = 8;
 
-pub const IUTF8: crate::tcflag_t = 0x00004000;
-#[cfg(not(all(target_env = "uclibc", target_arch = "mips")))]
-pub const CMSPAR: crate::tcflag_t = 0o10000000000;
-
-pub const MFD_CLOEXEC: c_uint = 0x0001;
-pub const MFD_ALLOW_SEALING: c_uint = 0x0002;
-pub const MFD_HUGETLB: c_uint = 0x0004;
-pub const MFD_NOEXEC_SEAL: c_uint = 0x0008;
-pub const MFD_EXEC: c_uint = 0x0010;
-pub const MFD_HUGE_64KB: c_uint = 0x40000000;
-pub const MFD_HUGE_512KB: c_uint = 0x4c000000;
-pub const MFD_HUGE_1MB: c_uint = 0x50000000;
-pub const MFD_HUGE_2MB: c_uint = 0x54000000;
-pub const MFD_HUGE_8MB: c_uint = 0x5c000000;
-pub const MFD_HUGE_16MB: c_uint = 0x60000000;
-pub const MFD_HUGE_32MB: c_uint = 0x64000000;
-pub const MFD_HUGE_256MB: c_uint = 0x70000000;
-pub const MFD_HUGE_512MB: c_uint = 0x74000000;
-pub const MFD_HUGE_1GB: c_uint = 0x78000000;
-pub const MFD_HUGE_2GB: c_uint = 0x7c000000;
-pub const MFD_HUGE_16GB: c_uint = 0x88000000;
-pub const MFD_HUGE_MASK: c_uint = 63;
-pub const MFD_HUGE_SHIFT: c_uint = 26;
-
 // linux/close_range.h
 pub const CLOSE_RANGE_UNSHARE: c_uint = 1 << 1;
 pub const CLOSE_RANGE_CLOEXEC: c_uint = 1 << 2;
@@ -3358,12 +1829,6 @@ pub const POSIX_SPAWN_SETSIGMASK: c_short = 0x08;
 pub const POSIX_SPAWN_SETSCHEDPARAM: c_short = 0x10;
 pub const POSIX_SPAWN_SETSCHEDULER: c_short = 0x20;
 
-pub const NLMSG_NOOP: c_int = 0x1;
-pub const NLMSG_ERROR: c_int = 0x2;
-pub const NLMSG_DONE: c_int = 0x3;
-pub const NLMSG_OVERRUN: c_int = 0x4;
-pub const NLMSG_MIN_TYPE: c_int = 0x10;
-
 // linux/netfilter/nfnetlink.h
 pub const NFNLGRP_NONE: c_int = 0;
 pub const NFNLGRP_CONNTRACK_NEW: c_int = 1;
@@ -3393,8 +1858,8 @@ pub const NFNL_SUBSYS_NFT_COMPAT: c_int = 11;
 pub const NFNL_SUBSYS_HOOK: c_int = 12;
 pub const NFNL_SUBSYS_COUNT: c_int = 13;
 
-pub const NFNL_MSG_BATCH_BEGIN: c_int = NLMSG_MIN_TYPE;
-pub const NFNL_MSG_BATCH_END: c_int = NLMSG_MIN_TYPE + 1;
+pub const NFNL_MSG_BATCH_BEGIN: c_int = crate::NLMSG_MIN_TYPE;
+pub const NFNL_MSG_BATCH_END: c_int = crate::NLMSG_MIN_TYPE + 1;
 
 pub const NFNL_BATCH_UNSPEC: c_int = 0;
 pub const NFNL_BATCH_GENID: c_int = 1;
@@ -3517,7 +1982,7 @@ pub const NFQA_SKB_CSUM_NOTVERIFIED: c_int = 0x0004;
 
 pub const GENL_NAMSIZ: c_int = 16;
 
-pub const GENL_MIN_ID: c_int = NLMSG_MIN_TYPE;
+pub const GENL_MIN_ID: c_int = crate::NLMSG_MIN_TYPE;
 pub const GENL_MAX_ID: c_int = 1023;
 
 pub const GENL_ADMIN_PERM: c_int = 0x01;
@@ -3525,7 +1990,7 @@ pub const GENL_CMD_CAP_DO: c_int = 0x02;
 pub const GENL_CMD_CAP_DUMP: c_int = 0x04;
 pub const GENL_CMD_CAP_HASPOL: c_int = 0x08;
 
-pub const GENL_ID_CTRL: c_int = NLMSG_MIN_TYPE;
+pub const GENL_ID_CTRL: c_int = crate::NLMSG_MIN_TYPE;
 
 pub const CTRL_CMD_UNSPEC: c_int = 0;
 pub const CTRL_CMD_NEWFAMILY: c_int = 1;
@@ -3555,32 +2020,6 @@ pub const CTRL_ATTR_MCAST_GRP_UNSPEC: c_int = 0;
 pub const CTRL_ATTR_MCAST_GRP_NAME: c_int = 1;
 pub const CTRL_ATTR_MCAST_GRP_ID: c_int = 2;
 
-// linux/if_packet.h
-pub const PACKET_HOST: c_uchar = 0;
-pub const PACKET_BROADCAST: c_uchar = 1;
-pub const PACKET_MULTICAST: c_uchar = 2;
-pub const PACKET_OTHERHOST: c_uchar = 3;
-pub const PACKET_OUTGOING: c_uchar = 4;
-pub const PACKET_LOOPBACK: c_uchar = 5;
-pub const PACKET_USER: c_uchar = 6;
-pub const PACKET_KERNEL: c_uchar = 7;
-
-pub const PACKET_ADD_MEMBERSHIP: c_int = 1;
-pub const PACKET_DROP_MEMBERSHIP: c_int = 2;
-pub const PACKET_RECV_OUTPUT: c_int = 3;
-pub const PACKET_RX_RING: c_int = 5;
-pub const PACKET_STATISTICS: c_int = 6;
-pub const PACKET_COPY_THRESH: c_int = 7;
-pub const PACKET_AUXDATA: c_int = 8;
-pub const PACKET_ORIGDEV: c_int = 9;
-pub const PACKET_VERSION: c_int = 10;
-pub const PACKET_HDRLEN: c_int = 11;
-pub const PACKET_RESERVE: c_int = 12;
-pub const PACKET_TX_RING: c_int = 13;
-pub const PACKET_LOSS: c_int = 14;
-pub const PACKET_VNET_HDR: c_int = 15;
-pub const PACKET_TX_TIMESTAMP: c_int = 16;
-pub const PACKET_TIMESTAMP: c_int = 17;
 pub const PACKET_FANOUT: c_int = 18;
 pub const PACKET_TX_HAS_OFF: c_int = 19;
 pub const PACKET_QDISC_BYPASS: c_int = 20;
@@ -3602,10 +2041,6 @@ pub const PACKET_FANOUT_FLAG_UNIQUEID: c_uint = 0x2000;
 pub const PACKET_FANOUT_FLAG_IGNORE_OUTGOING: c_uint = 0x4000;
 pub const PACKET_FANOUT_FLAG_DEFRAG: c_uint = 0x8000;
 
-pub const PACKET_MR_MULTICAST: c_int = 0;
-pub const PACKET_MR_PROMISC: c_int = 1;
-pub const PACKET_MR_ALLMULTI: c_int = 2;
-
 pub const TP_STATUS_KERNEL: __u32 = 0;
 pub const TP_STATUS_USER: __u32 = 1 << 0;
 pub const TP_STATUS_COPY: __u32 = 1 << 1;
@@ -3754,62 +2189,6 @@ pub const NF_IP6_PRI_LAST: c_int = crate::INT_MAX;
 // linux/netfilter_ipv6/ip6_tables.h
 pub const IP6T_SO_ORIGINAL_DST: c_int = 80;
 
-pub const SIOCADDRT: c_ulong = 0x0000890B;
-pub const SIOCDELRT: c_ulong = 0x0000890C;
-pub const SIOCGIFNAME: c_ulong = 0x00008910;
-pub const SIOCSIFLINK: c_ulong = 0x00008911;
-pub const SIOCGIFCONF: c_ulong = 0x00008912;
-pub const SIOCGIFFLAGS: c_ulong = 0x00008913;
-pub const SIOCSIFFLAGS: c_ulong = 0x00008914;
-pub const SIOCGIFADDR: c_ulong = 0x00008915;
-pub const SIOCSIFADDR: c_ulong = 0x00008916;
-pub const SIOCGIFDSTADDR: c_ulong = 0x00008917;
-pub const SIOCSIFDSTADDR: c_ulong = 0x00008918;
-pub const SIOCGIFBRDADDR: c_ulong = 0x00008919;
-pub const SIOCSIFBRDADDR: c_ulong = 0x0000891A;
-pub const SIOCGIFNETMASK: c_ulong = 0x0000891B;
-pub const SIOCSIFNETMASK: c_ulong = 0x0000891C;
-pub const SIOCGIFMETRIC: c_ulong = 0x0000891D;
-pub const SIOCSIFMETRIC: c_ulong = 0x0000891E;
-pub const SIOCGIFMEM: c_ulong = 0x0000891F;
-pub const SIOCSIFMEM: c_ulong = 0x00008920;
-pub const SIOCGIFMTU: c_ulong = 0x00008921;
-pub const SIOCSIFMTU: c_ulong = 0x00008922;
-pub const SIOCSIFNAME: c_ulong = 0x00008923;
-pub const SIOCSIFHWADDR: c_ulong = 0x00008924;
-pub const SIOCGIFENCAP: c_ulong = 0x00008925;
-pub const SIOCSIFENCAP: c_ulong = 0x00008926;
-pub const SIOCGIFHWADDR: c_ulong = 0x00008927;
-pub const SIOCGIFSLAVE: c_ulong = 0x00008929;
-pub const SIOCSIFSLAVE: c_ulong = 0x00008930;
-pub const SIOCADDMULTI: c_ulong = 0x00008931;
-pub const SIOCDELMULTI: c_ulong = 0x00008932;
-pub const SIOCGIFINDEX: c_ulong = 0x00008933;
-pub const SIOGIFINDEX: c_ulong = SIOCGIFINDEX;
-pub const SIOCSIFPFLAGS: c_ulong = 0x00008934;
-pub const SIOCGIFPFLAGS: c_ulong = 0x00008935;
-pub const SIOCDIFADDR: c_ulong = 0x00008936;
-pub const SIOCSIFHWBROADCAST: c_ulong = 0x00008937;
-pub const SIOCGIFCOUNT: c_ulong = 0x00008938;
-pub const SIOCGIFBR: c_ulong = 0x00008940;
-pub const SIOCSIFBR: c_ulong = 0x00008941;
-pub const SIOCGIFTXQLEN: c_ulong = 0x00008942;
-pub const SIOCSIFTXQLEN: c_ulong = 0x00008943;
-pub const SIOCETHTOOL: c_ulong = 0x00008946;
-pub const SIOCGMIIPHY: c_ulong = 0x00008947;
-pub const SIOCGMIIREG: c_ulong = 0x00008948;
-pub const SIOCSMIIREG: c_ulong = 0x00008949;
-pub const SIOCWANDEV: c_ulong = 0x0000894A;
-pub const SIOCOUTQNSD: c_ulong = 0x0000894B;
-pub const SIOCGSKNS: c_ulong = 0x0000894C;
-pub const SIOCDARP: c_ulong = 0x00008953;
-pub const SIOCGARP: c_ulong = 0x00008954;
-pub const SIOCSARP: c_ulong = 0x00008955;
-pub const SIOCDRARP: c_ulong = 0x00008960;
-pub const SIOCGRARP: c_ulong = 0x00008961;
-pub const SIOCSRARP: c_ulong = 0x00008962;
-pub const SIOCGIFMAP: c_ulong = 0x00008970;
-pub const SIOCSIFMAP: c_ulong = 0x00008971;
 pub const SIOCSHWTSTAMP: c_ulong = 0x000089b0;
 pub const SIOCGHWTSTAMP: c_ulong = 0x000089b1;
 
@@ -4108,58 +2487,6 @@ pub const IW_EV_ADDR_PK_LEN: usize = 20; // IW_EV_LCP_PK_LEN + size_of::<crate::
 pub const IW_EV_QUAL_PK_LEN: usize = 8; // IW_EV_LCP_PK_LEN + size_of::<iw_quality>();
 pub const IW_EV_POINT_PK_LEN: usize = 8; // IW_EV_LCP_PK_LEN + 4;
 
-pub const IPTOS_TOS_MASK: u8 = 0x1E;
-pub const IPTOS_PREC_MASK: u8 = 0xE0;
-
-pub const IPTOS_ECN_NOT_ECT: u8 = 0x00;
-
-pub const RTF_UP: c_ushort = 0x0001;
-pub const RTF_GATEWAY: c_ushort = 0x0002;
-
-pub const RTF_HOST: c_ushort = 0x0004;
-pub const RTF_REINSTATE: c_ushort = 0x0008;
-pub const RTF_DYNAMIC: c_ushort = 0x0010;
-pub const RTF_MODIFIED: c_ushort = 0x0020;
-pub const RTF_MTU: c_ushort = 0x0040;
-pub const RTF_MSS: c_ushort = RTF_MTU;
-pub const RTF_WINDOW: c_ushort = 0x0080;
-pub const RTF_IRTT: c_ushort = 0x0100;
-pub const RTF_REJECT: c_ushort = 0x0200;
-pub const RTF_STATIC: c_ushort = 0x0400;
-pub const RTF_XRESOLVE: c_ushort = 0x0800;
-pub const RTF_NOFORWARD: c_ushort = 0x1000;
-pub const RTF_THROW: c_ushort = 0x2000;
-pub const RTF_NOPMTUDISC: c_ushort = 0x4000;
-
-pub const RTF_DEFAULT: u32 = 0x00010000;
-pub const RTF_ALLONLINK: u32 = 0x00020000;
-pub const RTF_ADDRCONF: u32 = 0x00040000;
-pub const RTF_LINKRT: u32 = 0x00100000;
-pub const RTF_NONEXTHOP: u32 = 0x00200000;
-pub const RTF_CACHE: u32 = 0x01000000;
-pub const RTF_FLOW: u32 = 0x02000000;
-pub const RTF_POLICY: u32 = 0x04000000;
-
-pub const RTCF_VALVE: u32 = 0x00200000;
-pub const RTCF_MASQ: u32 = 0x00400000;
-pub const RTCF_NAT: u32 = 0x00800000;
-pub const RTCF_DOREDIRECT: u32 = 0x01000000;
-pub const RTCF_LOG: u32 = 0x02000000;
-pub const RTCF_DIRECTSRC: u32 = 0x04000000;
-
-pub const RTF_LOCAL: u32 = 0x80000000;
-pub const RTF_INTERFACE: u32 = 0x40000000;
-pub const RTF_MULTICAST: u32 = 0x20000000;
-pub const RTF_BROADCAST: u32 = 0x10000000;
-pub const RTF_NAT: u32 = 0x08000000;
-pub const RTF_ADDRCLASSMASK: u32 = 0xF8000000;
-
-pub const RT_CLASS_UNSPEC: u8 = 0;
-pub const RT_CLASS_DEFAULT: u8 = 253;
-pub const RT_CLASS_MAIN: u8 = 254;
-pub const RT_CLASS_LOCAL: u8 = 255;
-pub const RT_CLASS_MAX: u8 = 255;
-
 // linux/neighbor.h
 pub const NUD_NONE: u16 = 0x00;
 pub const NUD_INCOMPLETE: u16 = 0x01;
@@ -4378,12 +2705,6 @@ pub const RTMSG_DELRULE: u32 = 0x32;
 pub const RTMSG_CONTROL: u32 = 0x40;
 pub const RTMSG_AR_FAILED: u32 = 0x51;
 
-pub const MAX_ADDR_LEN: usize = 7;
-pub const ARPD_UPDATE: c_ushort = 0x01;
-pub const ARPD_LOOKUP: c_ushort = 0x02;
-pub const ARPD_FLUSH: c_ushort = 0x03;
-pub const ATF_MAGIC: c_int = 0x80;
-
 pub const RTEXT_FILTER_VF: c_int = 1 << 0;
 pub const RTEXT_FILTER_BRVLAN: c_int = 1 << 1;
 pub const RTEXT_FILTER_BRVLAN_COMPRESSED: c_int = 1 << 2;
@@ -4689,20 +3010,10 @@ pub const IF_LINK_MODE_DEFAULT: c_int = 0;
 pub const IF_LINK_MODE_DORMANT: c_int = 1;
 pub const IF_LINK_MODE_TESTING: c_int = 2;
 
-// include/uapi/linux/udp.h
-pub const UDP_CORK: c_int = 1;
-pub const UDP_ENCAP: c_int = 100;
-pub const UDP_NO_CHECK6_TX: c_int = 101;
-pub const UDP_NO_CHECK6_RX: c_int = 102;
-
 // include/uapi/linux/mman.h
 pub const MAP_SHARED_VALIDATE: c_int = 0x3;
 pub const MAP_DROPPABLE: c_int = 0x8;
 
-// include/uapi/asm-generic/mman-common.h
-pub const MAP_FIXED_NOREPLACE: c_int = 0x100000;
-pub const MLOCK_ONFAULT: c_uint = 0x01;
-
 // uapi/linux/vm_sockets.h
 pub const VMADDR_CID_ANY: c_uint = 0xFFFFFFFF;
 pub const VMADDR_CID_HYPERVISOR: c_uint = 0;
@@ -5256,29 +3567,6 @@ pub const LINUX_REBOOT_CMD_RESTART2: c_int = 0xA1B2C3D4;
 pub const LINUX_REBOOT_CMD_SW_SUSPEND: c_int = 0xD000FCE2;
 pub const LINUX_REBOOT_CMD_KEXEC: c_int = 0x45584543;
 
-pub const REG_EXTENDED: c_int = 1;
-pub const REG_ICASE: c_int = 2;
-pub const REG_NEWLINE: c_int = 4;
-pub const REG_NOSUB: c_int = 8;
-
-pub const REG_NOTBOL: c_int = 1;
-pub const REG_NOTEOL: c_int = 2;
-
-pub const REG_ENOSYS: c_int = -1;
-pub const REG_NOMATCH: c_int = 1;
-pub const REG_BADPAT: c_int = 2;
-pub const REG_ECOLLATE: c_int = 3;
-pub const REG_ECTYPE: c_int = 4;
-pub const REG_EESCAPE: c_int = 5;
-pub const REG_ESUBREG: c_int = 6;
-pub const REG_EBRACK: c_int = 7;
-pub const REG_EPAREN: c_int = 8;
-pub const REG_EBRACE: c_int = 9;
-pub const REG_BADBR: c_int = 10;
-pub const REG_ERANGE: c_int = 11;
-pub const REG_ESPACE: c_int = 12;
-pub const REG_BADRPT: c_int = 13;
-
 // linux/errqueue.h
 pub const SO_EE_ORIGIN_NONE: u8 = 0;
 pub const SO_EE_ORIGIN_LOCAL: u8 = 1;
@@ -5287,43 +3575,6 @@ pub const SO_EE_ORIGIN_ICMP6: u8 = 3;
 pub const SO_EE_ORIGIN_TXSTATUS: u8 = 4;
 pub const SO_EE_ORIGIN_TIMESTAMPING: u8 = SO_EE_ORIGIN_TXSTATUS;
 
-// errno.h
-pub const EPERM: c_int = 1;
-pub const ENOENT: c_int = 2;
-pub const ESRCH: c_int = 3;
-pub const EINTR: c_int = 4;
-pub const EIO: c_int = 5;
-pub const ENXIO: c_int = 6;
-pub const E2BIG: c_int = 7;
-pub const ENOEXEC: c_int = 8;
-pub const EBADF: c_int = 9;
-pub const ECHILD: c_int = 10;
-pub const EAGAIN: c_int = 11;
-pub const ENOMEM: c_int = 12;
-pub const EACCES: c_int = 13;
-pub const EFAULT: c_int = 14;
-pub const ENOTBLK: c_int = 15;
-pub const EBUSY: c_int = 16;
-pub const EEXIST: c_int = 17;
-pub const EXDEV: c_int = 18;
-pub const ENODEV: c_int = 19;
-pub const ENOTDIR: c_int = 20;
-pub const EISDIR: c_int = 21;
-pub const EINVAL: c_int = 22;
-pub const ENFILE: c_int = 23;
-pub const EMFILE: c_int = 24;
-pub const ENOTTY: c_int = 25;
-pub const ETXTBSY: c_int = 26;
-pub const EFBIG: c_int = 27;
-pub const ENOSPC: c_int = 28;
-pub const ESPIPE: c_int = 29;
-pub const EROFS: c_int = 30;
-pub const EMLINK: c_int = 31;
-pub const EPIPE: c_int = 32;
-pub const EDOM: c_int = 33;
-pub const ERANGE: c_int = 34;
-pub const EWOULDBLOCK: c_int = EAGAIN;
-
 // linux/sctp.h
 pub const SCTP_FUTURE_ASSOC: c_int = 0;
 pub const SCTP_CURRENT_ASSOC: c_int = 1;
@@ -5625,21 +3876,6 @@ pub const PF_SUSPEND_TASK: c_int = PF_SUSPEND_TASK_UINT as _;
 // desired information as-is in terms of integer representation.
 const PF_SUSPEND_TASK_UINT: c_uint = 0x80000000;
 
-pub const CSIGNAL: c_int = 0x000000ff;
-
-pub const SCHED_NORMAL: c_int = 0;
-pub const SCHED_OTHER: c_int = 0;
-pub const SCHED_FIFO: c_int = 1;
-pub const SCHED_RR: c_int = 2;
-pub const SCHED_BATCH: c_int = 3;
-pub const SCHED_IDLE: c_int = 5;
-pub const SCHED_DEADLINE: c_int = 6;
-
-pub const SCHED_RESET_ON_FORK: c_int = 0x40000000;
-
-pub const CLONE_CLEAR_SIGHAND: c_ulonglong = 0x100000000;
-pub const CLONE_INTO_CGROUP: c_ulonglong = 0x200000000;
-
 pub const SCHED_FLAG_RESET_ON_FORK: c_int = 0x01;
 pub const SCHED_FLAG_RECLAIM: c_int = 0x02;
 pub const SCHED_FLAG_DL_OVERRUN: c_int = 0x04;
@@ -5706,25 +3942,6 @@ pub const MOUNT_ATTR_NOSYMFOLLOW: crate::__u64 = 0x00200000;
 
 pub const MOUNT_ATTR_SIZE_VER0: c_int = 32;
 
-// elf.h
-pub const NT_PRSTATUS: c_int = 1;
-pub const NT_PRFPREG: c_int = 2;
-pub const NT_FPREGSET: c_int = 2;
-pub const NT_PRPSINFO: c_int = 3;
-pub const NT_PRXREG: c_int = 4;
-pub const NT_TASKSTRUCT: c_int = 4;
-pub const NT_PLATFORM: c_int = 5;
-pub const NT_AUXV: c_int = 6;
-pub const NT_GWINDOWS: c_int = 7;
-pub const NT_ASRS: c_int = 8;
-pub const NT_PSTATUS: c_int = 10;
-pub const NT_PSINFO: c_int = 13;
-pub const NT_PRCRED: c_int = 14;
-pub const NT_UTSNAME: c_int = 15;
-pub const NT_LWPSTATUS: c_int = 16;
-pub const NT_LWPSINFO: c_int = 17;
-pub const NT_PRFPXREG: c_int = 20;
-
 pub const SCHED_FLAG_KEEP_ALL: c_int = SCHED_FLAG_KEEP_POLICY | SCHED_FLAG_KEEP_PARAMS;
 
 pub const SCHED_FLAG_UTIL_CLAMP: c_int = SCHED_FLAG_UTIL_CLAMP_MIN | SCHED_FLAG_UTIL_CLAMP_MAX;
@@ -5748,68 +3965,6 @@ f! {
         return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1);
     }
 
-    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
-        if ((*cmsg).cmsg_len as usize) < size_of::<cmsghdr>() {
-            return core::ptr::null_mut::<cmsghdr>();
-        }
-        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
-        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
-        if (next.wrapping_offset(1)) as usize > max
-            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max
-        {
-            core::ptr::null_mut::<cmsghdr>()
-        } else {
-            next
-        }
-    }
-
-    pub fn CPU_ALLOC_SIZE(count: c_int) -> size_t {
-        let _dummy: cpu_set_t = mem::zeroed();
-        let size_in_bits = 8 * size_of_val(&_dummy.bits[0]);
-        ((count as size_t + size_in_bits - 1) / 8) as size_t
-    }
-
-    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
-        for slot in &mut cpuset.bits {
-            *slot = 0;
-        }
-    }
-
-    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
-        let size_in_bits = 8 * size_of_val(&cpuset.bits[0]); // 32, 64 etc
-        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
-        cpuset.bits[idx] |= 1 << offset;
-    }
-
-    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
-        let size_in_bits = 8 * size_of_val(&cpuset.bits[0]); // 32, 64 etc
-        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
-        cpuset.bits[idx] &= !(1 << offset);
-    }
-
-    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
-        let size_in_bits = 8 * size_of_val(&cpuset.bits[0]);
-        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
-        0 != (cpuset.bits[idx] & (1 << offset))
-    }
-
-    pub fn CPU_COUNT_S(size: usize, cpuset: &cpu_set_t) -> c_int {
-        let mut s: u32 = 0;
-        let size_of_mask = size_of_val(&cpuset.bits[0]);
-        for i in &cpuset.bits[..(size / size_of_mask)] {
-            s += i.count_ones();
-        }
-        s as c_int
-    }
-
-    pub fn CPU_COUNT(cpuset: &cpu_set_t) -> c_int {
-        CPU_COUNT_S(size_of::<cpu_set_t>(), cpuset)
-    }
-
-    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
-        set1.bits == set2.bits
-    }
-
     pub fn SCTP_PR_INDEX(policy: c_int) -> c_int {
         policy >> (4 - 1)
     }
@@ -5823,26 +3978,6 @@ f! {
         *flags |= policy;
     }
 
-    pub fn IPTOS_TOS(tos: u8) -> u8 {
-        tos & IPTOS_TOS_MASK
-    }
-
-    pub fn IPTOS_PREC(tos: u8) -> u8 {
-        tos & IPTOS_PREC_MASK
-    }
-
-    pub fn RT_TOS(tos: u8) -> u8 {
-        tos & crate::IPTOS_TOS_MASK
-    }
-
-    pub fn RT_ADDRCLASS(flags: u32) -> u32 {
-        flags >> 23
-    }
-
-    pub fn RT_LOCALADDR(flags: u32) -> bool {
-        (flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE)
-    }
-
     pub fn SO_EE_OFFENDER(ee: *const crate::sock_extended_err) -> *mut crate::sockaddr {
         ee.offset(1) as *mut crate::sockaddr
     }
@@ -5891,58 +4026,9 @@ f! {
     pub fn BPF_JUMP(code: __u16, k: __u32, jt: __u8, jf: __u8) -> sock_filter {
         sock_filter { code, jt, jf, k }
     }
-
-    pub fn ELF32_R_SYM(val: Elf32_Word) -> Elf32_Word {
-        val >> 8
-    }
-
-    pub fn ELF32_R_TYPE(val: Elf32_Word) -> Elf32_Word {
-        val & 0xff
-    }
-
-    pub fn ELF32_R_INFO(sym: Elf32_Word, t: Elf32_Word) -> Elf32_Word {
-        sym << (8 + t) & 0xff
-    }
-
-    pub fn ELF64_R_SYM(val: Elf64_Xword) -> Elf64_Xword {
-        val >> 32
-    }
-
-    pub fn ELF64_R_TYPE(val: Elf64_Xword) -> Elf64_Xword {
-        val & 0xffffffff
-    }
-
-    pub fn ELF64_R_INFO(sym: Elf64_Xword, t: Elf64_Xword) -> Elf64_Xword {
-        sym << (32 + t)
-    }
 }
 
 safe_f! {
-    pub const fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {
-        let major = major as crate::dev_t;
-        let minor = minor as crate::dev_t;
-        let mut dev = 0;
-        dev |= (major & 0x00000fff) << 8;
-        dev |= (major & 0xfffff000) << 32;
-        dev |= (minor & 0x000000ff) << 0;
-        dev |= (minor & 0xffffff00) << 12;
-        dev
-    }
-
-    pub const fn major(dev: crate::dev_t) -> c_uint {
-        let mut major = 0;
-        major |= (dev & 0x00000000000fff00) >> 8;
-        major |= (dev & 0xfffff00000000000) >> 32;
-        major as c_uint
-    }
-
-    pub const fn minor(dev: crate::dev_t) -> c_uint {
-        let mut minor = 0;
-        minor |= (dev & 0x00000000000000ff) >> 0;
-        minor |= (dev & 0x00000ffffff00000) >> 12;
-        minor as c_uint
-    }
-
     pub const fn SCTP_PR_TTL_ENABLED(policy: c_int) -> bool {
         policy == SCTP_PR_SCTP_TTL
     }
@@ -5956,98 +4042,6 @@ safe_f! {
     }
 }
 
-cfg_if! {
-    if #[cfg(all(
-        any(target_env = "gnu", target_env = "musl", target_env = "ohos"),
-        any(target_arch = "x86_64", target_arch = "x86")
-    ))] {
-        extern "C" {
-            pub fn iopl(level: c_int) -> c_int;
-            pub fn ioperm(from: c_ulong, num: c_ulong, turn_on: c_int) -> c_int;
-        }
-    }
-}
-
-cfg_if! {
-    if #[cfg(all(not(target_env = "uclibc"), not(target_env = "ohos")))] {
-        extern "C" {
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_read64")]
-            pub fn aio_read(aiocbp: *mut aiocb) -> c_int;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_write64")]
-            pub fn aio_write(aiocbp: *mut aiocb) -> c_int;
-            pub fn aio_fsync(op: c_int, aiocbp: *mut aiocb) -> c_int;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_error64")]
-            pub fn aio_error(aiocbp: *const aiocb) -> c_int;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_return64")]
-            pub fn aio_return(aiocbp: *mut aiocb) -> ssize_t;
-            #[cfg_attr(gnu_time_bits64, link_name = "__aio_suspend_time64")]
-            pub fn aio_suspend(
-                aiocb_list: *const *const aiocb,
-                nitems: c_int,
-                timeout: *const crate::timespec,
-            ) -> c_int;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_cancel64")]
-            pub fn aio_cancel(fd: c_int, aiocbp: *mut aiocb) -> c_int;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "lio_listio64")]
-            pub fn lio_listio(
-                mode: c_int,
-                aiocb_list: *const *mut aiocb,
-                nitems: c_int,
-                sevp: *mut crate::sigevent,
-            ) -> c_int;
-        }
-    }
-}
-
-cfg_if! {
-    if #[cfg(not(target_env = "uclibc"))] {
-        extern "C" {
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "pwritev64")]
-            pub fn pwritev(
-                fd: c_int,
-                iov: *const crate::iovec,
-                iovcnt: c_int,
-                offset: off_t,
-            ) -> ssize_t;
-            #[cfg_attr(gnu_file_offset_bits64, link_name = "preadv64")]
-            pub fn preadv(
-                fd: c_int,
-                iov: *const crate::iovec,
-                iovcnt: c_int,
-                offset: off_t,
-            ) -> ssize_t;
-            pub fn getnameinfo(
-                sa: *const crate::sockaddr,
-                salen: crate::socklen_t,
-                host: *mut c_char,
-                hostlen: crate::socklen_t,
-                serv: *mut c_char,
-                servlen: crate::socklen_t,
-                flags: c_int,
-            ) -> c_int;
-            pub fn getloadavg(loadavg: *mut c_double, nelem: c_int) -> c_int;
-            pub fn process_vm_readv(
-                pid: crate::pid_t,
-                local_iov: *const crate::iovec,
-                liovcnt: c_ulong,
-                remote_iov: *const crate::iovec,
-                riovcnt: c_ulong,
-                flags: c_ulong,
-            ) -> isize;
-            pub fn process_vm_writev(
-                pid: crate::pid_t,
-                local_iov: *const crate::iovec,
-                liovcnt: c_ulong,
-                remote_iov: *const crate::iovec,
-                riovcnt: c_ulong,
-                flags: c_ulong,
-            ) -> isize;
-            #[cfg_attr(gnu_time_bits64, link_name = "__futimes64")]
-            pub fn futimes(fd: c_int, times: *const crate::timeval) -> c_int;
-        }
-    }
-}
-
 // These functions are not available on OpenHarmony
 cfg_if! {
     if #[cfg(not(target_env = "ohos"))] {
@@ -6057,10 +4051,10 @@ cfg_if! {
             // https://git.musl-libc.org/cgit/musl/tree/include/shadow.h
             pub fn getspnam_r(
                 name: *const c_char,
-                spbuf: *mut spwd,
+                spbuf: *mut crate::spwd,
                 buf: *mut c_char,
                 buflen: size_t,
-                spbufp: *mut *mut spwd,
+                spbufp: *mut *mut crate::spwd,
             ) -> c_int;
 
             pub fn mq_open(name: *const c_char, oflag: c_int, ...) -> crate::mqd_t;
@@ -6101,14 +4095,13 @@ cfg_if! {
                 oldattr: *mut crate::mq_attr,
             ) -> c_int;
 
-            pub fn pthread_mutex_consistent(mutex: *mut pthread_mutex_t) -> c_int;
-            pub fn pthread_cancel(thread: crate::pthread_t) -> c_int;
+            pub fn pthread_mutex_consistent(mutex: *mut crate::pthread_mutex_t) -> c_int;
             pub fn pthread_mutexattr_getrobust(
-                attr: *const pthread_mutexattr_t,
+                attr: *const crate::pthread_mutexattr_t,
                 robustness: *mut c_int,
             ) -> c_int;
             pub fn pthread_mutexattr_setrobust(
-                attr: *mut pthread_mutexattr_t,
+                attr: *mut crate::pthread_mutexattr_t,
                 robustness: c_int,
             ) -> c_int;
         }
@@ -6116,51 +4109,17 @@ cfg_if! {
 }
 
 extern "C" {
-    #[cfg_attr(
-        not(any(target_env = "musl", target_env = "ohos")),
-        link_name = "__xpg_strerror_r"
-    )]
-    pub fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
-
-    pub fn abs(i: c_int) -> c_int;
-    pub fn labs(i: c_long) -> c_long;
-    pub fn rand() -> c_int;
-    pub fn srand(seed: c_uint);
-
-    pub fn drand48() -> c_double;
-    pub fn erand48(xseed: *mut c_ushort) -> c_double;
-    pub fn lrand48() -> c_long;
-    pub fn nrand48(xseed: *mut c_ushort) -> c_long;
     pub fn mrand48() -> c_long;
-    pub fn jrand48(xseed: *mut c_ushort) -> c_long;
-    pub fn srand48(seed: c_long);
     pub fn seed48(xseed: *mut c_ushort) -> *mut c_ushort;
     pub fn lcong48(p: *mut c_ushort);
 
     #[cfg_attr(gnu_time_bits64, link_name = "__lutimes64")]
     pub fn lutimes(file: *const c_char, times: *const crate::timeval) -> c_int;
 
-    pub fn setpwent();
-    pub fn endpwent();
-    pub fn getpwent() -> *mut passwd;
-    pub fn setgrent();
-    pub fn endgrent();
-    pub fn getgrent() -> *mut crate::group;
-    pub fn setspent();
-    pub fn endspent();
-    pub fn getspent() -> *mut spwd;
-
-    pub fn getspnam(name: *const c_char) -> *mut spwd;
-
-    pub fn shm_open(name: *const c_char, oflag: c_int, mode: mode_t) -> c_int;
+    pub fn shm_open(name: *const c_char, oflag: c_int, mode: crate::mode_t) -> c_int;
     pub fn shm_unlink(name: *const c_char) -> c_int;
 
     // System V IPC
-    pub fn shmget(key: crate::key_t, size: size_t, shmflg: c_int) -> c_int;
-    pub fn shmat(shmid: c_int, shmaddr: *const c_void, shmflg: c_int) -> *mut c_void;
-    pub fn shmdt(shmaddr: *const c_void) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__shmctl64")]
-    pub fn shmctl(shmid: c_int, cmd: c_int, buf: *mut crate::shmid_ds) -> c_int;
     pub fn ftok(pathname: *const c_char, proj_id: c_int) -> crate::key_t;
     pub fn semget(key: crate::key_t, nsems: c_int, semflag: c_int) -> c_int;
     pub fn semop(semid: c_int, sops: *mut crate::sembuf, nsops: size_t) -> c_int;
@@ -6178,14 +4137,11 @@ extern "C" {
     ) -> ssize_t;
     pub fn msgsnd(msqid: c_int, msgp: *const c_void, msgsz: size_t, msgflg: c_int) -> c_int;
 
-    pub fn mprotect(addr: *mut c_void, len: size_t, prot: c_int) -> c_int;
-    pub fn __errno_location() -> *mut c_int;
-
     #[cfg_attr(gnu_file_offset_bits64, link_name = "fallocate64")]
     pub fn fallocate(fd: c_int, mode: c_int, offset: off_t, len: off_t) -> c_int;
     #[cfg_attr(gnu_file_offset_bits64, link_name = "posix_fallocate64")]
     pub fn posix_fallocate(fd: c_int, offset: off_t, len: off_t) -> c_int;
-    pub fn readahead(fd: c_int, offset: off64_t, count: size_t) -> ssize_t;
+    pub fn readahead(fd: c_int, offset: crate::off64_t, count: size_t) -> ssize_t;
     pub fn getxattr(
         path: *const c_char,
         name: *const c_char,
@@ -6234,13 +4190,13 @@ extern "C" {
     pub fn signalfd(fd: c_int, mask: *const crate::sigset_t, flags: c_int) -> c_int;
     pub fn timerfd_create(clockid: crate::clockid_t, flags: c_int) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__timerfd_gettime64")]
-    pub fn timerfd_gettime(fd: c_int, curr_value: *mut itimerspec) -> c_int;
+    pub fn timerfd_gettime(fd: c_int, curr_value: *mut crate::itimerspec) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__timerfd_settime64")]
     pub fn timerfd_settime(
         fd: c_int,
         flags: c_int,
-        new_value: *const itimerspec,
-        old_value: *mut itimerspec,
+        new_value: *const crate::itimerspec,
+        old_value: *mut crate::itimerspec,
     ) -> c_int;
     pub fn quotactl(cmd: c_int, special: *const c_char, id: c_int, data: *mut c_char) -> c_int;
     pub fn epoll_pwait(
@@ -6258,67 +4214,27 @@ extern "C" {
         timeout: *const crate::timespec,
     ) -> c_int;
     pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> c_int;
-    pub fn nl_langinfo_l(item: crate::nl_item, locale: crate::locale_t) -> *mut c_char;
     pub fn accept4(
         fd: c_int,
         addr: *mut crate::sockaddr,
         len: *mut crate::socklen_t,
         flg: c_int,
     ) -> c_int;
-    pub fn pthread_getaffinity_np(
-        thread: crate::pthread_t,
-        cpusetsize: size_t,
-        cpuset: *mut crate::cpu_set_t,
-    ) -> c_int;
-    pub fn pthread_setaffinity_np(
-        thread: crate::pthread_t,
-        cpusetsize: size_t,
-        cpuset: *const crate::cpu_set_t,
-    ) -> c_int;
-    pub fn pthread_setschedprio(native: crate::pthread_t, priority: c_int) -> c_int;
     pub fn reboot(how_to: c_int) -> c_int;
     pub fn setfsgid(gid: crate::gid_t) -> c_int;
     pub fn setfsuid(uid: crate::uid_t) -> c_int;
 
     // Not available now on Android
-    pub fn mkfifoat(dirfd: c_int, pathname: *const c_char, mode: mode_t) -> c_int;
-    pub fn if_nameindex() -> *mut if_nameindex;
-    pub fn if_freenameindex(ptr: *mut if_nameindex);
-    pub fn sync_file_range(fd: c_int, offset: off64_t, nbytes: off64_t, flags: c_uint) -> c_int;
-    pub fn mremap(
-        addr: *mut c_void,
-        len: size_t,
-        new_len: size_t,
-        flags: c_int,
-        ...
-    ) -> *mut c_void;
-
-    #[cfg_attr(gnu_time_bits64, link_name = "__glob64_time64")]
-    #[cfg_attr(
-        all(not(gnu_time_bits64), gnu_file_offset_bits64),
-        link_name = "glob64"
-    )]
-    pub fn glob(
-        pattern: *const c_char,
-        flags: c_int,
-        errfunc: Option<extern "C" fn(epath: *const c_char, errno: c_int) -> c_int>,
-        pglob: *mut crate::glob_t,
+    pub fn mkfifoat(dirfd: c_int, pathname: *const c_char, mode: crate::mode_t) -> c_int;
+    pub fn sync_file_range(
+        fd: c_int,
+        offset: crate::off64_t,
+        nbytes: crate::off64_t,
+        flags: c_uint,
     ) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__globfree64_time64")]
-    #[cfg_attr(
-        all(not(gnu_time_bits64), gnu_file_offset_bits64),
-        link_name = "globfree64"
-    )]
-    pub fn globfree(pglob: *mut crate::glob_t);
 
     pub fn posix_madvise(addr: *mut c_void, len: size_t, advice: c_int) -> c_int;
 
-    pub fn seekdir(dirp: *mut crate::DIR, loc: c_long);
-
-    pub fn telldir(dirp: *mut crate::DIR) -> c_long;
-    pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int) -> c_int;
-
-    pub fn msync(addr: *mut c_void, len: size_t, flags: c_int) -> c_int;
     pub fn remap_file_pages(
         addr: *mut c_void,
         size: size_t,
@@ -6326,32 +4242,17 @@ extern "C" {
         pgoff: size_t,
         flags: c_int,
     ) -> c_int;
-    pub fn recvfrom(
-        socket: c_int,
-        buf: *mut c_void,
-        len: size_t,
-        flags: c_int,
-        addr: *mut crate::sockaddr,
-        addrlen: *mut crate::socklen_t,
-    ) -> ssize_t;
     #[cfg_attr(gnu_file_offset_bits64, link_name = "mkstemps64")]
     pub fn mkstemps(template: *mut c_char, suffixlen: c_int) -> c_int;
 
-    pub fn nl_langinfo(item: crate::nl_item) -> *mut c_char;
-
     pub fn vhangup() -> c_int;
     pub fn sync();
     pub fn syncfs(fd: c_int) -> c_int;
     pub fn syscall(num: c_long, ...) -> c_long;
-    pub fn sched_getaffinity(
-        pid: crate::pid_t,
-        cpusetsize: size_t,
-        cpuset: *mut cpu_set_t,
-    ) -> c_int;
     pub fn sched_setaffinity(
         pid: crate::pid_t,
         cpusetsize: size_t,
-        cpuset: *const cpu_set_t,
+        cpuset: *const crate::cpu_set_t,
     ) -> c_int;
     pub fn epoll_create(size: c_int) -> c_int;
     pub fn epoll_create1(flags: c_int) -> c_int;
@@ -6362,17 +4263,9 @@ extern "C" {
         timeout: c_int,
     ) -> c_int;
     pub fn epoll_ctl(epfd: c_int, op: c_int, fd: c_int, event: *mut crate::epoll_event) -> c_int;
-    pub fn pthread_getschedparam(
-        native: crate::pthread_t,
-        policy: *mut c_int,
-        param: *mut crate::sched_param,
-    ) -> c_int;
     pub fn unshare(flags: c_int) -> c_int;
     pub fn umount(target: *const c_char) -> c_int;
-    pub fn sched_get_priority_max(policy: c_int) -> c_int;
     pub fn tee(fd_in: c_int, fd_out: c_int, len: size_t, flags: c_uint) -> ssize_t;
-    #[cfg_attr(gnu_time_bits64, link_name = "__settimeofday64")]
-    pub fn settimeofday(tv: *const crate::timeval, tz: *const crate::timezone) -> c_int;
     pub fn splice(
         fd_in: c_int,
         off_in: *mut crate::loff_t,
@@ -6387,65 +4280,13 @@ extern "C" {
 
     #[cfg_attr(gnu_time_bits64, link_name = "__sched_rr_get_interval64")]
     pub fn sched_rr_get_interval(pid: crate::pid_t, tp: *mut crate::timespec) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__sem_timedwait64")]
-    pub fn sem_timedwait(sem: *mut sem_t, abstime: *const crate::timespec) -> c_int;
-    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut c_int) -> c_int;
     pub fn sched_setparam(pid: crate::pid_t, param: *const crate::sched_param) -> c_int;
     pub fn setns(fd: c_int, nstype: c_int) -> c_int;
     pub fn swapoff(path: *const c_char) -> c_int;
     pub fn vmsplice(fd: c_int, iov: *const crate::iovec, nr_segs: size_t, flags: c_uint)
         -> ssize_t;
-    pub fn mount(
-        src: *const c_char,
-        target: *const c_char,
-        fstype: *const c_char,
-        flags: c_ulong,
-        data: *const c_void,
-    ) -> c_int;
     pub fn personality(persona: c_ulong) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__prctl_time64")]
-    pub fn prctl(option: c_int, ...) -> c_int;
     pub fn sched_getparam(pid: crate::pid_t, param: *mut crate::sched_param) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__ppoll64")]
-    pub fn ppoll(
-        fds: *mut crate::pollfd,
-        nfds: nfds_t,
-        timeout: *const crate::timespec,
-        sigmask: *const sigset_t,
-    ) -> c_int;
-    pub fn pthread_mutexattr_getprotocol(
-        attr: *const pthread_mutexattr_t,
-        protocol: *mut c_int,
-    ) -> c_int;
-    pub fn pthread_mutexattr_setprotocol(attr: *mut pthread_mutexattr_t, protocol: c_int) -> c_int;
-
-    #[cfg_attr(gnu_time_bits64, link_name = "__pthread_mutex_timedlock64")]
-    pub fn pthread_mutex_timedlock(
-        lock: *mut pthread_mutex_t,
-        abstime: *const crate::timespec,
-    ) -> c_int;
-    pub fn pthread_barrierattr_init(attr: *mut crate::pthread_barrierattr_t) -> c_int;
-    pub fn pthread_barrierattr_destroy(attr: *mut crate::pthread_barrierattr_t) -> c_int;
-    pub fn pthread_barrierattr_getpshared(
-        attr: *const crate::pthread_barrierattr_t,
-        shared: *mut c_int,
-    ) -> c_int;
-    pub fn pthread_barrierattr_setpshared(
-        attr: *mut crate::pthread_barrierattr_t,
-        shared: c_int,
-    ) -> c_int;
-    pub fn pthread_barrier_init(
-        barrier: *mut pthread_barrier_t,
-        attr: *const crate::pthread_barrierattr_t,
-        count: c_uint,
-    ) -> c_int;
-    pub fn pthread_barrier_destroy(barrier: *mut pthread_barrier_t) -> c_int;
-    pub fn pthread_barrier_wait(barrier: *mut pthread_barrier_t) -> c_int;
-    pub fn pthread_spin_init(lock: *mut crate::pthread_spinlock_t, pshared: c_int) -> c_int;
-    pub fn pthread_spin_destroy(lock: *mut crate::pthread_spinlock_t) -> c_int;
-    pub fn pthread_spin_lock(lock: *mut crate::pthread_spinlock_t) -> c_int;
-    pub fn pthread_spin_trylock(lock: *mut crate::pthread_spinlock_t) -> c_int;
-    pub fn pthread_spin_unlock(lock: *mut crate::pthread_spinlock_t) -> c_int;
     pub fn clone(
         cb: extern "C" fn(*mut c_void) -> c_int,
         child_stack: *mut c_void,
@@ -6461,45 +4302,7 @@ extern "C" {
         rqtp: *const crate::timespec,
         rmtp: *mut crate::timespec,
     ) -> c_int;
-    pub fn pthread_attr_getguardsize(
-        attr: *const crate::pthread_attr_t,
-        guardsize: *mut size_t,
-    ) -> c_int;
-    pub fn pthread_attr_setguardsize(attr: *mut crate::pthread_attr_t, guardsize: size_t) -> c_int;
-    pub fn pthread_attr_getinheritsched(
-        attr: *const crate::pthread_attr_t,
-        inheritsched: *mut c_int,
-    ) -> c_int;
-    pub fn pthread_attr_setinheritsched(
-        attr: *mut crate::pthread_attr_t,
-        inheritsched: c_int,
-    ) -> c_int;
-    pub fn pthread_attr_getschedpolicy(
-        attr: *const crate::pthread_attr_t,
-        policy: *mut c_int,
-    ) -> c_int;
-    pub fn pthread_attr_setschedpolicy(attr: *mut crate::pthread_attr_t, policy: c_int) -> c_int;
-    pub fn pthread_attr_getschedparam(
-        attr: *const crate::pthread_attr_t,
-        param: *mut crate::sched_param,
-    ) -> c_int;
-    pub fn pthread_attr_setschedparam(
-        attr: *mut crate::pthread_attr_t,
-        param: *const crate::sched_param,
-    ) -> c_int;
-    pub fn sethostname(name: *const c_char, len: size_t) -> c_int;
-    pub fn sched_get_priority_min(policy: c_int) -> c_int;
-    pub fn pthread_condattr_getpshared(
-        attr: *const pthread_condattr_t,
-        pshared: *mut c_int,
-    ) -> c_int;
-    pub fn sysinfo(info: *mut crate::sysinfo) -> c_int;
     pub fn umount2(target: *const c_char, flags: c_int) -> c_int;
-    pub fn pthread_setschedparam(
-        native: crate::pthread_t,
-        policy: c_int,
-        param: *const crate::sched_param,
-    ) -> c_int;
     pub fn swapon(path: *const c_char, swapflags: c_int) -> c_int;
     pub fn sched_setscheduler(
         pid: crate::pid_t,
@@ -6508,86 +4311,19 @@ extern "C" {
     ) -> c_int;
     #[cfg_attr(gnu_file_offset_bits64, link_name = "sendfile64")]
     pub fn sendfile(out_fd: c_int, in_fd: c_int, offset: *mut off_t, count: size_t) -> ssize_t;
-    pub fn sigsuspend(mask: *const crate::sigset_t) -> c_int;
-    pub fn getgrgid_r(
-        gid: crate::gid_t,
-        grp: *mut crate::group,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut crate::group,
-    ) -> c_int;
     pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> c_int;
-    pub fn sem_close(sem: *mut sem_t) -> c_int;
     pub fn getdtablesize() -> c_int;
-    pub fn getgrnam_r(
-        name: *const c_char,
-        grp: *mut crate::group,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut crate::group,
-    ) -> c_int;
-    pub fn initgroups(user: *const c_char, group: crate::gid_t) -> c_int;
-    pub fn pthread_sigmask(how: c_int, set: *const sigset_t, oldset: *mut sigset_t) -> c_int;
-    pub fn sem_open(name: *const c_char, oflag: c_int, ...) -> *mut sem_t;
-    pub fn getgrnam(name: *const c_char) -> *mut crate::group;
-    pub fn pthread_kill(thread: crate::pthread_t, sig: c_int) -> c_int;
-    pub fn sem_unlink(name: *const c_char) -> c_int;
-    pub fn daemon(nochdir: c_int, noclose: c_int) -> c_int;
-    pub fn getpwnam_r(
-        name: *const c_char,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
-    pub fn getpwuid_r(
-        uid: crate::uid_t,
-        pwd: *mut passwd,
-        buf: *mut c_char,
-        buflen: size_t,
-        result: *mut *mut passwd,
-    ) -> c_int;
-    pub fn sigwait(set: *const sigset_t, sig: *mut c_int) -> c_int;
     pub fn pthread_atfork(
         prepare: Option<unsafe extern "C" fn()>,
         parent: Option<unsafe extern "C" fn()>,
         child: Option<unsafe extern "C" fn()>,
     ) -> c_int;
-    pub fn getgrgid(gid: crate::gid_t) -> *mut crate::group;
     pub fn getgrouplist(
         user: *const c_char,
         group: crate::gid_t,
         groups: *mut crate::gid_t,
         ngroups: *mut c_int,
     ) -> c_int;
-    pub fn pthread_mutexattr_getpshared(
-        attr: *const pthread_mutexattr_t,
-        pshared: *mut c_int,
-    ) -> c_int;
-    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut crate::FILE;
-    pub fn faccessat(dirfd: c_int, pathname: *const c_char, mode: c_int, flags: c_int) -> c_int;
-    pub fn pthread_create(
-        native: *mut crate::pthread_t,
-        attr: *const crate::pthread_attr_t,
-        f: extern "C" fn(*mut c_void) -> *mut c_void,
-        value: *mut c_void,
-    ) -> c_int;
-    pub fn dl_iterate_phdr(
-        callback: Option<
-            unsafe extern "C" fn(
-                info: *mut crate::dl_phdr_info,
-                size: size_t,
-                data: *mut c_void,
-            ) -> c_int,
-        >,
-        data: *mut c_void,
-    ) -> c_int;
-
-    pub fn setmntent(filename: *const c_char, ty: *const c_char) -> *mut crate::FILE;
-    pub fn getmntent(stream: *mut crate::FILE) -> *mut crate::mntent;
-    pub fn addmntent(stream: *mut crate::FILE, mnt: *const crate::mntent) -> c_int;
-    pub fn endmntent(streamp: *mut crate::FILE) -> c_int;
-    pub fn hasmntopt(mnt: *const crate::mntent, opt: *const c_char) -> *mut c_char;
 
     pub fn posix_spawn(
         pid: *mut crate::pid_t,
@@ -6651,7 +4387,7 @@ extern "C" {
         fd: c_int,
         path: *const c_char,
         oflag: c_int,
-        mode: mode_t,
+        mode: crate::mode_t,
     ) -> c_int;
     pub fn posix_spawn_file_actions_addclose(
         actions: *mut posix_spawn_file_actions_t,
@@ -6674,85 +4410,12 @@ extern "C" {
     pub fn inotify_add_watch(fd: c_int, path: *const c_char, mask: u32) -> c_int;
     pub fn fanotify_init(flags: c_uint, event_f_flags: c_uint) -> c_int;
 
-    pub fn regcomp(preg: *mut crate::regex_t, pattern: *const c_char, cflags: c_int) -> c_int;
-
-    pub fn regexec(
-        preg: *const crate::regex_t,
-        input: *const c_char,
-        nmatch: size_t,
-        pmatch: *mut regmatch_t,
-        eflags: c_int,
-    ) -> c_int;
-
-    pub fn regerror(
-        errcode: c_int,
-        preg: *const crate::regex_t,
-        errbuf: *mut c_char,
-        errbuf_size: size_t,
-    ) -> size_t;
-
-    pub fn regfree(preg: *mut crate::regex_t);
-
-    pub fn iconv_open(tocode: *const c_char, fromcode: *const c_char) -> iconv_t;
-    pub fn iconv(
-        cd: iconv_t,
-        inbuf: *mut *mut c_char,
-        inbytesleft: *mut size_t,
-        outbuf: *mut *mut c_char,
-        outbytesleft: *mut size_t,
-    ) -> size_t;
-    pub fn iconv_close(cd: iconv_t) -> c_int;
-
-    pub fn gettid() -> crate::pid_t;
-
-    pub fn timer_create(
-        clockid: crate::clockid_t,
-        sevp: *mut crate::sigevent,
-        timerid: *mut crate::timer_t,
-    ) -> c_int;
-    pub fn timer_delete(timerid: crate::timer_t) -> c_int;
-    pub fn timer_getoverrun(timerid: crate::timer_t) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__timer_gettime64")]
-    pub fn timer_gettime(timerid: crate::timer_t, curr_value: *mut crate::itimerspec) -> c_int;
-    #[cfg_attr(gnu_time_bits64, link_name = "__timer_settime64")]
-    pub fn timer_settime(
-        timerid: crate::timer_t,
-        flags: c_int,
-        new_value: *const crate::itimerspec,
-        old_value: *mut crate::itimerspec,
-    ) -> c_int;
-
     pub fn gethostid() -> c_long;
 
     pub fn pthread_getcpuclockid(thread: crate::pthread_t, clk_id: *mut crate::clockid_t) -> c_int;
-    pub fn memmem(
-        haystack: *const c_void,
-        haystacklen: size_t,
-        needle: *const c_void,
-        needlelen: size_t,
-    ) -> *mut c_void;
-    pub fn sched_getcpu() -> c_int;
 
     pub fn pthread_getname_np(thread: crate::pthread_t, name: *mut c_char, len: size_t) -> c_int;
     pub fn pthread_setname_np(thread: crate::pthread_t, name: *const c_char) -> c_int;
-    pub fn getopt_long(
-        argc: c_int,
-        argv: *const *mut c_char,
-        optstring: *const c_char,
-        longopts: *const option,
-        longindex: *mut c_int,
-    ) -> c_int;
-
-    pub fn pthread_once(control: *mut pthread_once_t, routine: extern "C" fn()) -> c_int;
-
-    pub fn copy_file_range(
-        fd_in: c_int,
-        off_in: *mut off64_t,
-        fd_out: c_int,
-        off_out: *mut off64_t,
-        len: size_t,
-        flags: c_uint,
-    ) -> ssize_t;
 
     pub fn klogctl(syslog_type: c_int, bufp: *mut c_char, len: c_int) -> c_int;
 }
@@ -6763,22 +4426,23 @@ extern "C" {
 cfg_if! {
     if #[cfg(not(target_env = "musl"))] {
         extern "C" {
-            pub fn fallocate64(fd: c_int, mode: c_int, offset: off64_t, len: off64_t) -> c_int;
-            pub fn fgetpos64(stream: *mut crate::FILE, ptr: *mut fpos64_t) -> c_int;
+            pub fn fallocate64(
+                fd: c_int,
+                mode: c_int,
+                offset: crate::off64_t,
+                len: crate::off64_t,
+            ) -> c_int;
+            pub fn fgetpos64(stream: *mut crate::FILE, ptr: *mut crate::fpos64_t) -> c_int;
             pub fn fopen64(filename: *const c_char, mode: *const c_char) -> *mut crate::FILE;
-            pub fn freopen64(
-                filename: *const c_char,
-                mode: *const c_char,
-                file: *mut crate::FILE,
-            ) -> *mut crate::FILE;
-            pub fn fseeko64(stream: *mut crate::FILE, offset: off64_t, whence: c_int) -> c_int;
-            pub fn fsetpos64(stream: *mut crate::FILE, ptr: *const fpos64_t) -> c_int;
-            pub fn ftello64(stream: *mut crate::FILE) -> off64_t;
-            pub fn posix_fallocate64(fd: c_int, offset: off64_t, len: off64_t) -> c_int;
+            pub fn posix_fallocate64(
+                fd: c_int,
+                offset: crate::off64_t,
+                len: crate::off64_t,
+            ) -> c_int;
             pub fn sendfile64(
                 out_fd: c_int,
                 in_fd: c_int,
-                offset: *mut off64_t,
+                offset: *mut crate::off64_t,
                 count: size_t,
             ) -> ssize_t;
             pub fn tmpfile64() -> *mut crate::FILE;
diff --git a/src/unix/linux_like/linux/musl/mod.rs b/src/unix/linux_like/linux/musl/mod.rs
index 80d8003e2..cff99d6aa 100644
--- a/src/unix/linux_like/linux/musl/mod.rs
+++ b/src/unix/linux_like/linux/musl/mod.rs
@@ -663,8 +663,6 @@ pub const O_NDELAY: c_int = O_NONBLOCK;
 pub const NI_MAXHOST: crate::socklen_t = 255;
 pub const PTHREAD_STACK_MIN: size_t = 2048;
 
-pub const POSIX_MADV_DONTNEED: c_int = 4;
-
 pub const MAP_ANONYMOUS: c_int = MAP_ANON;
 
 pub const SOCK_SEQPACKET: c_int = 5;
diff --git a/src/unix/linux_like/linux/uclibc/x86_64/mod.rs b/src/unix/linux_like/linux/uclibc/x86_64/mod.rs
index 9b422433d..87200ce39 100644
--- a/src/unix/linux_like/linux/uclibc/x86_64/mod.rs
+++ b/src/unix/linux_like/linux/uclibc/x86_64/mod.rs
@@ -17,6 +17,7 @@ pub type stat64 = stat;
 pub type suseconds_t = c_long;
 pub type time_t = c_int;
 pub type wchar_t = c_int;
+pub type pthread_t = c_ulong;
 
 pub type fsblkcnt64_t = u64;
 pub type fsfilcnt64_t = u64;
@@ -38,7 +39,6 @@ s! {
         __unused2: c_ulong,
     }
 
-    #[cfg(not(target_os = "l4re"))]
     pub struct pthread_attr_t {
         __detachstate: c_int,
         __schedpolicy: c_int,
@@ -331,13 +331,4 @@ pub const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56;
 pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: usize = 8;
 pub const __SIZEOF_PTHREAD_BARRIER_T: usize = 32;
 pub const __SIZEOF_PTHREAD_BARRIERATTR_T: usize = 4;
-
-cfg_if! {
-    if #[cfg(target_os = "l4re")] {
-        mod l4re;
-        pub use self::l4re::*;
-    } else {
-        mod other;
-        pub use other::*;
-    }
-}
+pub const PTHREAD_STACK_MIN: usize = 16384;
diff --git a/src/unix/linux_like/linux/uclibc/x86_64/other.rs b/src/unix/linux_like/linux/uclibc/x86_64/other.rs
deleted file mode 100644
index dc16d02c8..000000000
--- a/src/unix/linux_like/linux/uclibc/x86_64/other.rs
+++ /dev/null
@@ -1,7 +0,0 @@
-use crate::prelude::*;
-
-// Thestyle checker discourages the use of #[cfg], so this has to go into a
-// separate module
-pub type pthread_t = c_ulong;
-
-pub const PTHREAD_STACK_MIN: usize = 16384;
diff --git a/src/unix/linux_like/linux_l4re_shared.rs b/src/unix/linux_like/linux_l4re_shared.rs
new file mode 100644
index 000000000..629b1b517
--- /dev/null
+++ b/src/unix/linux_like/linux_l4re_shared.rs
@@ -0,0 +1,2104 @@
+//! Shared definitions between Linux and L4Re
+
+// FIXME(linux): check if there is more overlap with emscripten and android
+
+use crate::prelude::*;
+
+pub type dev_t = u64;
+pub type socklen_t = u32;
+pub type mode_t = u32;
+pub type ino64_t = u64;
+pub type off64_t = i64;
+pub type blkcnt64_t = i64;
+pub type rlim64_t = u64;
+pub type nfds_t = c_ulong;
+pub type nl_item = c_int;
+pub type idtype_t = c_uint;
+pub type loff_t = c_longlong;
+pub type pthread_key_t = c_uint;
+pub type pthread_once_t = c_int;
+pub type pthread_spinlock_t = c_int;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+pub type Elf32_Xword = u64;
+pub type Elf32_Sword = i32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+pub type Elf64_Sxword = i64;
+pub type Elf64_Sword = i32;
+
+pub type Elf32_Section = u16;
+pub type Elf64_Section = u16;
+
+pub type Elf32_Relr = Elf32_Word;
+pub type Elf64_Relr = Elf32_Xword;
+pub type Elf32_Rel = __c_anonymous_elf32_rel;
+pub type Elf64_Rel = __c_anonymous_elf64_rel;
+
+cfg_if! {
+    if #[cfg(not(target_arch = "sparc64"))] {
+        pub type Elf32_Rela = __c_anonymous_elf32_rela;
+        pub type Elf64_Rela = __c_anonymous_elf64_rela;
+    }
+}
+
+pub type iconv_t = *mut c_void;
+
+cfg_if! {
+    if #[cfg(not(target_env = "gnu"))] {
+        missing! {
+            #[derive(Debug)]
+            pub enum fpos64_t {} // FIXME(linux): fill this out with a struct
+        }
+    }
+}
+
+s! {
+    pub struct glob_t {
+        pub gl_pathc: size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: size_t,
+        pub gl_flags: c_int,
+
+        __unused1: *mut c_void,
+        __unused2: *mut c_void,
+        __unused3: *mut c_void,
+        __unused4: *mut c_void,
+        __unused5: *mut c_void,
+    }
+
+    pub struct passwd {
+        pub pw_name: *mut c_char,
+        pub pw_passwd: *mut c_char,
+        pub pw_uid: crate::uid_t,
+        pub pw_gid: crate::gid_t,
+        pub pw_gecos: *mut c_char,
+        pub pw_dir: *mut c_char,
+        pub pw_shell: *mut c_char,
+    }
+
+    pub struct spwd {
+        pub sp_namp: *mut c_char,
+        pub sp_pwdp: *mut c_char,
+        pub sp_lstchg: c_long,
+        pub sp_min: c_long,
+        pub sp_max: c_long,
+        pub sp_warn: c_long,
+        pub sp_inact: c_long,
+        pub sp_expire: c_long,
+        pub sp_flag: c_ulong,
+    }
+
+    pub struct itimerspec {
+        pub it_interval: crate::timespec,
+        pub it_value: crate::timespec,
+    }
+
+    pub struct fsid_t {
+        __val: [c_int; 2],
+    }
+
+    pub struct packet_mreq {
+        pub mr_ifindex: c_int,
+        pub mr_type: c_ushort,
+        pub mr_alen: c_ushort,
+        pub mr_address: [c_uchar; 8],
+    }
+
+    pub struct cpu_set_t {
+        #[cfg(all(target_pointer_width = "32", not(target_arch = "x86_64")))]
+        bits: [u32; 32],
+        #[cfg(not(all(target_pointer_width = "32", not(target_arch = "x86_64"))))]
+        bits: [u64; 16],
+    }
+
+    pub struct sembuf {
+        pub sem_num: c_ushort,
+        pub sem_op: c_short,
+        pub sem_flg: c_short,
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        // As of uClibc 1.0.36, the following fields are
+        // gated behind a "#if 0" block which always evaluates
+        // to false. So I'm just removing these, and if uClibc changes
+        // the #if block in the future to include the following fields, these
+        // will probably need including here. tsidea, skrap
+        // QNX (NTO) platform does not define these fields
+        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
+        pub dlpi_adds: c_ulonglong,
+        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
+        pub dlpi_subs: c_ulonglong,
+        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
+        pub dlpi_tls_modid: size_t,
+        #[cfg(not(any(target_env = "uclibc", target_os = "nto")))]
+        pub dlpi_tls_data: *mut c_void,
+    }
+
+    pub struct Elf32_Ehdr {
+        pub e_ident: [c_uchar; 16],
+        pub e_type: Elf32_Half,
+        pub e_machine: Elf32_Half,
+        pub e_version: Elf32_Word,
+        pub e_entry: Elf32_Addr,
+        pub e_phoff: Elf32_Off,
+        pub e_shoff: Elf32_Off,
+        pub e_flags: Elf32_Word,
+        pub e_ehsize: Elf32_Half,
+        pub e_phentsize: Elf32_Half,
+        pub e_phnum: Elf32_Half,
+        pub e_shentsize: Elf32_Half,
+        pub e_shnum: Elf32_Half,
+        pub e_shstrndx: Elf32_Half,
+    }
+
+    pub struct Elf64_Ehdr {
+        pub e_ident: [c_uchar; 16],
+        pub e_type: Elf64_Half,
+        pub e_machine: Elf64_Half,
+        pub e_version: Elf64_Word,
+        pub e_entry: Elf64_Addr,
+        pub e_phoff: Elf64_Off,
+        pub e_shoff: Elf64_Off,
+        pub e_flags: Elf64_Word,
+        pub e_ehsize: Elf64_Half,
+        pub e_phentsize: Elf64_Half,
+        pub e_phnum: Elf64_Half,
+        pub e_shentsize: Elf64_Half,
+        pub e_shnum: Elf64_Half,
+        pub e_shstrndx: Elf64_Half,
+    }
+
+    pub struct Elf32_Sym {
+        pub st_name: Elf32_Word,
+        pub st_value: Elf32_Addr,
+        pub st_size: Elf32_Word,
+        pub st_info: c_uchar,
+        pub st_other: c_uchar,
+        pub st_shndx: Elf32_Section,
+    }
+
+    pub struct Elf64_Sym {
+        pub st_name: Elf64_Word,
+        pub st_info: c_uchar,
+        pub st_other: c_uchar,
+        pub st_shndx: Elf64_Section,
+        pub st_value: Elf64_Addr,
+        pub st_size: Elf64_Xword,
+    }
+
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct Elf32_Shdr {
+        pub sh_name: Elf32_Word,
+        pub sh_type: Elf32_Word,
+        pub sh_flags: Elf32_Word,
+        pub sh_addr: Elf32_Addr,
+        pub sh_offset: Elf32_Off,
+        pub sh_size: Elf32_Word,
+        pub sh_link: Elf32_Word,
+        pub sh_info: Elf32_Word,
+        pub sh_addralign: Elf32_Word,
+        pub sh_entsize: Elf32_Word,
+    }
+
+    pub struct Elf64_Shdr {
+        pub sh_name: Elf64_Word,
+        pub sh_type: Elf64_Word,
+        pub sh_flags: Elf64_Xword,
+        pub sh_addr: Elf64_Addr,
+        pub sh_offset: Elf64_Off,
+        pub sh_size: Elf64_Xword,
+        pub sh_link: Elf64_Word,
+        pub sh_info: Elf64_Word,
+        pub sh_addralign: Elf64_Xword,
+        pub sh_entsize: Elf64_Xword,
+    }
+
+    pub struct __c_anonymous_elf32_rel {
+        pub r_offset: Elf32_Addr,
+        pub r_info: Elf32_Word,
+    }
+
+    pub struct __c_anonymous_elf64_rel {
+        pub r_offset: Elf64_Addr,
+        pub r_info: Elf64_Xword,
+    }
+
+    pub struct ucred {
+        pub pid: crate::pid_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+    }
+
+    pub struct mntent {
+        pub mnt_fsname: *mut c_char,
+        pub mnt_dir: *mut c_char,
+        pub mnt_type: *mut c_char,
+        pub mnt_opts: *mut c_char,
+        pub mnt_freq: c_int,
+        pub mnt_passno: c_int,
+    }
+
+    pub struct in6_pktinfo {
+        pub ipi6_addr: crate::in6_addr,
+        pub ipi6_ifindex: c_uint,
+    }
+
+    pub struct arpd_request {
+        pub req: c_ushort,
+        pub ip: u32,
+        pub dev: c_ulong,
+        pub stamp: c_ulong,
+        pub updated: c_ulong,
+        pub ha: [c_uchar; crate::MAX_ADDR_LEN],
+    }
+
+    pub struct regmatch_t {
+        pub rm_so: crate::regoff_t,
+        pub rm_eo: crate::regoff_t,
+    }
+
+    pub struct option {
+        pub name: *const c_char,
+        pub has_arg: c_int,
+        pub flag: *mut c_int,
+        pub val: c_int,
+    }
+
+    pub struct rlimit64 {
+        pub rlim_cur: rlim64_t,
+        pub rlim_max: rlim64_t,
+    }
+
+    pub struct __c_anonymous_ifru_map {
+        pub mem_start: c_ulong,
+        pub mem_end: c_ulong,
+        pub base_addr: c_ushort,
+        pub irq: c_uchar,
+        pub dma: c_uchar,
+        pub port: c_uchar,
+    }
+}
+
+cfg_if! {
+    if #[cfg(not(target_arch = "sparc64"))] {
+        s! {
+            pub struct __c_anonymous_elf32_rela {
+                pub r_offset: crate::Elf32_Addr,
+                pub r_info: crate::Elf32_Word,
+                pub r_addend: crate::Elf32_Sword,
+            }
+
+            pub struct __c_anonymous_elf64_rela {
+                pub r_offset: crate::Elf64_Addr,
+                pub r_info: crate::Elf64_Xword,
+                pub r_addend: crate::Elf64_Sxword,
+            }
+        }
+    }
+}
+
+s_no_extra_traits! {
+    pub struct dirent {
+        pub d_ino: crate::ino_t,
+        pub d_off: crate::off_t,
+        pub d_reclen: c_ushort,
+        pub d_type: c_uchar,
+        pub d_name: [c_char; 256],
+    }
+
+    pub struct dirent64 {
+        pub d_ino: crate::ino64_t,
+        pub d_off: crate::off64_t,
+        pub d_reclen: c_ushort,
+        pub d_type: c_uchar,
+        pub d_name: [c_char; 256],
+    }
+
+    pub union __c_anonymous_ifr_ifru {
+        pub ifru_addr: crate::sockaddr,
+        pub ifru_dstaddr: crate::sockaddr,
+        pub ifru_broadaddr: crate::sockaddr,
+        pub ifru_netmask: crate::sockaddr,
+        pub ifru_hwaddr: crate::sockaddr,
+        pub ifru_flags: c_short,
+        pub ifru_ifindex: c_int,
+        pub ifru_metric: c_int,
+        pub ifru_mtu: c_int,
+        pub ifru_map: crate::__c_anonymous_ifru_map,
+        pub ifru_slave: [c_char; crate::IFNAMSIZ],
+        pub ifru_newname: [c_char; crate::IFNAMSIZ],
+        pub ifru_data: *mut c_char,
+    }
+
+    pub struct ifreq {
+        /// interface name, e.g. "en0"
+        pub ifr_name: [c_char; crate::IFNAMSIZ],
+        pub ifr_ifru: __c_anonymous_ifr_ifru,
+    }
+
+    pub union __c_anonymous_ifc_ifcu {
+        pub ifcu_buf: *mut c_char,
+        pub ifcu_req: *mut crate::ifreq,
+    }
+
+    /// Structure used in SIOCGIFCONF request.  Used to retrieve interface configuration for
+    /// machine (useful for programs which must know all networks accessible).
+    pub struct ifconf {
+        /// Size of buffer
+        pub ifc_len: c_int,
+        pub ifc_ifcu: __c_anonymous_ifc_ifcu,
+    }
+}
+
+#[cfg(not(target_env = "uclibc"))]
+const base: crate::nl_item = 0x20000;
+#[cfg(target_env = "uclibc")]
+const base: crate::nl_item = 768;
+
+pub const ABDAY_1: crate::nl_item = base;
+pub const ABDAY_2: crate::nl_item = base + 0x1;
+pub const ABDAY_3: crate::nl_item = base + 0x2;
+pub const ABDAY_4: crate::nl_item = base + 0x3;
+pub const ABDAY_5: crate::nl_item = base + 0x4;
+pub const ABDAY_6: crate::nl_item = base + 0x5;
+pub const ABDAY_7: crate::nl_item = base + 0x6;
+
+pub const DAY_1: crate::nl_item = base + 0x7;
+pub const DAY_2: crate::nl_item = base + 0x8;
+pub const DAY_3: crate::nl_item = base + 0x9;
+pub const DAY_4: crate::nl_item = base + 0xA;
+pub const DAY_5: crate::nl_item = base + 0xB;
+pub const DAY_6: crate::nl_item = base + 0xC;
+pub const DAY_7: crate::nl_item = base + 0xD;
+
+pub const ABMON_1: crate::nl_item = base + 0xE;
+pub const ABMON_2: crate::nl_item = base + 0xF;
+pub const ABMON_3: crate::nl_item = base + 0x10;
+pub const ABMON_4: crate::nl_item = base + 0x11;
+pub const ABMON_5: crate::nl_item = base + 0x12;
+pub const ABMON_6: crate::nl_item = base + 0x13;
+pub const ABMON_7: crate::nl_item = base + 0x14;
+pub const ABMON_8: crate::nl_item = base + 0x15;
+pub const ABMON_9: crate::nl_item = base + 0x16;
+pub const ABMON_10: crate::nl_item = base + 0x17;
+pub const ABMON_11: crate::nl_item = base + 0x18;
+pub const ABMON_12: crate::nl_item = base + 0x19;
+
+pub const MON_1: crate::nl_item = base + 0x1A;
+pub const MON_2: crate::nl_item = base + 0x1B;
+pub const MON_3: crate::nl_item = base + 0x1C;
+pub const MON_4: crate::nl_item = base + 0x1D;
+pub const MON_5: crate::nl_item = base + 0x1E;
+pub const MON_6: crate::nl_item = base + 0x1F;
+pub const MON_7: crate::nl_item = base + 0x20;
+pub const MON_8: crate::nl_item = base + 0x21;
+pub const MON_9: crate::nl_item = base + 0x22;
+pub const MON_10: crate::nl_item = base + 0x23;
+pub const MON_11: crate::nl_item = base + 0x24;
+pub const MON_12: crate::nl_item = base + 0x25;
+
+pub const AM_STR: crate::nl_item = base + 0x26;
+pub const PM_STR: crate::nl_item = base + 0x27;
+
+pub const D_T_FMT: crate::nl_item = base + 0x28;
+pub const D_FMT: crate::nl_item = base + 0x29;
+pub const T_FMT: crate::nl_item = base + 0x2A;
+pub const T_FMT_AMPM: crate::nl_item = base + 0x2B;
+
+pub const ERA: crate::nl_item = base + 0x2C;
+pub const ERA_D_FMT: crate::nl_item = base + 0x2E;
+pub const ALT_DIGITS: crate::nl_item = base + 0x2F;
+pub const ERA_D_T_FMT: crate::nl_item = base + 0x30;
+pub const ERA_T_FMT: crate::nl_item = base + 0x31;
+
+cfg_if! {
+    if #[cfg(any(
+        target_env = "gnu",
+        target_env = "musl",
+        target_env = "ohos"
+    ))] {
+        pub const CODESET: crate::nl_item = 14;
+        pub const CRNCYSTR: crate::nl_item = 0x4000F;
+        pub const RADIXCHAR: crate::nl_item = 0x10000;
+        pub const THOUSEP: crate::nl_item = 0x10001;
+        pub const YESEXPR: crate::nl_item = 0x50000;
+        pub const NOEXPR: crate::nl_item = 0x50001;
+        pub const YESSTR: crate::nl_item = 0x50002;
+        pub const NOSTR: crate::nl_item = 0x50003;
+    } else if #[cfg(target_env = "uclibc")] {
+        pub const CODESET: crate::nl_item = 10;
+        pub const CRNCYSTR: crate::nl_item = 0x215;
+        pub const RADIXCHAR: crate::nl_item = 0x100;
+        pub const THOUSEP: crate::nl_item = 0x101;
+        pub const YESEXPR: crate::nl_item = 0x500;
+        pub const NOEXPR: crate::nl_item = 0x501;
+        pub const YESSTR: crate::nl_item = 0x502;
+        pub const NOSTR: crate::nl_item = 0x503;
+    }
+}
+
+pub const RUSAGE_CHILDREN: c_int = -1;
+
+pub const L_tmpnam: c_uint = 20;
+pub const _PC_LINK_MAX: c_int = 0;
+pub const _PC_MAX_CANON: c_int = 1;
+pub const _PC_MAX_INPUT: c_int = 2;
+pub const _PC_NAME_MAX: c_int = 3;
+pub const _PC_PATH_MAX: c_int = 4;
+pub const _PC_PIPE_BUF: c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: c_int = 6;
+pub const _PC_NO_TRUNC: c_int = 7;
+pub const _PC_VDISABLE: c_int = 8;
+pub const _PC_SYNC_IO: c_int = 9;
+pub const _PC_ASYNC_IO: c_int = 10;
+pub const _PC_PRIO_IO: c_int = 11;
+pub const _PC_SOCK_MAXBUF: c_int = 12;
+pub const _PC_FILESIZEBITS: c_int = 13;
+pub const _PC_REC_INCR_XFER_SIZE: c_int = 14;
+pub const _PC_REC_MAX_XFER_SIZE: c_int = 15;
+pub const _PC_REC_MIN_XFER_SIZE: c_int = 16;
+pub const _PC_REC_XFER_ALIGN: c_int = 17;
+pub const _PC_ALLOC_SIZE_MIN: c_int = 18;
+pub const _PC_SYMLINK_MAX: c_int = 19;
+pub const _PC_2_SYMLINKS: c_int = 20;
+
+pub const _SC_ARG_MAX: c_int = 0;
+pub const _SC_CHILD_MAX: c_int = 1;
+pub const _SC_CLK_TCK: c_int = 2;
+pub const _SC_NGROUPS_MAX: c_int = 3;
+pub const _SC_OPEN_MAX: c_int = 4;
+pub const _SC_STREAM_MAX: c_int = 5;
+pub const _SC_TZNAME_MAX: c_int = 6;
+pub const _SC_JOB_CONTROL: c_int = 7;
+pub const _SC_SAVED_IDS: c_int = 8;
+pub const _SC_REALTIME_SIGNALS: c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
+pub const _SC_TIMERS: c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
+pub const _SC_PRIORITIZED_IO: c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: c_int = 14;
+pub const _SC_FSYNC: c_int = 15;
+pub const _SC_MAPPED_FILES: c_int = 16;
+pub const _SC_MEMLOCK: c_int = 17;
+pub const _SC_MEMLOCK_RANGE: c_int = 18;
+pub const _SC_MEMORY_PROTECTION: c_int = 19;
+pub const _SC_MESSAGE_PASSING: c_int = 20;
+pub const _SC_SEMAPHORES: c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: c_int = 23;
+pub const _SC_AIO_MAX: c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
+pub const _SC_DELAYTIMER_MAX: c_int = 26;
+pub const _SC_MQ_OPEN_MAX: c_int = 27;
+pub const _SC_MQ_PRIO_MAX: c_int = 28;
+pub const _SC_VERSION: c_int = 29;
+pub const _SC_PAGESIZE: c_int = 30;
+pub const _SC_PAGE_SIZE: c_int = _SC_PAGESIZE;
+pub const _SC_RTSIG_MAX: c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: c_int = 32;
+pub const _SC_SEM_VALUE_MAX: c_int = 33;
+pub const _SC_SIGQUEUE_MAX: c_int = 34;
+pub const _SC_TIMER_MAX: c_int = 35;
+pub const _SC_BC_BASE_MAX: c_int = 36;
+pub const _SC_BC_DIM_MAX: c_int = 37;
+pub const _SC_BC_SCALE_MAX: c_int = 38;
+pub const _SC_BC_STRING_MAX: c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
+pub const _SC_EXPR_NEST_MAX: c_int = 42;
+pub const _SC_LINE_MAX: c_int = 43;
+pub const _SC_RE_DUP_MAX: c_int = 44;
+pub const _SC_2_VERSION: c_int = 46;
+pub const _SC_2_C_BIND: c_int = 47;
+pub const _SC_2_C_DEV: c_int = 48;
+pub const _SC_2_FORT_DEV: c_int = 49;
+pub const _SC_2_FORT_RUN: c_int = 50;
+pub const _SC_2_SW_DEV: c_int = 51;
+pub const _SC_2_LOCALEDEF: c_int = 52;
+pub const _SC_UIO_MAXIOV: c_int = 60;
+pub const _SC_IOV_MAX: c_int = 60;
+pub const _SC_THREADS: c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: c_int = 71;
+pub const _SC_TTY_NAME_MAX: c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: c_int = 74;
+pub const _SC_THREAD_STACK_MIN: c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
+pub const _SC_NPROCESSORS_CONF: c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: c_int = 84;
+pub const _SC_PHYS_PAGES: c_int = 85;
+pub const _SC_AVPHYS_PAGES: c_int = 86;
+pub const _SC_ATEXIT_MAX: c_int = 87;
+pub const _SC_PASS_MAX: c_int = 88;
+pub const _SC_XOPEN_VERSION: c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
+pub const _SC_XOPEN_UNIX: c_int = 91;
+pub const _SC_XOPEN_CRYPT: c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: c_int = 93;
+pub const _SC_XOPEN_SHM: c_int = 94;
+pub const _SC_2_CHAR_TERM: c_int = 95;
+pub const _SC_2_UPE: c_int = 97;
+pub const _SC_XOPEN_XPG2: c_int = 98;
+pub const _SC_XOPEN_XPG3: c_int = 99;
+pub const _SC_XOPEN_XPG4: c_int = 100;
+pub const _SC_NZERO: c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
+pub const _SC_XOPEN_LEGACY: c_int = 129;
+pub const _SC_XOPEN_REALTIME: c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
+pub const _SC_ADVISORY_INFO: c_int = 132;
+pub const _SC_BARRIERS: c_int = 133;
+pub const _SC_CLOCK_SELECTION: c_int = 137;
+pub const _SC_CPUTIME: c_int = 138;
+pub const _SC_THREAD_CPUTIME: c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: c_int = 153;
+pub const _SC_SPIN_LOCKS: c_int = 154;
+pub const _SC_REGEXP: c_int = 155;
+pub const _SC_SHELL: c_int = 157;
+pub const _SC_SPAWN: c_int = 159;
+pub const _SC_SPORADIC_SERVER: c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
+pub const _SC_TIMEOUTS: c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
+pub const _SC_2_PBS: c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
+pub const _SC_2_PBS_LOCATE: c_int = 170;
+pub const _SC_2_PBS_MESSAGE: c_int = 171;
+pub const _SC_2_PBS_TRACK: c_int = 172;
+pub const _SC_SYMLOOP_MAX: c_int = 173;
+pub const _SC_STREAMS: c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
+pub const _SC_V6_ILP32_OFF32: c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
+pub const _SC_V6_LP64_OFF64: c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
+pub const _SC_HOST_NAME_MAX: c_int = 180;
+pub const _SC_TRACE: c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
+pub const _SC_TRACE_INHERIT: c_int = 183;
+pub const _SC_TRACE_LOG: c_int = 184;
+pub const _SC_IPV6: c_int = 235;
+pub const _SC_RAW_SOCKETS: c_int = 236;
+pub const _SC_V7_ILP32_OFF32: c_int = 237;
+pub const _SC_V7_ILP32_OFFBIG: c_int = 238;
+pub const _SC_V7_LP64_OFF64: c_int = 239;
+pub const _SC_V7_LPBIG_OFFBIG: c_int = 240;
+pub const _SC_SS_REPL_MAX: c_int = 241;
+pub const _SC_TRACE_EVENT_NAME_MAX: c_int = 242;
+pub const _SC_TRACE_NAME_MAX: c_int = 243;
+pub const _SC_TRACE_SYS_MAX: c_int = 244;
+pub const _SC_TRACE_USER_EVENT_MAX: c_int = 245;
+pub const _SC_XOPEN_STREAMS: c_int = 246;
+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: c_int = 247;
+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: c_int = 248;
+
+pub const _CS_PATH: c_int = 0;
+pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
+pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
+pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
+pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
+pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
+pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
+pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
+pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
+pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
+pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
+pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
+pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
+pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
+pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
+pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
+pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
+pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
+pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
+pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
+
+pub const RLIM_SAVED_MAX: crate::rlim_t = crate::RLIM_INFINITY;
+pub const RLIM_SAVED_CUR: crate::rlim_t = crate::RLIM_INFINITY;
+
+// elf.h - Fields in the e_ident array.
+pub const EI_NIDENT: usize = 16;
+
+pub const EI_MAG0: usize = 0;
+pub const ELFMAG0: u8 = 0x7f;
+pub const EI_MAG1: usize = 1;
+pub const ELFMAG1: u8 = b'E';
+pub const EI_MAG2: usize = 2;
+pub const ELFMAG2: u8 = b'L';
+pub const EI_MAG3: usize = 3;
+pub const ELFMAG3: u8 = b'F';
+pub const SELFMAG: usize = 4;
+
+pub const EI_CLASS: usize = 4;
+pub const ELFCLASSNONE: u8 = 0;
+pub const ELFCLASS32: u8 = 1;
+pub const ELFCLASS64: u8 = 2;
+pub const ELFCLASSNUM: usize = 3;
+
+pub const EI_DATA: usize = 5;
+pub const ELFDATANONE: u8 = 0;
+pub const ELFDATA2LSB: u8 = 1;
+pub const ELFDATA2MSB: u8 = 2;
+pub const ELFDATANUM: usize = 3;
+
+pub const EI_VERSION: usize = 6;
+
+pub const EI_OSABI: usize = 7;
+pub const ELFOSABI_NONE: u8 = 0;
+pub const ELFOSABI_SYSV: u8 = 0;
+pub const ELFOSABI_HPUX: u8 = 1;
+pub const ELFOSABI_NETBSD: u8 = 2;
+pub const ELFOSABI_GNU: u8 = 3;
+pub const ELFOSABI_LINUX: u8 = ELFOSABI_GNU;
+pub const ELFOSABI_SOLARIS: u8 = 6;
+pub const ELFOSABI_AIX: u8 = 7;
+pub const ELFOSABI_IRIX: u8 = 8;
+pub const ELFOSABI_FREEBSD: u8 = 9;
+pub const ELFOSABI_TRU64: u8 = 10;
+pub const ELFOSABI_MODESTO: u8 = 11;
+pub const ELFOSABI_OPENBSD: u8 = 12;
+pub const ELFOSABI_ARM: u8 = 97;
+pub const ELFOSABI_STANDALONE: u8 = 255;
+
+pub const EI_ABIVERSION: usize = 8;
+
+pub const EI_PAD: usize = 9;
+
+// elf.h - Legal values for e_type (object file type).
+pub const ET_NONE: u16 = 0;
+pub const ET_REL: u16 = 1;
+pub const ET_EXEC: u16 = 2;
+pub const ET_DYN: u16 = 3;
+pub const ET_CORE: u16 = 4;
+pub const ET_NUM: u16 = 5;
+pub const ET_LOOS: u16 = 0xfe00;
+pub const ET_HIOS: u16 = 0xfeff;
+pub const ET_LOPROC: u16 = 0xff00;
+pub const ET_HIPROC: u16 = 0xffff;
+
+// elf.h - Legal values for e_machine (architecture).
+pub const EM_NONE: u16 = 0;
+pub const EM_M32: u16 = 1;
+pub const EM_SPARC: u16 = 2;
+pub const EM_386: u16 = 3;
+pub const EM_68K: u16 = 4;
+pub const EM_88K: u16 = 5;
+pub const EM_860: u16 = 7;
+pub const EM_MIPS: u16 = 8;
+pub const EM_S370: u16 = 9;
+pub const EM_MIPS_RS3_LE: u16 = 10;
+pub const EM_PARISC: u16 = 15;
+pub const EM_VPP500: u16 = 17;
+pub const EM_SPARC32PLUS: u16 = 18;
+pub const EM_960: u16 = 19;
+pub const EM_PPC: u16 = 20;
+pub const EM_PPC64: u16 = 21;
+pub const EM_S390: u16 = 22;
+pub const EM_V800: u16 = 36;
+pub const EM_FR20: u16 = 37;
+pub const EM_RH32: u16 = 38;
+pub const EM_RCE: u16 = 39;
+pub const EM_ARM: u16 = 40;
+pub const EM_FAKE_ALPHA: u16 = 41;
+pub const EM_SH: u16 = 42;
+pub const EM_SPARCV9: u16 = 43;
+pub const EM_TRICORE: u16 = 44;
+pub const EM_ARC: u16 = 45;
+pub const EM_H8_300: u16 = 46;
+pub const EM_H8_300H: u16 = 47;
+pub const EM_H8S: u16 = 48;
+pub const EM_H8_500: u16 = 49;
+pub const EM_IA_64: u16 = 50;
+pub const EM_MIPS_X: u16 = 51;
+pub const EM_COLDFIRE: u16 = 52;
+pub const EM_68HC12: u16 = 53;
+pub const EM_MMA: u16 = 54;
+pub const EM_PCP: u16 = 55;
+pub const EM_NCPU: u16 = 56;
+pub const EM_NDR1: u16 = 57;
+pub const EM_STARCORE: u16 = 58;
+pub const EM_ME16: u16 = 59;
+pub const EM_ST100: u16 = 60;
+pub const EM_TINYJ: u16 = 61;
+pub const EM_X86_64: u16 = 62;
+pub const EM_PDSP: u16 = 63;
+pub const EM_FX66: u16 = 66;
+pub const EM_ST9PLUS: u16 = 67;
+pub const EM_ST7: u16 = 68;
+pub const EM_68HC16: u16 = 69;
+pub const EM_68HC11: u16 = 70;
+pub const EM_68HC08: u16 = 71;
+pub const EM_68HC05: u16 = 72;
+pub const EM_SVX: u16 = 73;
+pub const EM_ST19: u16 = 74;
+pub const EM_VAX: u16 = 75;
+pub const EM_CRIS: u16 = 76;
+pub const EM_JAVELIN: u16 = 77;
+pub const EM_FIREPATH: u16 = 78;
+pub const EM_ZSP: u16 = 79;
+pub const EM_MMIX: u16 = 80;
+pub const EM_HUANY: u16 = 81;
+pub const EM_PRISM: u16 = 82;
+pub const EM_AVR: u16 = 83;
+pub const EM_FR30: u16 = 84;
+pub const EM_D10V: u16 = 85;
+pub const EM_D30V: u16 = 86;
+pub const EM_V850: u16 = 87;
+pub const EM_M32R: u16 = 88;
+pub const EM_MN10300: u16 = 89;
+pub const EM_MN10200: u16 = 90;
+pub const EM_PJ: u16 = 91;
+#[cfg(not(target_env = "uclibc"))]
+pub const EM_OPENRISC: u16 = 92;
+#[cfg(target_env = "uclibc")]
+pub const EM_OR1K: u16 = 92;
+#[cfg(not(target_env = "uclibc"))]
+pub const EM_ARC_A5: u16 = 93;
+pub const EM_XTENSA: u16 = 94;
+pub const EM_AARCH64: u16 = 183;
+pub const EM_TILEPRO: u16 = 188;
+pub const EM_TILEGX: u16 = 191;
+pub const EM_RISCV: u16 = 243;
+pub const EM_ALPHA: u16 = 0x9026;
+
+// elf.h - Legal values for e_version (version).
+pub const EV_NONE: u32 = 0;
+pub const EV_CURRENT: u32 = 1;
+pub const EV_NUM: u32 = 2;
+
+// elf.h - Legal values for p_type (segment type).
+pub const PT_NULL: u32 = 0;
+pub const PT_LOAD: u32 = 1;
+pub const PT_DYNAMIC: u32 = 2;
+pub const PT_INTERP: u32 = 3;
+pub const PT_NOTE: u32 = 4;
+pub const PT_SHLIB: u32 = 5;
+pub const PT_PHDR: u32 = 6;
+pub const PT_TLS: u32 = 7;
+pub const PT_NUM: u32 = 8;
+pub const PT_LOOS: u32 = 0x60000000;
+pub const PT_GNU_EH_FRAME: u32 = 0x6474e550;
+pub const PT_GNU_STACK: u32 = 0x6474e551;
+pub const PT_GNU_RELRO: u32 = 0x6474e552;
+pub const PT_LOSUNW: u32 = 0x6ffffffa;
+pub const PT_SUNWBSS: u32 = 0x6ffffffa;
+pub const PT_SUNWSTACK: u32 = 0x6ffffffb;
+pub const PT_HISUNW: u32 = 0x6fffffff;
+pub const PT_HIOS: u32 = 0x6fffffff;
+pub const PT_LOPROC: u32 = 0x70000000;
+pub const PT_HIPROC: u32 = 0x7fffffff;
+
+// Legal values for p_flags (segment flags).
+pub const PF_X: u32 = 1 << 0;
+pub const PF_W: u32 = 1 << 1;
+pub const PF_R: u32 = 1 << 2;
+pub const PF_MASKOS: u32 = 0x0ff00000;
+pub const PF_MASKPROC: u32 = 0xf0000000;
+
+// elf.h - Legal values for a_type (entry type).
+pub const AT_NULL: c_ulong = 0;
+pub const AT_IGNORE: c_ulong = 1;
+pub const AT_EXECFD: c_ulong = 2;
+pub const AT_PHDR: c_ulong = 3;
+pub const AT_PHENT: c_ulong = 4;
+pub const AT_PHNUM: c_ulong = 5;
+pub const AT_PAGESZ: c_ulong = 6;
+pub const AT_BASE: c_ulong = 7;
+pub const AT_FLAGS: c_ulong = 8;
+pub const AT_ENTRY: c_ulong = 9;
+pub const AT_NOTELF: c_ulong = 10;
+pub const AT_UID: c_ulong = 11;
+pub const AT_EUID: c_ulong = 12;
+pub const AT_GID: c_ulong = 13;
+pub const AT_EGID: c_ulong = 14;
+pub const AT_PLATFORM: c_ulong = 15;
+pub const AT_HWCAP: c_ulong = 16;
+pub const AT_CLKTCK: c_ulong = 17;
+
+pub const AT_SECURE: c_ulong = 23;
+pub const AT_BASE_PLATFORM: c_ulong = 24;
+pub const AT_RANDOM: c_ulong = 25;
+pub const AT_HWCAP2: c_ulong = 26;
+
+pub const AT_HWCAP3: c_ulong = 29;
+pub const AT_HWCAP4: c_ulong = 30;
+pub const AT_EXECFN: c_ulong = 31;
+
+// defined in arch/<arch>/include/uapi/asm/auxvec.h but has the same value
+// wherever it is defined.
+pub const AT_SYSINFO_EHDR: c_ulong = 33;
+#[cfg(not(target_env = "uclibc"))]
+pub const AT_MINSIGSTKSZ: c_ulong = 51;
+
+pub const GLOB_ERR: c_int = 1 << 0;
+pub const GLOB_MARK: c_int = 1 << 1;
+pub const GLOB_NOSORT: c_int = 1 << 2;
+pub const GLOB_DOOFFS: c_int = 1 << 3;
+pub const GLOB_NOCHECK: c_int = 1 << 4;
+pub const GLOB_APPEND: c_int = 1 << 5;
+pub const GLOB_NOESCAPE: c_int = 1 << 6;
+
+pub const GLOB_NOSPACE: c_int = 1;
+pub const GLOB_ABORTED: c_int = 2;
+pub const GLOB_NOMATCH: c_int = 3;
+
+pub const POSIX_MADV_NORMAL: c_int = 0;
+pub const POSIX_MADV_RANDOM: c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: c_int = 2;
+pub const POSIX_MADV_WILLNEED: c_int = 3;
+pub const POSIX_MADV_DONTNEED: c_int = 4;
+
+pub const S_IEXEC: mode_t = 0o0100;
+pub const S_IWRITE: mode_t = 0o0200;
+pub const S_IREAD: mode_t = 0o0400;
+
+pub const F_LOCK: c_int = 1;
+pub const F_TEST: c_int = 3;
+pub const F_TLOCK: c_int = 2;
+pub const F_ULOCK: c_int = 0;
+
+pub const ST_RDONLY: c_ulong = 1;
+pub const ST_NOSUID: c_ulong = 2;
+pub const ST_NODEV: c_ulong = 4;
+pub const ST_NOEXEC: c_ulong = 8;
+pub const ST_SYNCHRONOUS: c_ulong = 16;
+pub const ST_MANDLOCK: c_ulong = 64;
+pub const ST_WRITE: c_ulong = 128;
+pub const ST_APPEND: c_ulong = 256;
+pub const ST_IMMUTABLE: c_ulong = 512;
+pub const ST_NOATIME: c_ulong = 1024;
+pub const ST_NODIRATIME: c_ulong = 2048;
+
+pub const RTLD_NEXT: *mut c_void = -1i64 as *mut c_void;
+pub const RTLD_DEFAULT: *mut c_void = ptr::null_mut();
+pub const RTLD_NODELETE: c_int = 0x1000;
+pub const RTLD_NOW: c_int = 0x2;
+
+pub const AT_EACCESS: c_int = 0x200;
+
+pub const PTHREAD_BARRIER_SERIAL_THREAD: c_int = -1;
+pub const PTHREAD_ONCE_INIT: pthread_once_t = 0;
+pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
+pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
+pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
+pub const PTHREAD_MUTEX_DEFAULT: c_int = PTHREAD_MUTEX_NORMAL;
+#[cfg(not(target_env = "uclibc"))]
+pub const PTHREAD_MUTEX_STALLED: c_int = 0;
+#[cfg(not(target_env = "uclibc"))]
+pub const PTHREAD_MUTEX_ROBUST: c_int = 1;
+#[cfg(not(target_env = "uclibc"))]
+pub const PTHREAD_PRIO_NONE: c_int = 0;
+#[cfg(not(target_env = "uclibc"))]
+pub const PTHREAD_PRIO_INHERIT: c_int = 1;
+#[cfg(not(target_env = "uclibc"))]
+pub const PTHREAD_PRIO_PROTECT: c_int = 2;
+pub const PTHREAD_PROCESS_PRIVATE: c_int = 0;
+pub const PTHREAD_PROCESS_SHARED: c_int = 1;
+pub const PTHREAD_INHERIT_SCHED: c_int = 0;
+pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
+#[cfg(not(target_env = "uclibc"))]
+pub const __SIZEOF_PTHREAD_COND_T: usize = 48;
+
+// netinet/in.h
+// NOTE: These are in addition to the constants defined in src/unix/mod.rs
+
+#[deprecated(
+    since = "0.2.80",
+    note = "This value was increased in the newer kernel \
+            and we'll change this following upstream in the future release. \
+            See #1896 for more info."
+)]
+pub const IPPROTO_MAX: c_int = 256;
+
+// System V IPC
+pub const IPC_PRIVATE: crate::key_t = 0;
+
+pub const IPC_CREAT: c_int = 0o1000;
+pub const IPC_EXCL: c_int = 0o2000;
+pub const IPC_NOWAIT: c_int = 0o4000;
+
+pub const IPC_RMID: c_int = 0;
+pub const IPC_SET: c_int = 1;
+pub const IPC_STAT: c_int = 2;
+pub const IPC_INFO: c_int = 3;
+
+pub const SHM_R: c_int = 0o400;
+pub const SHM_W: c_int = 0o200;
+
+pub const SHM_RDONLY: c_int = 0o10000;
+pub const SHM_RND: c_int = 0o20000;
+pub const SHM_REMAP: c_int = 0o40000;
+pub const SHM_LOCK: c_int = 11;
+pub const SHM_UNLOCK: c_int = 12;
+pub const SHM_HUGETLB: c_int = 0o4000;
+#[cfg(not(all(target_env = "uclibc", target_arch = "mips")))]
+pub const SHM_NORESERVE: c_int = 0o10000;
+
+pub const LOG_NFACILITIES: c_int = 24;
+
+pub const SEM_FAILED: *mut crate::sem_t = ptr::null_mut();
+
+pub const AI_PASSIVE: c_int = 0x0001;
+pub const AI_CANONNAME: c_int = 0x0002;
+pub const AI_NUMERICHOST: c_int = 0x0004;
+pub const AI_V4MAPPED: c_int = 0x0008;
+pub const AI_ALL: c_int = 0x0010;
+pub const AI_ADDRCONFIG: c_int = 0x0020;
+
+pub const AI_NUMERICSERV: c_int = 0x0400;
+
+pub const EAI_BADFLAGS: c_int = -1;
+pub const EAI_NONAME: c_int = -2;
+pub const EAI_AGAIN: c_int = -3;
+pub const EAI_FAIL: c_int = -4;
+pub const EAI_NODATA: c_int = -5;
+pub const EAI_FAMILY: c_int = -6;
+pub const EAI_SOCKTYPE: c_int = -7;
+pub const EAI_SERVICE: c_int = -8;
+pub const EAI_MEMORY: c_int = -10;
+pub const EAI_SYSTEM: c_int = -11;
+pub const EAI_OVERFLOW: c_int = -12;
+
+pub const NI_NUMERICHOST: c_int = 1;
+pub const NI_NUMERICSERV: c_int = 2;
+pub const NI_NOFQDN: c_int = 4;
+pub const NI_NAMEREQD: c_int = 8;
+pub const NI_DGRAM: c_int = 16;
+#[cfg(not(target_env = "uclibc"))]
+pub const NI_IDN: c_int = 32;
+
+cfg_if! {
+    if #[cfg(not(target_env = "uclibc"))] {
+        pub const AIO_CANCELED: c_int = 0;
+        pub const AIO_NOTCANCELED: c_int = 1;
+        pub const AIO_ALLDONE: c_int = 2;
+        pub const LIO_READ: c_int = 0;
+        pub const LIO_WRITE: c_int = 1;
+        pub const LIO_NOP: c_int = 2;
+        pub const LIO_WAIT: c_int = 0;
+        pub const LIO_NOWAIT: c_int = 1;
+        pub const RUSAGE_THREAD: c_int = 1;
+        pub const MSG_COPY: c_int = 0o40000;
+        pub const SHM_EXEC: c_int = 0o100000;
+        pub const IPV6_MULTICAST_ALL: c_int = 29;
+        pub const IPV6_ROUTER_ALERT_ISOLATE: c_int = 30;
+        pub const PACKET_MR_UNICAST: c_int = 3;
+        pub const PTRACE_EVENT_STOP: c_int = 128;
+        pub const UDP_SEGMENT: c_int = 103;
+        pub const UDP_GRO: c_int = 104;
+    }
+}
+
+pub const PR_SET_PDEATHSIG: c_int = 1;
+pub const PR_GET_PDEATHSIG: c_int = 2;
+
+pub const PR_GET_DUMPABLE: c_int = 3;
+pub const PR_SET_DUMPABLE: c_int = 4;
+
+pub const PR_GET_UNALIGN: c_int = 5;
+pub const PR_SET_UNALIGN: c_int = 6;
+pub const PR_UNALIGN_NOPRINT: c_int = 1;
+pub const PR_UNALIGN_SIGBUS: c_int = 2;
+
+pub const PR_GET_KEEPCAPS: c_int = 7;
+pub const PR_SET_KEEPCAPS: c_int = 8;
+
+pub const PR_GET_FPEMU: c_int = 9;
+pub const PR_SET_FPEMU: c_int = 10;
+pub const PR_FPEMU_NOPRINT: c_int = 1;
+pub const PR_FPEMU_SIGFPE: c_int = 2;
+
+pub const PR_GET_FPEXC: c_int = 11;
+pub const PR_SET_FPEXC: c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: c_int = 0x80;
+pub const PR_FP_EXC_DIV: c_int = 0x010000;
+pub const PR_FP_EXC_OVF: c_int = 0x020000;
+pub const PR_FP_EXC_UND: c_int = 0x040000;
+pub const PR_FP_EXC_RES: c_int = 0x080000;
+pub const PR_FP_EXC_INV: c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: c_int = 0;
+pub const PR_FP_EXC_NONRECOV: c_int = 1;
+pub const PR_FP_EXC_ASYNC: c_int = 2;
+pub const PR_FP_EXC_PRECISE: c_int = 3;
+
+pub const PR_GET_TIMING: c_int = 13;
+pub const PR_SET_TIMING: c_int = 14;
+pub const PR_TIMING_STATISTICAL: c_int = 0;
+pub const PR_TIMING_TIMESTAMP: c_int = 1;
+
+pub const PR_SET_NAME: c_int = 15;
+pub const PR_GET_NAME: c_int = 16;
+
+pub const PR_GET_ENDIAN: c_int = 19;
+pub const PR_SET_ENDIAN: c_int = 20;
+pub const PR_ENDIAN_BIG: c_int = 0;
+pub const PR_ENDIAN_LITTLE: c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: c_int = 2;
+
+pub const PR_GET_SECCOMP: c_int = 21;
+pub const PR_SET_SECCOMP: c_int = 22;
+
+pub const PR_CAPBSET_READ: c_int = 23;
+pub const PR_CAPBSET_DROP: c_int = 24;
+
+pub const PR_GET_TSC: c_int = 25;
+pub const PR_SET_TSC: c_int = 26;
+pub const PR_TSC_ENABLE: c_int = 1;
+pub const PR_TSC_SIGSEGV: c_int = 2;
+
+pub const PR_GET_SECUREBITS: c_int = 27;
+pub const PR_SET_SECUREBITS: c_int = 28;
+
+pub const PR_SET_TIMERSLACK: c_int = 29;
+pub const PR_GET_TIMERSLACK: c_int = 30;
+
+pub const PR_TASK_PERF_EVENTS_DISABLE: c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: c_int = 32;
+
+pub const PR_MCE_KILL: c_int = 33;
+pub const PR_MCE_KILL_CLEAR: c_int = 0;
+pub const PR_MCE_KILL_SET: c_int = 1;
+
+pub const PR_MCE_KILL_LATE: c_int = 0;
+pub const PR_MCE_KILL_EARLY: c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: c_int = 2;
+
+pub const PR_MCE_KILL_GET: c_int = 34;
+
+pub const PR_SET_MM: c_int = 35;
+pub const PR_SET_MM_START_CODE: c_int = 1;
+pub const PR_SET_MM_END_CODE: c_int = 2;
+pub const PR_SET_MM_START_DATA: c_int = 3;
+pub const PR_SET_MM_END_DATA: c_int = 4;
+pub const PR_SET_MM_START_STACK: c_int = 5;
+pub const PR_SET_MM_START_BRK: c_int = 6;
+pub const PR_SET_MM_BRK: c_int = 7;
+pub const PR_SET_MM_ARG_START: c_int = 8;
+pub const PR_SET_MM_ARG_END: c_int = 9;
+pub const PR_SET_MM_ENV_START: c_int = 10;
+pub const PR_SET_MM_ENV_END: c_int = 11;
+pub const PR_SET_MM_AUXV: c_int = 12;
+pub const PR_SET_MM_EXE_FILE: c_int = 13;
+pub const PR_SET_MM_MAP: c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: c_int = 15;
+
+pub const PR_SET_PTRACER: c_int = 0x59616d61;
+pub const PR_SET_PTRACER_ANY: c_ulong = 0xffffffffffffffff;
+
+pub const PR_SET_CHILD_SUBREAPER: c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: c_int = 37;
+
+pub const PR_SET_NO_NEW_PRIVS: c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: c_int = 39;
+
+pub const PR_GET_TID_ADDRESS: c_int = 40;
+
+pub const PR_SET_THP_DISABLE: c_int = 41;
+pub const PR_GET_THP_DISABLE: c_int = 42;
+
+pub const PR_MPX_ENABLE_MANAGEMENT: c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: c_int = 44;
+
+pub const PR_SET_FP_MODE: c_int = 45;
+pub const PR_GET_FP_MODE: c_int = 46;
+pub const PR_FP_MODE_FR: c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: c_int = 1 << 1;
+
+pub const PR_CAP_AMBIENT: c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: c_int = 4;
+
+pub const PR_SET_VMA: c_int = 0x53564d41;
+pub const PR_SET_VMA_ANON_NAME: c_int = 0;
+
+pub const PR_SCHED_CORE: c_int = 62;
+pub const PR_SCHED_CORE_GET: c_int = 0;
+pub const PR_SCHED_CORE_CREATE: c_int = 1;
+pub const PR_SCHED_CORE_SHARE_TO: c_int = 2;
+pub const PR_SCHED_CORE_SHARE_FROM: c_int = 3;
+pub const PR_SCHED_CORE_MAX: c_int = 4;
+pub const PR_SCHED_CORE_SCOPE_THREAD: c_int = 0;
+pub const PR_SCHED_CORE_SCOPE_THREAD_GROUP: c_int = 1;
+pub const PR_SCHED_CORE_SCOPE_PROCESS_GROUP: c_int = 2;
+
+pub const ITIMER_REAL: c_int = 0;
+pub const ITIMER_VIRTUAL: c_int = 1;
+pub const ITIMER_PROF: c_int = 2;
+
+pub const _POSIX_VDISABLE: crate::cc_t = 0;
+
+pub const IPV6_RTHDR_LOOSE: c_int = 0;
+pub const IPV6_RTHDR_STRICT: c_int = 1;
+
+pub const IUTF8: crate::tcflag_t = 0x00004000;
+#[cfg(not(all(target_env = "uclibc", target_arch = "mips")))]
+pub const CMSPAR: crate::tcflag_t = 0o10000000000;
+
+pub const MFD_CLOEXEC: c_uint = 0x0001;
+pub const MFD_ALLOW_SEALING: c_uint = 0x0002;
+pub const MFD_HUGETLB: c_uint = 0x0004;
+cfg_if! {
+    if #[cfg(not(target_env = "uclibc"))] {
+        pub const MFD_NOEXEC_SEAL: c_uint = 0x0008;
+        pub const MFD_EXEC: c_uint = 0x0010;
+        pub const MFD_HUGE_64KB: c_uint = 0x40000000;
+        pub const MFD_HUGE_512KB: c_uint = 0x4c000000;
+        pub const MFD_HUGE_1MB: c_uint = 0x50000000;
+        pub const MFD_HUGE_2MB: c_uint = 0x54000000;
+        pub const MFD_HUGE_8MB: c_uint = 0x5c000000;
+        pub const MFD_HUGE_16MB: c_uint = 0x60000000;
+        pub const MFD_HUGE_32MB: c_uint = 0x64000000;
+        pub const MFD_HUGE_256MB: c_uint = 0x70000000;
+        pub const MFD_HUGE_512MB: c_uint = 0x74000000;
+        pub const MFD_HUGE_1GB: c_uint = 0x78000000;
+        pub const MFD_HUGE_2GB: c_uint = 0x7c000000;
+        pub const MFD_HUGE_16GB: c_uint = 0x88000000;
+        pub const MFD_HUGE_MASK: c_uint = 63;
+        pub const MFD_HUGE_SHIFT: c_uint = 26;
+
+        pub const NLMSG_NOOP: c_int = 0x1;
+        pub const NLMSG_ERROR: c_int = 0x2;
+        pub const NLMSG_DONE: c_int = 0x3;
+        pub const NLMSG_OVERRUN: c_int = 0x4;
+        pub const NLMSG_MIN_TYPE: c_int = 0x10;
+    }
+}
+
+// linux/if_packet.h
+pub const PACKET_HOST: c_uchar = 0;
+pub const PACKET_BROADCAST: c_uchar = 1;
+pub const PACKET_MULTICAST: c_uchar = 2;
+pub const PACKET_OTHERHOST: c_uchar = 3;
+pub const PACKET_OUTGOING: c_uchar = 4;
+pub const PACKET_LOOPBACK: c_uchar = 5;
+#[cfg(not(target_os = "l4re"))]
+pub const PACKET_USER: c_uchar = 6;
+#[cfg(not(target_os = "l4re"))]
+pub const PACKET_KERNEL: c_uchar = 7;
+
+pub const PACKET_ADD_MEMBERSHIP: c_int = 1;
+pub const PACKET_DROP_MEMBERSHIP: c_int = 2;
+pub const PACKET_RECV_OUTPUT: c_int = 3;
+pub const PACKET_RX_RING: c_int = 5;
+pub const PACKET_STATISTICS: c_int = 6;
+cfg_if! {
+    if #[cfg(not(target_os = "l4re"))] {
+        pub const PACKET_COPY_THRESH: c_int = 7;
+        pub const PACKET_AUXDATA: c_int = 8;
+        pub const PACKET_ORIGDEV: c_int = 9;
+        pub const PACKET_VERSION: c_int = 10;
+        pub const PACKET_HDRLEN: c_int = 11;
+        pub const PACKET_RESERVE: c_int = 12;
+        pub const PACKET_TX_RING: c_int = 13;
+        pub const PACKET_LOSS: c_int = 14;
+        pub const PACKET_VNET_HDR: c_int = 15;
+        pub const PACKET_TX_TIMESTAMP: c_int = 16;
+        pub const PACKET_TIMESTAMP: c_int = 17;
+    }
+}
+
+pub const PACKET_MR_MULTICAST: c_int = 0;
+pub const PACKET_MR_PROMISC: c_int = 1;
+pub const PACKET_MR_ALLMULTI: c_int = 2;
+
+pub const SIOCADDRT: c_ulong = 0x0000890B;
+pub const SIOCDELRT: c_ulong = 0x0000890C;
+pub const SIOCGIFNAME: c_ulong = 0x00008910;
+pub const SIOCSIFLINK: c_ulong = 0x00008911;
+pub const SIOCGIFCONF: c_ulong = 0x00008912;
+pub const SIOCGIFFLAGS: c_ulong = 0x00008913;
+pub const SIOCSIFFLAGS: c_ulong = 0x00008914;
+pub const SIOCGIFADDR: c_ulong = 0x00008915;
+pub const SIOCSIFADDR: c_ulong = 0x00008916;
+pub const SIOCGIFDSTADDR: c_ulong = 0x00008917;
+pub const SIOCSIFDSTADDR: c_ulong = 0x00008918;
+pub const SIOCGIFBRDADDR: c_ulong = 0x00008919;
+pub const SIOCSIFBRDADDR: c_ulong = 0x0000891A;
+pub const SIOCGIFNETMASK: c_ulong = 0x0000891B;
+pub const SIOCSIFNETMASK: c_ulong = 0x0000891C;
+pub const SIOCGIFMETRIC: c_ulong = 0x0000891D;
+pub const SIOCSIFMETRIC: c_ulong = 0x0000891E;
+pub const SIOCGIFMEM: c_ulong = 0x0000891F;
+pub const SIOCSIFMEM: c_ulong = 0x00008920;
+pub const SIOCGIFMTU: c_ulong = 0x00008921;
+pub const SIOCSIFMTU: c_ulong = 0x00008922;
+pub const SIOCSIFNAME: c_ulong = 0x00008923;
+pub const SIOCSIFHWADDR: c_ulong = 0x00008924;
+pub const SIOCGIFENCAP: c_ulong = 0x00008925;
+pub const SIOCSIFENCAP: c_ulong = 0x00008926;
+pub const SIOCGIFHWADDR: c_ulong = 0x00008927;
+pub const SIOCGIFSLAVE: c_ulong = 0x00008929;
+pub const SIOCSIFSLAVE: c_ulong = 0x00008930;
+pub const SIOCADDMULTI: c_ulong = 0x00008931;
+pub const SIOCDELMULTI: c_ulong = 0x00008932;
+pub const SIOCGIFINDEX: c_ulong = 0x00008933;
+pub const SIOGIFINDEX: c_ulong = SIOCGIFINDEX;
+pub const SIOCSIFPFLAGS: c_ulong = 0x00008934;
+pub const SIOCGIFPFLAGS: c_ulong = 0x00008935;
+pub const SIOCDIFADDR: c_ulong = 0x00008936;
+pub const SIOCSIFHWBROADCAST: c_ulong = 0x00008937;
+pub const SIOCGIFCOUNT: c_ulong = 0x00008938;
+pub const SIOCGIFBR: c_ulong = 0x00008940;
+pub const SIOCSIFBR: c_ulong = 0x00008941;
+pub const SIOCGIFTXQLEN: c_ulong = 0x00008942;
+pub const SIOCSIFTXQLEN: c_ulong = 0x00008943;
+cfg_if! {
+    if #[cfg(not(target_os = "l4re"))] {
+        pub const SIOCETHTOOL: c_ulong = 0x00008946;
+        pub const SIOCGMIIPHY: c_ulong = 0x00008947;
+        pub const SIOCGMIIREG: c_ulong = 0x00008948;
+        pub const SIOCSMIIREG: c_ulong = 0x00008949;
+        pub const SIOCWANDEV: c_ulong = 0x0000894A;
+        pub const SIOCOUTQNSD: c_ulong = 0x0000894B;
+        pub const SIOCGSKNS: c_ulong = 0x0000894C;
+    }
+}
+pub const SIOCDARP: c_ulong = 0x00008953;
+pub const SIOCGARP: c_ulong = 0x00008954;
+pub const SIOCSARP: c_ulong = 0x00008955;
+pub const SIOCDRARP: c_ulong = 0x00008960;
+pub const SIOCGRARP: c_ulong = 0x00008961;
+pub const SIOCSRARP: c_ulong = 0x00008962;
+pub const SIOCGIFMAP: c_ulong = 0x00008970;
+pub const SIOCSIFMAP: c_ulong = 0x00008971;
+
+pub const IPTOS_TOS_MASK: u8 = 0x1E;
+pub const IPTOS_PREC_MASK: u8 = 0xE0;
+
+pub const IPTOS_ECN_NOT_ECT: u8 = 0x00;
+
+pub const RTF_UP: c_ushort = 0x0001;
+pub const RTF_GATEWAY: c_ushort = 0x0002;
+
+pub const RTF_HOST: c_ushort = 0x0004;
+pub const RTF_REINSTATE: c_ushort = 0x0008;
+pub const RTF_DYNAMIC: c_ushort = 0x0010;
+pub const RTF_MODIFIED: c_ushort = 0x0020;
+pub const RTF_MTU: c_ushort = 0x0040;
+pub const RTF_MSS: c_ushort = RTF_MTU;
+pub const RTF_WINDOW: c_ushort = 0x0080;
+pub const RTF_IRTT: c_ushort = 0x0100;
+pub const RTF_REJECT: c_ushort = 0x0200;
+pub const RTF_STATIC: c_ushort = 0x0400;
+pub const RTF_XRESOLVE: c_ushort = 0x0800;
+pub const RTF_NOFORWARD: c_ushort = 0x1000;
+pub const RTF_THROW: c_ushort = 0x2000;
+pub const RTF_NOPMTUDISC: c_ushort = 0x4000;
+
+pub const RTF_DEFAULT: u32 = 0x00010000;
+pub const RTF_ALLONLINK: u32 = 0x00020000;
+pub const RTF_ADDRCONF: u32 = 0x00040000;
+pub const RTF_LINKRT: u32 = 0x00100000;
+pub const RTF_NONEXTHOP: u32 = 0x00200000;
+pub const RTF_CACHE: u32 = 0x01000000;
+pub const RTF_FLOW: u32 = 0x02000000;
+pub const RTF_POLICY: u32 = 0x04000000;
+
+pub const RTCF_VALVE: u32 = 0x00200000;
+pub const RTCF_MASQ: u32 = 0x00400000;
+pub const RTCF_NAT: u32 = 0x00800000;
+pub const RTCF_DOREDIRECT: u32 = 0x01000000;
+pub const RTCF_LOG: u32 = 0x02000000;
+pub const RTCF_DIRECTSRC: u32 = 0x04000000;
+
+pub const RTF_LOCAL: u32 = 0x80000000;
+pub const RTF_INTERFACE: u32 = 0x40000000;
+pub const RTF_MULTICAST: u32 = 0x20000000;
+pub const RTF_BROADCAST: u32 = 0x10000000;
+pub const RTF_NAT: u32 = 0x08000000;
+pub const RTF_ADDRCLASSMASK: u32 = 0xF8000000;
+
+pub const RT_CLASS_UNSPEC: u8 = 0;
+pub const RT_CLASS_DEFAULT: u8 = 253;
+pub const RT_CLASS_MAIN: u8 = 254;
+pub const RT_CLASS_LOCAL: u8 = 255;
+pub const RT_CLASS_MAX: u8 = 255;
+
+pub const MAX_ADDR_LEN: usize = 7;
+pub const ARPD_UPDATE: c_ushort = 0x01;
+pub const ARPD_LOOKUP: c_ushort = 0x02;
+pub const ARPD_FLUSH: c_ushort = 0x03;
+pub const ATF_MAGIC: c_int = 0x80;
+
+// include/uapi/linux/udp.h
+pub const UDP_CORK: c_int = 1;
+pub const UDP_ENCAP: c_int = 100;
+pub const UDP_NO_CHECK6_TX: c_int = 101;
+pub const UDP_NO_CHECK6_RX: c_int = 102;
+
+// include/uapi/asm-generic/mman-common.h
+pub const MAP_FIXED_NOREPLACE: c_int = 0x100000;
+pub const MLOCK_ONFAULT: c_uint = 0x01;
+
+pub const REG_EXTENDED: c_int = 1;
+pub const REG_ICASE: c_int = 2;
+pub const REG_NEWLINE: c_int = 4;
+pub const REG_NOSUB: c_int = 8;
+
+pub const REG_NOTBOL: c_int = 1;
+pub const REG_NOTEOL: c_int = 2;
+
+pub const REG_ENOSYS: c_int = -1;
+pub const REG_NOMATCH: c_int = 1;
+pub const REG_BADPAT: c_int = 2;
+pub const REG_ECOLLATE: c_int = 3;
+pub const REG_ECTYPE: c_int = 4;
+pub const REG_EESCAPE: c_int = 5;
+pub const REG_ESUBREG: c_int = 6;
+pub const REG_EBRACK: c_int = 7;
+pub const REG_EPAREN: c_int = 8;
+pub const REG_EBRACE: c_int = 9;
+pub const REG_BADBR: c_int = 10;
+pub const REG_ERANGE: c_int = 11;
+pub const REG_ESPACE: c_int = 12;
+pub const REG_BADRPT: c_int = 13;
+
+// errno.h
+pub const EPERM: c_int = 1;
+pub const ENOENT: c_int = 2;
+pub const ESRCH: c_int = 3;
+pub const EINTR: c_int = 4;
+pub const EIO: c_int = 5;
+pub const ENXIO: c_int = 6;
+pub const E2BIG: c_int = 7;
+pub const ENOEXEC: c_int = 8;
+pub const EBADF: c_int = 9;
+pub const ECHILD: c_int = 10;
+pub const EAGAIN: c_int = 11;
+pub const ENOMEM: c_int = 12;
+pub const EACCES: c_int = 13;
+pub const EFAULT: c_int = 14;
+pub const ENOTBLK: c_int = 15;
+pub const EBUSY: c_int = 16;
+pub const EEXIST: c_int = 17;
+pub const EXDEV: c_int = 18;
+pub const ENODEV: c_int = 19;
+pub const ENOTDIR: c_int = 20;
+pub const EISDIR: c_int = 21;
+pub const EINVAL: c_int = 22;
+pub const ENFILE: c_int = 23;
+pub const EMFILE: c_int = 24;
+pub const ENOTTY: c_int = 25;
+pub const ETXTBSY: c_int = 26;
+pub const EFBIG: c_int = 27;
+pub const ENOSPC: c_int = 28;
+pub const ESPIPE: c_int = 29;
+pub const EROFS: c_int = 30;
+pub const EMLINK: c_int = 31;
+pub const EPIPE: c_int = 32;
+pub const EDOM: c_int = 33;
+pub const ERANGE: c_int = 34;
+pub const EWOULDBLOCK: c_int = EAGAIN;
+
+pub const CSIGNAL: c_int = 0x000000ff;
+
+#[cfg(not(target_os = "l4re"))]
+pub const SCHED_NORMAL: c_int = 0;
+pub const SCHED_OTHER: c_int = 0;
+pub const SCHED_FIFO: c_int = 1;
+pub const SCHED_RR: c_int = 2;
+pub const SCHED_BATCH: c_int = 3;
+pub const SCHED_IDLE: c_int = 5;
+pub const SCHED_DEADLINE: c_int = 6;
+
+pub const SCHED_RESET_ON_FORK: c_int = 0x40000000;
+
+// elf.h
+pub const NT_PRSTATUS: c_int = 1;
+#[cfg(not(target_os = "l4re"))]
+pub const NT_PRFPREG: c_int = 2;
+pub const NT_FPREGSET: c_int = 2;
+pub const NT_PRPSINFO: c_int = 3;
+#[cfg(not(target_os = "l4re"))]
+pub const NT_PRXREG: c_int = 4;
+pub const NT_TASKSTRUCT: c_int = 4;
+pub const NT_PLATFORM: c_int = 5;
+pub const NT_AUXV: c_int = 6;
+pub const NT_GWINDOWS: c_int = 7;
+pub const NT_ASRS: c_int = 8;
+pub const NT_PSTATUS: c_int = 10;
+pub const NT_PSINFO: c_int = 13;
+pub const NT_PRCRED: c_int = 14;
+pub const NT_UTSNAME: c_int = 15;
+pub const NT_LWPSTATUS: c_int = 16;
+pub const NT_LWPSINFO: c_int = 17;
+pub const NT_PRFPXREG: c_int = 20;
+
+pub const MS_NOUSER: c_ulong = 0xffffffff80000000;
+
+f! {
+    pub fn CMSG_NXTHDR(
+        mhdr: *const crate::msghdr,
+        cmsg: *const crate::cmsghdr,
+    ) -> *mut crate::cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < size_of::<crate::cmsghdr>() {
+            return core::ptr::null_mut::<crate::cmsghdr>();
+        }
+        let next =
+            (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut crate::cmsghdr;
+        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
+        if (next.wrapping_offset(1)) as usize > max
+            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max
+        {
+            core::ptr::null_mut::<crate::cmsghdr>()
+        } else {
+            next
+        }
+    }
+
+    pub fn CPU_ALLOC_SIZE(count: c_int) -> size_t {
+        let _dummy: cpu_set_t = mem::zeroed();
+        let size_in_bits = 8 * mem::size_of_val(&_dummy.bits[0]);
+        ((count as size_t + size_in_bits - 1) / 8) as size_t
+    }
+
+    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {
+        for slot in &mut cpuset.bits {
+            *slot = 0;
+        }
+    }
+
+    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] |= 1 << offset;
+    }
+
+    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {
+        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        cpuset.bits[idx] &= !(1 << offset);
+    }
+
+    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {
+        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]);
+        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);
+        0 != (cpuset.bits[idx] & (1 << offset))
+    }
+
+    pub fn CPU_COUNT_S(size: usize, cpuset: &cpu_set_t) -> c_int {
+        let mut s: u32 = 0;
+        let size_of_mask = mem::size_of_val(&cpuset.bits[0]);
+        for i in &cpuset.bits[..(size / size_of_mask)] {
+            s += i.count_ones();
+        }
+        s as c_int
+    }
+
+    pub fn CPU_COUNT(cpuset: &cpu_set_t) -> c_int {
+        CPU_COUNT_S(size_of::<cpu_set_t>(), cpuset)
+    }
+
+    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {
+        set1.bits == set2.bits
+    }
+
+    pub fn IPTOS_TOS(tos: u8) -> u8 {
+        tos & IPTOS_TOS_MASK
+    }
+
+    pub fn IPTOS_PREC(tos: u8) -> u8 {
+        tos & IPTOS_PREC_MASK
+    }
+
+    pub fn RT_TOS(tos: u8) -> u8 {
+        tos & crate::IPTOS_TOS_MASK
+    }
+
+    pub fn RT_ADDRCLASS(flags: u32) -> u32 {
+        flags >> 23
+    }
+
+    pub fn RT_LOCALADDR(flags: u32) -> bool {
+        (flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE)
+    }
+
+    pub fn ELF32_R_SYM(val: Elf32_Word) -> Elf32_Word {
+        val >> 8
+    }
+
+    pub fn ELF32_R_TYPE(val: Elf32_Word) -> Elf32_Word {
+        val & 0xff
+    }
+
+    pub fn ELF32_R_INFO(sym: Elf32_Word, t: Elf32_Word) -> Elf32_Word {
+        sym << (8 + t) & 0xff
+    }
+
+    pub fn ELF64_R_SYM(val: Elf64_Xword) -> Elf64_Xword {
+        val >> 32
+    }
+
+    pub fn ELF64_R_TYPE(val: Elf64_Xword) -> Elf64_Xword {
+        val & 0xffffffff
+    }
+
+    pub fn ELF64_R_INFO(sym: Elf64_Xword, t: Elf64_Xword) -> Elf64_Xword {
+        sym << (32 + t)
+    }
+}
+
+safe_f! {
+    pub const fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {
+        let major = major as crate::dev_t;
+        let minor = minor as crate::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+
+    pub const fn major(dev: crate::dev_t) -> c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as c_uint
+    }
+
+    pub const fn minor(dev: crate::dev_t) -> c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as c_uint
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(
+        any(target_env = "gnu", target_env = "musl", target_env = "ohos"),
+        any(target_arch = "x86_64", target_arch = "x86")
+    ))] {
+        extern "C" {
+            pub fn iopl(level: c_int) -> c_int;
+            pub fn ioperm(from: c_ulong, num: c_ulong, turn_on: c_int) -> c_int;
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(not(target_env = "uclibc"), not(target_env = "ohos")))] {
+        extern "C" {
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_read64")]
+            pub fn aio_read(aiocbp: *mut crate::aiocb) -> c_int;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_write64")]
+            pub fn aio_write(aiocbp: *mut crate::aiocb) -> c_int;
+            pub fn aio_fsync(op: c_int, aiocbp: *mut crate::aiocb) -> c_int;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_error64")]
+            pub fn aio_error(aiocbp: *const crate::aiocb) -> c_int;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_return64")]
+            pub fn aio_return(aiocbp: *mut crate::aiocb) -> ssize_t;
+            #[cfg_attr(gnu_time_bits64, link_name = "__aio_suspend_time64")]
+            pub fn aio_suspend(
+                aiocb_list: *const *const crate::aiocb,
+                nitems: c_int,
+                timeout: *const crate::timespec,
+            ) -> c_int;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "aio_cancel64")]
+            pub fn aio_cancel(fd: c_int, aiocbp: *mut crate::aiocb) -> c_int;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "lio_listio64")]
+            pub fn lio_listio(
+                mode: c_int,
+                aiocb_list: *const *mut crate::aiocb,
+                nitems: c_int,
+                sevp: *mut crate::sigevent,
+            ) -> c_int;
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(not(target_env = "uclibc"))] {
+        extern "C" {
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "pwritev64")]
+            pub fn pwritev(
+                fd: c_int,
+                iov: *const crate::iovec,
+                iovcnt: c_int,
+                offset: crate::off_t,
+            ) -> ssize_t;
+            #[cfg_attr(gnu_file_offset_bits64, link_name = "preadv64")]
+            pub fn preadv(
+                fd: c_int,
+                iov: *const crate::iovec,
+                iovcnt: c_int,
+                offset: crate::off_t,
+            ) -> ssize_t;
+            pub fn getnameinfo(
+                sa: *const crate::sockaddr,
+                salen: crate::socklen_t,
+                host: *mut c_char,
+                hostlen: crate::socklen_t,
+                serv: *mut c_char,
+                servlen: crate::socklen_t,
+                flags: c_int,
+            ) -> c_int;
+            pub fn getloadavg(loadavg: *mut c_double, nelem: c_int) -> c_int;
+            pub fn process_vm_readv(
+                pid: crate::pid_t,
+                local_iov: *const crate::iovec,
+                liovcnt: c_ulong,
+                remote_iov: *const crate::iovec,
+                riovcnt: c_ulong,
+                flags: c_ulong,
+            ) -> isize;
+            pub fn process_vm_writev(
+                pid: crate::pid_t,
+                local_iov: *const crate::iovec,
+                liovcnt: c_ulong,
+                remote_iov: *const crate::iovec,
+                riovcnt: c_ulong,
+                flags: c_ulong,
+            ) -> isize;
+            #[cfg_attr(gnu_time_bits64, link_name = "__futimes64")]
+            pub fn futimes(fd: c_int, times: *const crate::timeval) -> c_int;
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(not(target_env = "ohos"))] {
+        extern "C" {
+            pub fn pthread_cancel(thread: crate::pthread_t) -> c_int;
+        }
+    }
+}
+
+extern "C" {
+    #[cfg_attr(
+        not(any(target_env = "musl", target_env = "ohos")),
+        link_name = "__xpg_strerror_r"
+    )]
+    pub fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
+
+    pub fn abs(i: c_int) -> c_int;
+    pub fn labs(i: c_long) -> c_long;
+    pub fn rand() -> c_int;
+    pub fn srand(seed: c_uint);
+
+    pub fn drand48() -> c_double;
+    pub fn erand48(xseed: *mut c_ushort) -> c_double;
+    pub fn lrand48() -> c_long;
+    pub fn nrand48(xseed: *mut c_ushort) -> c_long;
+    pub fn jrand48(xseed: *mut c_ushort) -> c_long;
+    pub fn srand48(seed: c_long);
+
+    pub fn setpwent();
+    pub fn endpwent();
+    pub fn getpwent() -> *mut passwd;
+    pub fn setgrent();
+    pub fn endgrent();
+    pub fn getgrent() -> *mut crate::group;
+    #[cfg(not(target_os = "l4re"))]
+    pub fn setspent();
+    #[cfg(not(target_os = "l4re"))]
+    pub fn endspent();
+    #[cfg(not(target_os = "l4re"))]
+    pub fn getspent() -> *mut spwd;
+
+    pub fn getspnam(name: *const c_char) -> *mut spwd;
+
+    // System V IPC
+    pub fn shmget(key: crate::key_t, size: size_t, shmflg: c_int) -> c_int;
+    pub fn shmat(shmid: c_int, shmaddr: *const c_void, shmflg: c_int) -> *mut c_void;
+    pub fn shmdt(shmaddr: *const c_void) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__shmctl64")]
+    pub fn shmctl(shmid: c_int, cmd: c_int, buf: *mut crate::shmid_ds) -> c_int;
+
+    pub fn mprotect(addr: *mut c_void, len: size_t, prot: c_int) -> c_int;
+    pub fn __errno_location() -> *mut c_int;
+
+    pub fn pthread_getaffinity_np(
+        thread: crate::pthread_t,
+        cpusetsize: size_t,
+        cpuset: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_setaffinity_np(
+        thread: crate::pthread_t,
+        cpusetsize: size_t,
+        cpuset: *const crate::cpu_set_t,
+    ) -> c_int;
+    #[cfg(not(target_env = "uclibc"))]
+    pub fn pthread_setschedprio(native: crate::pthread_t, priority: c_int) -> c_int;
+
+    // Not available now on Android
+    pub fn mremap(
+        addr: *mut c_void,
+        len: size_t,
+        new_len: size_t,
+        flags: c_int,
+        ...
+    ) -> *mut c_void;
+
+    #[cfg_attr(gnu_time_bits64, link_name = "__glob64_time64")]
+    #[cfg_attr(
+        all(not(gnu_time_bits64), gnu_file_offset_bits64),
+        link_name = "glob64"
+    )]
+    pub fn glob(
+        pattern: *const c_char,
+        flags: c_int,
+        errfunc: Option<extern "C" fn(epath: *const c_char, errno: c_int) -> c_int>,
+        pglob: *mut crate::glob_t,
+    ) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__globfree64_time64")]
+    #[cfg_attr(
+        all(not(gnu_time_bits64), gnu_file_offset_bits64),
+        link_name = "globfree64"
+    )]
+    pub fn globfree(pglob: *mut crate::glob_t);
+
+    pub fn seekdir(dirp: *mut crate::DIR, loc: c_long);
+
+    pub fn telldir(dirp: *mut crate::DIR) -> c_long;
+    pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int) -> c_int;
+
+    pub fn msync(addr: *mut c_void, len: size_t, flags: c_int) -> c_int;
+    pub fn recvfrom(
+        socket: c_int,
+        buf: *mut c_void,
+        len: size_t,
+        flags: c_int,
+        addr: *mut crate::sockaddr,
+        addrlen: *mut crate::socklen_t,
+    ) -> ssize_t;
+
+    pub fn nl_langinfo(item: crate::nl_item) -> *mut c_char;
+    pub fn nl_langinfo_l(item: crate::nl_item, locale: crate::locale_t) -> *mut c_char;
+
+    pub fn sched_getaffinity(
+        pid: crate::pid_t,
+        cpusetsize: size_t,
+        cpuset: *mut cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_getschedparam(
+        native: crate::pthread_t,
+        policy: *mut c_int,
+        param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn sched_get_priority_max(policy: c_int) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__settimeofday64")]
+    pub fn settimeofday(tv: *const crate::timeval, tz: *const crate::timezone) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__sem_timedwait64")]
+    pub fn sem_timedwait(sem: *mut crate::sem_t, abstime: *const crate::timespec) -> c_int;
+    pub fn sem_getvalue(sem: *mut crate::sem_t, sval: *mut c_int) -> c_int;
+    pub fn mount(
+        src: *const c_char,
+        target: *const c_char,
+        fstype: *const c_char,
+        flags: c_ulong,
+        data: *const c_void,
+    ) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__prctl_time64")]
+    pub fn prctl(option: c_int, ...) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__ppoll64")]
+    pub fn ppoll(
+        fds: *mut crate::pollfd,
+        nfds: nfds_t,
+        timeout: *const crate::timespec,
+        sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    #[cfg(not(target_env = "uclibc"))]
+    pub fn pthread_mutexattr_getprotocol(
+        attr: *const crate::pthread_mutexattr_t,
+        protocol: *mut c_int,
+    ) -> c_int;
+    #[cfg(not(target_env = "uclibc"))]
+    pub fn pthread_mutexattr_setprotocol(
+        attr: *mut crate::pthread_mutexattr_t,
+        protocol: c_int,
+    ) -> c_int;
+
+    #[cfg_attr(gnu_time_bits64, link_name = "__pthread_mutex_timedlock64")]
+    pub fn pthread_mutex_timedlock(
+        lock: *mut crate::pthread_mutex_t,
+        abstime: *const crate::timespec,
+    ) -> c_int;
+    pub fn pthread_barrierattr_init(attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    pub fn pthread_barrierattr_destroy(attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
+    pub fn pthread_barrierattr_getpshared(
+        attr: *const crate::pthread_barrierattr_t,
+        shared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_barrierattr_setpshared(
+        attr: *mut crate::pthread_barrierattr_t,
+        shared: c_int,
+    ) -> c_int;
+    pub fn pthread_barrier_init(
+        barrier: *mut crate::pthread_barrier_t,
+        attr: *const crate::pthread_barrierattr_t,
+        count: c_uint,
+    ) -> c_int;
+    pub fn pthread_barrier_destroy(barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_barrier_wait(barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_spin_init(lock: *mut crate::pthread_spinlock_t, pshared: c_int) -> c_int;
+    pub fn pthread_spin_destroy(lock: *mut crate::pthread_spinlock_t) -> c_int;
+    pub fn pthread_spin_lock(lock: *mut crate::pthread_spinlock_t) -> c_int;
+    pub fn pthread_spin_trylock(lock: *mut crate::pthread_spinlock_t) -> c_int;
+    pub fn pthread_spin_unlock(lock: *mut crate::pthread_spinlock_t) -> c_int;
+    pub fn pthread_attr_getguardsize(
+        attr: *const crate::pthread_attr_t,
+        guardsize: *mut size_t,
+    ) -> c_int;
+    pub fn pthread_attr_setguardsize(attr: *mut crate::pthread_attr_t, guardsize: size_t) -> c_int;
+    pub fn pthread_attr_getinheritsched(
+        attr: *const crate::pthread_attr_t,
+        inheritsched: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setinheritsched(
+        attr: *mut crate::pthread_attr_t,
+        inheritsched: c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getschedpolicy(
+        attr: *const crate::pthread_attr_t,
+        policy: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setschedpolicy(attr: *mut crate::pthread_attr_t, policy: c_int) -> c_int;
+    pub fn pthread_attr_getschedparam(
+        attr: *const crate::pthread_attr_t,
+        param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_attr_setschedparam(
+        attr: *mut crate::pthread_attr_t,
+        param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn sethostname(name: *const c_char, len: size_t) -> c_int;
+    pub fn sched_get_priority_min(policy: c_int) -> c_int;
+    pub fn pthread_condattr_getpshared(
+        attr: *const crate::pthread_condattr_t,
+        pshared: *mut c_int,
+    ) -> c_int;
+    pub fn sysinfo(info: *mut crate::sysinfo) -> c_int;
+    pub fn pthread_setschedparam(
+        native: crate::pthread_t,
+        policy: c_int,
+        param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn sigsuspend(mask: *const crate::sigset_t) -> c_int;
+    pub fn getgrgid_r(
+        gid: crate::gid_t,
+        grp: *mut crate::group,
+        buf: *mut c_char,
+        buflen: size_t,
+        result: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn sem_close(sem: *mut crate::sem_t) -> c_int;
+    pub fn getgrnam_r(
+        name: *const c_char,
+        grp: *mut crate::group,
+        buf: *mut c_char,
+        buflen: size_t,
+        result: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn initgroups(user: *const c_char, group: crate::gid_t) -> c_int;
+    pub fn pthread_sigmask(
+        how: c_int,
+        set: *const crate::sigset_t,
+        oldset: *mut crate::sigset_t,
+    ) -> c_int;
+    pub fn sem_open(name: *const c_char, oflag: c_int, ...) -> *mut crate::sem_t;
+    pub fn getgrnam(name: *const c_char) -> *mut crate::group;
+    pub fn pthread_kill(thread: crate::pthread_t, sig: c_int) -> c_int;
+    pub fn sem_unlink(name: *const c_char) -> c_int;
+    pub fn daemon(nochdir: c_int, noclose: c_int) -> c_int;
+    pub fn sigwait(set: *const crate::sigset_t, sig: *mut c_int) -> c_int;
+    pub fn getgrgid(gid: crate::gid_t) -> *mut crate::group;
+    pub fn pthread_mutexattr_getpshared(
+        attr: *const crate::pthread_mutexattr_t,
+        pshared: *mut c_int,
+    ) -> c_int;
+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut crate::FILE;
+    pub fn faccessat(dirfd: c_int, pathname: *const c_char, mode: c_int, flags: c_int) -> c_int;
+    pub fn pthread_create(
+        native: *mut crate::pthread_t,
+        attr: *const crate::pthread_attr_t,
+        f: extern "C" fn(*mut c_void) -> *mut c_void,
+        value: *mut c_void,
+    ) -> c_int;
+    pub fn dl_iterate_phdr(
+        callback: Option<
+            unsafe extern "C" fn(
+                info: *mut crate::dl_phdr_info,
+                size: size_t,
+                data: *mut c_void,
+            ) -> c_int,
+        >,
+        data: *mut c_void,
+    ) -> c_int;
+
+    pub fn setmntent(filename: *const c_char, ty: *const c_char) -> *mut crate::FILE;
+    pub fn getmntent(stream: *mut crate::FILE) -> *mut crate::mntent;
+    pub fn addmntent(stream: *mut crate::FILE, mnt: *const crate::mntent) -> c_int;
+    pub fn endmntent(streamp: *mut crate::FILE) -> c_int;
+    pub fn hasmntopt(mnt: *const crate::mntent, opt: *const c_char) -> *mut c_char;
+
+    pub fn regcomp(preg: *mut crate::regex_t, pattern: *const c_char, cflags: c_int) -> c_int;
+
+    pub fn regexec(
+        preg: *const crate::regex_t,
+        input: *const c_char,
+        nmatch: size_t,
+        pmatch: *mut regmatch_t,
+        eflags: c_int,
+    ) -> c_int;
+
+    pub fn regerror(
+        errcode: c_int,
+        preg: *const crate::regex_t,
+        errbuf: *mut c_char,
+        errbuf_size: size_t,
+    ) -> size_t;
+
+    pub fn regfree(preg: *mut crate::regex_t);
+
+    pub fn iconv_open(tocode: *const c_char, fromcode: *const c_char) -> iconv_t;
+    pub fn iconv(
+        cd: iconv_t,
+        inbuf: *mut *mut c_char,
+        inbytesleft: *mut size_t,
+        outbuf: *mut *mut c_char,
+        outbytesleft: *mut size_t,
+    ) -> size_t;
+    pub fn iconv_close(cd: iconv_t) -> c_int;
+
+    pub fn gettid() -> crate::pid_t;
+
+    pub fn timer_create(
+        clockid: crate::clockid_t,
+        sevp: *mut crate::sigevent,
+        timerid: *mut crate::timer_t,
+    ) -> c_int;
+    pub fn timer_delete(timerid: crate::timer_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
+    pub fn timer_getoverrun(timerid: crate::timer_t) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__timer_gettime64")]
+    pub fn timer_gettime(timerid: crate::timer_t, curr_value: *mut crate::itimerspec) -> c_int;
+    #[cfg_attr(gnu_time_bits64, link_name = "__timer_settime64")]
+    pub fn timer_settime(
+        timerid: crate::timer_t,
+        flags: c_int,
+        new_value: *const crate::itimerspec,
+        old_value: *mut crate::itimerspec,
+    ) -> c_int;
+
+    pub fn memmem(
+        haystack: *const c_void,
+        haystacklen: size_t,
+        needle: *const c_void,
+        needlelen: size_t,
+    ) -> *mut c_void;
+    pub fn sched_getcpu() -> c_int;
+
+    pub fn getopt_long(
+        argc: c_int,
+        argv: *const *mut c_char,
+        optstring: *const c_char,
+        longopts: *const option,
+        longindex: *mut c_int,
+    ) -> c_int;
+
+    pub fn pthread_once(control: *mut pthread_once_t, routine: extern "C" fn()) -> c_int;
+
+    #[cfg(not(target_env = "uclibc"))]
+    pub fn copy_file_range(
+        fd_in: c_int,
+        off_in: *mut off64_t,
+        fd_out: c_int,
+        off_out: *mut off64_t,
+        len: size_t,
+        flags: c_uint,
+    ) -> ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(not(target_env = "musl"))] {
+        extern "C" {
+            pub fn freopen64(
+                filename: *const c_char,
+                mode: *const c_char,
+                file: *mut crate::FILE,
+            ) -> *mut crate::FILE;
+            pub fn fseeko64(stream: *mut crate::FILE, offset: off64_t, whence: c_int) -> c_int;
+            pub fn fsetpos64(stream: *mut crate::FILE, ptr: *const crate::fpos64_t) -> c_int;
+            pub fn ftello64(stream: *mut crate::FILE) -> off64_t;
+        }
+    }
+}
diff --git a/src/unix/linux_like/mod.rs b/src/unix/linux_like/mod.rs
index 80fa9c176..c22b718ca 100644
--- a/src/unix/linux_like/mod.rs
+++ b/src/unix/linux_like/mod.rs
@@ -5,6 +5,7 @@ pub type speed_t = c_uint;
 pub type tcflag_t = c_uint;
 pub type clockid_t = c_int;
 pub type timer_t = *mut c_void;
+pub type useconds_t = u32;
 pub type key_t = c_int;
 pub type id_t = c_uint;
 
@@ -71,7 +72,7 @@ s! {
         pub ai_protocol: c_int,
         pub ai_addrlen: socklen_t,
 
-        #[cfg(any(target_os = "linux", target_os = "emscripten"))]
+        #[cfg(not(target_os = "android"))]
         pub ai_addr: *mut crate::sockaddr,
 
         pub ai_canonname: *mut c_char,
@@ -212,10 +213,95 @@ s! {
         pub msg_hdr: crate::msghdr,
         pub msg_len: c_uint,
     }
+
+    pub struct if_nameindex {
+        pub if_index: c_uint,
+        pub if_name: *mut c_char,
+    }
+
+    #[cfg_attr(
+        any(
+            target_pointer_width = "32",
+            target_arch = "x86_64",
+            target_arch = "powerpc64",
+            target_arch = "mips64",
+            target_arch = "mips64r6",
+            target_arch = "s390x",
+            target_arch = "sparc64",
+            target_arch = "aarch64",
+            target_arch = "riscv64",
+            target_arch = "riscv32",
+            target_arch = "loongarch64",
+            target_os = "emscripten"
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        not(any(
+            target_pointer_width = "32",
+            target_arch = "x86_64",
+            target_arch = "powerpc64",
+            target_arch = "mips64",
+            target_arch = "mips64r6",
+            target_arch = "s390x",
+            target_arch = "sparc64",
+            target_arch = "aarch64",
+            target_arch = "riscv64",
+            target_arch = "riscv32",
+            target_arch = "loongarch64",
+            target_os = "emscripten"
+        )),
+        repr(align(8))
+    )]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_mutexattr_t {
+        #[doc(hidden)]
+        size: [u8; crate::__SIZEOF_PTHREAD_MUTEXATTR_T],
+    }
+
+    #[cfg_attr(
+        any(
+            target_env = "musl",
+            target_env = "ohos",
+            target_env = "uclibc",
+            target_os = "emscripten",
+            target_pointer_width = "32"
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        all(
+            not(target_env = "musl"),
+            not(target_env = "ohos"),
+            not(target_env = "uclibc"),
+            not(target_os = "emscripten"),
+            target_pointer_width = "64"
+        ),
+        repr(align(8))
+    )]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_rwlockattr_t {
+        #[doc(hidden)]
+        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCKATTR_T],
+    }
+
+    #[repr(align(4))]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_condattr_t {
+        #[doc(hidden)]
+        size: [u8; crate::__SIZEOF_PTHREAD_CONDATTR_T],
+    }
+
+    #[repr(align(4))]
+    #[cfg(not(any(target_os = "android", target_os = "emscripten")))]
+    pub struct pthread_barrierattr_t {
+        #[doc(hidden)]
+        size: [u8; crate::__SIZEOF_PTHREAD_BARRIERATTR_T],
+    }
 }
 
 cfg_if! {
-    if #[cfg(not(target_os = "emscripten"))] {
+    if #[cfg(not(any(target_os = "emscripten", target_os = "l4re")))] {
         s! {
             pub struct file_clone_range {
                 pub src_fd: crate::__s64,
@@ -284,22 +370,6 @@ cfg_if! {
 }
 
 s_no_extra_traits! {
-    #[cfg_attr(
-        any(target_arch = "x86_64", all(target_arch = "x86", target_env = "gnu")),
-        repr(packed)
-    )]
-    pub struct epoll_event {
-        pub events: u32,
-        pub data: epoll_data,
-    }
-
-    pub union epoll_data {
-        pub ptr: *mut c_void,
-        pub fd: c_int,
-        pub u32: u32,
-        pub u64: u64,
-    }
-
     pub union __c_anonymous_sigev_un {
         _pad: [c_int; SIGEV_PAD_SIZE],
         pub _tid: c_int,
@@ -340,37 +410,193 @@ s_no_extra_traits! {
         ifu_broadaddr: *mut sockaddr,
         ifu_dstaddr: *mut sockaddr,
     }
+
+    #[cfg_attr(
+        all(
+            any(target_env = "musl", target_env = "ohos", target_os = "emscripten"),
+            target_pointer_width = "32"
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        all(
+            any(target_env = "musl", target_env = "ohos", target_os = "emscripten"),
+            target_pointer_width = "64"
+        ),
+        repr(align(8))
+    )]
+    #[cfg_attr(
+        all(
+            not(any(target_env = "musl", target_env = "ohos", target_os = "emscripten")),
+            target_arch = "x86"
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        all(
+            not(any(target_env = "musl", target_env = "ohos", target_os = "emscripten")),
+            not(target_arch = "x86")
+        ),
+        repr(align(8))
+    )]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_cond_t {
+        #[doc(hidden)]
+        size: [u8; crate::__SIZEOF_PTHREAD_COND_T],
+    }
+
+    #[cfg_attr(
+        all(
+            target_pointer_width = "32",
+            any(
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "csky",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86",
+                target_os = "emscripten",
+            )
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        any(
+            target_pointer_width = "64",
+            not(any(
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "csky",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86",
+                target_os = "emscripten",
+            ))
+        ),
+        repr(align(8))
+    )]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_mutex_t {
+        #[doc(hidden)]
+        size: [c_char; crate::__SIZEOF_PTHREAD_MUTEX_T],
+    }
+
+    #[cfg_attr(
+        all(
+            target_pointer_width = "32",
+            any(
+                target_os = "emscripten",
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "csky",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86"
+            )
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        any(
+            target_pointer_width = "64",
+            not(any(
+                target_os = "emscripten",
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86"
+            ))
+        ),
+        repr(align(8))
+    )]
+    #[cfg(not(target_os = "android"))]
+    pub struct pthread_rwlock_t {
+        size: [u8; crate::__SIZEOF_PTHREAD_RWLOCK_T],
+    }
+
+    #[cfg_attr(
+        all(
+            target_pointer_width = "32",
+            any(
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "csky",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86"
+            )
+        ),
+        repr(align(4))
+    )]
+    #[cfg_attr(
+        any(
+            target_pointer_width = "64",
+            not(any(
+                target_arch = "mips",
+                target_arch = "mips32r6",
+                target_arch = "arm",
+                target_arch = "hexagon",
+                target_arch = "m68k",
+                target_arch = "csky",
+                target_arch = "powerpc",
+                target_arch = "sparc",
+                target_arch = "x86_64",
+                target_arch = "x86"
+            ))
+        ),
+        repr(align(8))
+    )]
+    #[cfg(not(any(target_os = "android", target_os = "emscripten")))]
+    pub struct pthread_barrier_t {
+        size: [u8; crate::__SIZEOF_PTHREAD_BARRIER_T],
+    }
 }
 
 cfg_if! {
-    if #[cfg(feature = "extra_traits")] {
-        impl PartialEq for epoll_event {
-            fn eq(&self, _other: &epoll_event) -> bool {
-                unimplemented!("traits")
+    if #[cfg(not(target_os = "l4re"))] {
+        s_no_extra_traits! {
+            #[cfg_attr(
+                any(target_arch = "x86_64", all(target_arch = "x86", target_env = "gnu")),
+                repr(packed)
+            )]
+            pub struct epoll_event {
+                pub events: u32,
+                pub data: epoll_data,
             }
-        }
-        impl Eq for epoll_event {}
-        impl hash::Hash for epoll_event {
-            fn hash<H: hash::Hasher>(&self, state: &mut H) {
-                let events = self.events;
-                let data = self.data;
-                events.hash(state);
-                data.hash(state);
-            }
-        }
 
-        impl PartialEq for epoll_data {
-            fn eq(&self, _other: &epoll_data) -> bool {
-                unimplemented!("traits")
-            }
-        }
-        impl Eq for epoll_data {}
-        impl hash::Hash for epoll_data {
-            fn hash<H: hash::Hasher>(&self, _state: &mut H) {
-                unimplemented!("traits")
+            pub union epoll_data {
+                pub ptr: *mut c_void,
+                pub fd: c_int,
+                pub u32: u32,
+                pub u64: u64,
             }
         }
+    }
+}
 
+cfg_if! {
+    if #[cfg(feature = "extra_traits")] {
         impl PartialEq for sockaddr_un {
             fn eq(&self, other: &sockaddr_un) -> bool {
                 self.sun_family == other.sun_family
@@ -392,6 +618,7 @@ cfg_if! {
         impl PartialEq for sockaddr_storage {
             fn eq(&self, other: &sockaddr_storage) -> bool {
                 self.ss_family == other.ss_family
+                    && self.__ss_align == other.__ss_align
                     && self
                         .__ss_pad2
                         .iter()
@@ -399,9 +626,7 @@ cfg_if! {
                         .all(|(a, b)| a == b)
             }
         }
-
         impl Eq for sockaddr_storage {}
-
         impl hash::Hash for sockaddr_storage {
             fn hash<H: hash::Hasher>(&self, state: &mut H) {
                 self.ss_family.hash(state);
@@ -442,9 +667,7 @@ cfg_if! {
                         .all(|(a, b)| a == b)
             }
         }
-
         impl Eq for utsname {}
-
         impl hash::Hash for utsname {
             fn hash<H: hash::Hasher>(&self, state: &mut H) {
                 self.sysname.hash(state);
@@ -467,6 +690,156 @@ cfg_if! {
                 unimplemented!("traits")
             }
         }
+
+        impl PartialEq for dirent {
+            fn eq(&self, other: &dirent) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                        .d_name
+                        .iter()
+                        .zip(other.d_name.iter())
+                        .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for dirent {}
+        impl hash::Hash for dirent {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(feature = "extra_traits", not(target_os = "l4re")))] {
+        impl PartialEq for epoll_event {
+            fn eq(&self, _other: &epoll_event) -> bool {
+                unimplemented!("traits")
+            }
+        }
+        impl Eq for epoll_event {}
+        impl hash::Hash for epoll_event {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                let events = self.events;
+                let data = self.data;
+                events.hash(state);
+                data.hash(state);
+            }
+        }
+
+        impl PartialEq for epoll_data {
+            fn eq(&self, _other: &epoll_data) -> bool {
+                unimplemented!("traits")
+            }
+        }
+        impl Eq for epoll_data {}
+        impl hash::Hash for epoll_data {
+            fn hash<H: hash::Hasher>(&self, _state: &mut H) {
+                unimplemented!("traits")
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(feature = "extra_traits", not(target_os = "emscripten")))] {
+        impl PartialEq for dirent64 {
+            fn eq(&self, other: &dirent64) -> bool {
+                self.d_ino == other.d_ino
+                    && self.d_off == other.d_off
+                    && self.d_reclen == other.d_reclen
+                    && self.d_type == other.d_type
+                    && self
+                        .d_name
+                        .iter()
+                        .zip(other.d_name.iter())
+                        .all(|(a, b)| a == b)
+            }
+        }
+        impl Eq for dirent64 {}
+        impl hash::Hash for dirent64 {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.d_ino.hash(state);
+                self.d_off.hash(state);
+                self.d_reclen.hash(state);
+                self.d_type.hash(state);
+                self.d_name.hash(state);
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(feature = "extra_traits", not(target_os = "android")))] {
+        impl PartialEq for pthread_cond_t {
+            fn eq(&self, other: &pthread_cond_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_cond_t {}
+
+        impl hash::Hash for pthread_cond_t {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_mutex_t {
+            fn eq(&self, other: &pthread_mutex_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_mutex_t {}
+
+        impl hash::Hash for pthread_mutex_t {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+
+        impl PartialEq for pthread_rwlock_t {
+            fn eq(&self, other: &pthread_rwlock_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_rwlock_t {}
+
+        impl hash::Hash for pthread_rwlock_t {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(all(
+        feature = "extra_traits",
+        not(any(target_os = "android", target_os = "emscripten"))
+    ))] {
+        impl PartialEq for pthread_barrier_t {
+            fn eq(&self, other: &pthread_barrier_t) -> bool {
+                self.size.iter().zip(other.size.iter()).all(|(a, b)| a == b)
+            }
+        }
+
+        impl Eq for pthread_barrier_t {}
+
+        impl hash::Hash for pthread_barrier_t {
+            fn hash<H: hash::Hasher>(&self, state: &mut H) {
+                self.size.hash(state);
+            }
+        }
     }
 }
 
@@ -481,6 +854,19 @@ cfg_if! {
     }
 }
 
+#[cfg(not(target_os = "android"))]
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+    size: [0; crate::__SIZEOF_PTHREAD_MUTEX_T],
+};
+#[cfg(not(target_os = "android"))]
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+    size: [0; crate::__SIZEOF_PTHREAD_COND_T],
+};
+#[cfg(not(any(target_os = "android", target_env = "uclibc")))]
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+    size: [0; crate::__SIZEOF_PTHREAD_RWLOCK_T],
+};
+
 pub const EXIT_FAILURE: c_int = 1;
 pub const EXIT_SUCCESS: c_int = 0;
 pub const RAND_MAX: c_int = 2147483647;
@@ -596,7 +982,9 @@ pub const PROT_READ: c_int = 1;
 pub const PROT_WRITE: c_int = 2;
 pub const PROT_EXEC: c_int = 4;
 
+#[cfg(not(target_os = "l4re"))]
 pub const XATTR_CREATE: c_int = 0x1;
+#[cfg(not(target_os = "l4re"))]
 pub const XATTR_REPLACE: c_int = 0x2;
 
 cfg_if! {
@@ -708,11 +1096,13 @@ pub const MADV_DONTDUMP: c_int = 16;
 pub const MADV_DODUMP: c_int = 17;
 pub const MADV_WIPEONFORK: c_int = 18;
 pub const MADV_KEEPONFORK: c_int = 19;
+#[cfg(not(target_os = "l4re"))]
 pub const MADV_COLD: c_int = 20;
+#[cfg(not(target_os = "l4re"))]
 pub const MADV_PAGEOUT: c_int = 21;
 pub const MADV_HWPOISON: c_int = 100;
 cfg_if! {
-    if #[cfg(not(target_os = "emscripten"))] {
+    if #[cfg(not(any(target_os = "emscripten", target_os = "l4re")))] {
         pub const MADV_POPULATE_READ: c_int = 22;
         pub const MADV_POPULATE_WRITE: c_int = 23;
         pub const MADV_DONTNEED_LOCKED: c_int = 24;
@@ -881,8 +1271,11 @@ pub const IP_TRANSPARENT: c_int = 19;
 pub const IP_ORIGDSTADDR: c_int = 20;
 pub const IP_RECVORIGDSTADDR: c_int = IP_ORIGDSTADDR;
 pub const IP_MINTTL: c_int = 21;
+#[cfg(not(target_env = "uclibc"))]
 pub const IP_NODEFRAG: c_int = 22;
+#[cfg(not(target_env = "uclibc"))]
 pub const IP_CHECKSUM: c_int = 23;
+#[cfg(not(target_env = "uclibc"))]
 pub const IP_BIND_ADDRESS_NO_PORT: c_int = 24;
 pub const IP_MULTICAST_IF: c_int = 32;
 pub const IP_MULTICAST_TTL: c_int = 33;
@@ -904,7 +1297,9 @@ pub const IP_PMTUDISC_DONT: c_int = 0;
 pub const IP_PMTUDISC_WANT: c_int = 1;
 pub const IP_PMTUDISC_DO: c_int = 2;
 pub const IP_PMTUDISC_PROBE: c_int = 3;
+#[cfg(not(target_env = "uclibc"))]
 pub const IP_PMTUDISC_INTERFACE: c_int = 4;
+#[cfg(not(target_env = "uclibc"))]
 pub const IP_PMTUDISC_OMIT: c_int = 5;
 
 // IPPROTO_IP defined in src/unix/mod.rs
@@ -1012,25 +1407,32 @@ pub const IPV6_RECVRTHDR: c_int = 56;
 pub const IPV6_RTHDR: c_int = 57;
 pub const IPV6_RECVDSTOPTS: c_int = 58;
 pub const IPV6_DSTOPTS: c_int = 59;
+#[cfg(not(target_env = "uclibc"))]
 pub const IPV6_RECVPATHMTU: c_int = 60;
+#[cfg(not(target_env = "uclibc"))]
 pub const IPV6_PATHMTU: c_int = 61;
+#[cfg(not(target_env = "uclibc"))]
 pub const IPV6_DONTFRAG: c_int = 62;
 pub const IPV6_RECVTCLASS: c_int = 66;
 pub const IPV6_TCLASS: c_int = 67;
-pub const IPV6_AUTOFLOWLABEL: c_int = 70;
-pub const IPV6_ADDR_PREFERENCES: c_int = 72;
-pub const IPV6_MINHOPCOUNT: c_int = 73;
-pub const IPV6_ORIGDSTADDR: c_int = 74;
-pub const IPV6_RECVORIGDSTADDR: c_int = IPV6_ORIGDSTADDR;
-pub const IPV6_TRANSPARENT: c_int = 75;
-pub const IPV6_UNICAST_IF: c_int = 76;
-pub const IPV6_PREFER_SRC_TMP: c_int = 0x0001;
-pub const IPV6_PREFER_SRC_PUBLIC: c_int = 0x0002;
-pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: c_int = 0x0100;
-pub const IPV6_PREFER_SRC_COA: c_int = 0x0004;
-pub const IPV6_PREFER_SRC_HOME: c_int = 0x0400;
-pub const IPV6_PREFER_SRC_CGA: c_int = 0x0008;
-pub const IPV6_PREFER_SRC_NONCGA: c_int = 0x0800;
+cfg_if! {
+    if #[cfg(not(target_env = "uclibc"))] {
+        pub const IPV6_AUTOFLOWLABEL: c_int = 70;
+        pub const IPV6_ADDR_PREFERENCES: c_int = 72;
+        pub const IPV6_MINHOPCOUNT: c_int = 73;
+        pub const IPV6_ORIGDSTADDR: c_int = 74;
+        pub const IPV6_RECVORIGDSTADDR: c_int = IPV6_ORIGDSTADDR;
+        pub const IPV6_TRANSPARENT: c_int = 75;
+        pub const IPV6_UNICAST_IF: c_int = 76;
+        pub const IPV6_PREFER_SRC_TMP: c_int = 0x0001;
+        pub const IPV6_PREFER_SRC_PUBLIC: c_int = 0x0002;
+        pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: c_int = 0x0100;
+        pub const IPV6_PREFER_SRC_COA: c_int = 0x0004;
+        pub const IPV6_PREFER_SRC_HOME: c_int = 0x0400;
+        pub const IPV6_PREFER_SRC_CGA: c_int = 0x0008;
+        pub const IPV6_PREFER_SRC_NONCGA: c_int = 0x0800;
+    }
+}
 
 pub const IPV6_PMTUDISC_DONT: c_int = 0;
 pub const IPV6_PMTUDISC_WANT: c_int = 1;
@@ -1139,25 +1541,29 @@ pub const MNT_DETACH: c_int = 0x2;
 pub const MNT_EXPIRE: c_int = 0x4;
 pub const UMOUNT_NOFOLLOW: c_int = 0x8;
 
-pub const Q_GETFMT: c_int = 0x800004;
-pub const Q_GETINFO: c_int = 0x800005;
-pub const Q_SETINFO: c_int = 0x800006;
-pub const QIF_BLIMITS: u32 = 1;
-pub const QIF_SPACE: u32 = 2;
-pub const QIF_ILIMITS: u32 = 4;
-pub const QIF_INODES: u32 = 8;
-pub const QIF_BTIME: u32 = 16;
-pub const QIF_ITIME: u32 = 32;
-pub const QIF_LIMITS: u32 = 5;
-pub const QIF_USAGE: u32 = 10;
-pub const QIF_TIMES: u32 = 48;
-pub const QIF_ALL: u32 = 63;
-
-pub const Q_SYNC: c_int = 0x800001;
-pub const Q_QUOTAON: c_int = 0x800002;
-pub const Q_QUOTAOFF: c_int = 0x800003;
-pub const Q_GETQUOTA: c_int = 0x800007;
-pub const Q_SETQUOTA: c_int = 0x800008;
+cfg_if! {
+    if #[cfg(not(target_os = "l4re"))] {
+        pub const Q_GETFMT: c_int = 0x800004;
+        pub const Q_GETINFO: c_int = 0x800005;
+        pub const Q_SETINFO: c_int = 0x800006;
+        pub const QIF_BLIMITS: u32 = 1;
+        pub const QIF_SPACE: u32 = 2;
+        pub const QIF_ILIMITS: u32 = 4;
+        pub const QIF_INODES: u32 = 8;
+        pub const QIF_BTIME: u32 = 16;
+        pub const QIF_ITIME: u32 = 32;
+        pub const QIF_LIMITS: u32 = 5;
+        pub const QIF_USAGE: u32 = 10;
+        pub const QIF_TIMES: u32 = 48;
+        pub const QIF_ALL: u32 = 63;
+
+        pub const Q_SYNC: c_int = 0x800001;
+        pub const Q_QUOTAON: c_int = 0x800002;
+        pub const Q_QUOTAOFF: c_int = 0x800003;
+        pub const Q_GETQUOTA: c_int = 0x800007;
+        pub const Q_SETQUOTA: c_int = 0x800008;
+    }
+}
 
 pub const TCIOFF: c_int = 2;
 pub const TCION: c_int = 3;
@@ -1199,11 +1605,13 @@ pub const ONLRET: crate::tcflag_t = 0o000040;
 pub const OFILL: crate::tcflag_t = 0o000100;
 pub const OFDEL: crate::tcflag_t = 0o000200;
 
+#[cfg(not(target_os = "l4re"))]
 pub const CLONE_NEWTIME: c_int = 0x80;
 pub const CLONE_VM: c_int = 0x100;
 pub const CLONE_FS: c_int = 0x200;
 pub const CLONE_FILES: c_int = 0x400;
 pub const CLONE_SIGHAND: c_int = 0x800;
+#[cfg(not(target_os = "l4re"))]
 pub const CLONE_PIDFD: c_int = 0x1000;
 pub const CLONE_PTRACE: c_int = 0x2000;
 pub const CLONE_VFORK: c_int = 0x4000;
@@ -1217,6 +1625,7 @@ pub const CLONE_CHILD_CLEARTID: c_int = 0x200000;
 pub const CLONE_DETACHED: c_int = 0x400000;
 pub const CLONE_UNTRACED: c_int = 0x800000;
 pub const CLONE_CHILD_SETTID: c_int = 0x01000000;
+#[cfg(not(target_os = "l4re"))]
 pub const CLONE_NEWCGROUP: c_int = 0x02000000;
 pub const CLONE_NEWUTS: c_int = 0x04000000;
 pub const CLONE_NEWIPC: c_int = 0x08000000;
@@ -1232,47 +1641,55 @@ pub const WEXITED: c_int = 0x00000004;
 pub const WCONTINUED: c_int = 0x00000008;
 pub const WNOWAIT: c_int = 0x01000000;
 
-// Options for personality(2).
-pub const ADDR_NO_RANDOMIZE: c_int = 0x0040000;
-pub const MMAP_PAGE_ZERO: c_int = 0x0100000;
-pub const ADDR_COMPAT_LAYOUT: c_int = 0x0200000;
-pub const READ_IMPLIES_EXEC: c_int = 0x0400000;
-pub const ADDR_LIMIT_32BIT: c_int = 0x0800000;
-pub const SHORT_INODE: c_int = 0x1000000;
-pub const WHOLE_SECONDS: c_int = 0x2000000;
-pub const STICKY_TIMEOUTS: c_int = 0x4000000;
-pub const ADDR_LIMIT_3GB: c_int = 0x8000000;
-
-// Options set using PTRACE_SETOPTIONS.
-pub const PTRACE_O_TRACESYSGOOD: c_int = 0x00000001;
-pub const PTRACE_O_TRACEFORK: c_int = 0x00000002;
-pub const PTRACE_O_TRACEVFORK: c_int = 0x00000004;
-pub const PTRACE_O_TRACECLONE: c_int = 0x00000008;
-pub const PTRACE_O_TRACEEXEC: c_int = 0x00000010;
-pub const PTRACE_O_TRACEVFORKDONE: c_int = 0x00000020;
-pub const PTRACE_O_TRACEEXIT: c_int = 0x00000040;
-pub const PTRACE_O_TRACESECCOMP: c_int = 0x00000080;
-pub const PTRACE_O_SUSPEND_SECCOMP: c_int = 0x00200000;
-pub const PTRACE_O_EXITKILL: c_int = 0x00100000;
-pub const PTRACE_O_MASK: c_int = 0x003000ff;
-
-// Wait extended result codes for the above trace options.
-pub const PTRACE_EVENT_FORK: c_int = 1;
-pub const PTRACE_EVENT_VFORK: c_int = 2;
-pub const PTRACE_EVENT_CLONE: c_int = 3;
-pub const PTRACE_EVENT_EXEC: c_int = 4;
-pub const PTRACE_EVENT_VFORK_DONE: c_int = 5;
-pub const PTRACE_EVENT_EXIT: c_int = 6;
-pub const PTRACE_EVENT_SECCOMP: c_int = 7;
+cfg_if! {
+    if #[cfg(not(target_os = "l4re"))] {
+        // Options for personality(2).
+        pub const ADDR_NO_RANDOMIZE: c_int = 0x0040000;
+        pub const MMAP_PAGE_ZERO: c_int = 0x0100000;
+        pub const ADDR_COMPAT_LAYOUT: c_int = 0x0200000;
+        pub const READ_IMPLIES_EXEC: c_int = 0x0400000;
+        pub const ADDR_LIMIT_32BIT: c_int = 0x0800000;
+        pub const SHORT_INODE: c_int = 0x1000000;
+        pub const WHOLE_SECONDS: c_int = 0x2000000;
+        pub const STICKY_TIMEOUTS: c_int = 0x4000000;
+        pub const ADDR_LIMIT_3GB: c_int = 0x8000000;
+
+        // Options set using PTRACE_SETOPTIONS.
+        pub const PTRACE_O_TRACESYSGOOD: c_int = 0x00000001;
+        pub const PTRACE_O_TRACEFORK: c_int = 0x00000002;
+        pub const PTRACE_O_TRACEVFORK: c_int = 0x00000004;
+        pub const PTRACE_O_TRACECLONE: c_int = 0x00000008;
+        pub const PTRACE_O_TRACEEXEC: c_int = 0x00000010;
+        pub const PTRACE_O_TRACEVFORKDONE: c_int = 0x00000020;
+        pub const PTRACE_O_TRACEEXIT: c_int = 0x00000040;
+        pub const PTRACE_O_TRACESECCOMP: c_int = 0x00000080;
+        pub const PTRACE_O_SUSPEND_SECCOMP: c_int = 0x00200000;
+        pub const PTRACE_O_EXITKILL: c_int = 0x00100000;
+        pub const PTRACE_O_MASK: c_int = 0x003000ff;
+
+        // Wait extended result codes for the above trace options.
+        pub const PTRACE_EVENT_FORK: c_int = 1;
+        pub const PTRACE_EVENT_VFORK: c_int = 2;
+        pub const PTRACE_EVENT_CLONE: c_int = 3;
+        pub const PTRACE_EVENT_EXEC: c_int = 4;
+        pub const PTRACE_EVENT_VFORK_DONE: c_int = 5;
+        pub const PTRACE_EVENT_EXIT: c_int = 6;
+        pub const PTRACE_EVENT_SECCOMP: c_int = 7;
+    }
+}
 
 pub const __WNOTHREAD: c_int = 0x20000000;
 pub const __WALL: c_int = 0x40000000;
 pub const __WCLONE: c_int = 0x80000000;
 
-pub const SPLICE_F_MOVE: c_uint = 0x01;
-pub const SPLICE_F_NONBLOCK: c_uint = 0x02;
-pub const SPLICE_F_MORE: c_uint = 0x04;
-pub const SPLICE_F_GIFT: c_uint = 0x08;
+cfg_if! {
+    if #[cfg(not(target_env = "uclibc"))] {
+        pub const SPLICE_F_MOVE: c_uint = 0x01;
+        pub const SPLICE_F_NONBLOCK: c_uint = 0x02;
+        pub const SPLICE_F_MORE: c_uint = 0x04;
+        pub const SPLICE_F_GIFT: c_uint = 0x08;
+    }
+}
 
 pub const RTLD_LOCAL: c_int = 0;
 pub const RTLD_LAZY: c_int = 1;
@@ -1295,6 +1712,7 @@ pub const LOG_AUTHPRIV: c_int = 10 << 3;
 pub const LOG_FTP: c_int = 11 << 3;
 pub const LOG_PERROR: c_int = 0x20;
 
+#[cfg(not(target_os = "l4re"))]
 pub const PIPE_BUF: usize = 4096;
 
 pub const SI_LOAD_SHIFT: c_uint = 16;
@@ -1327,14 +1745,19 @@ pub const BUS_ADRALN: c_int = 1;
 pub const BUS_ADRERR: c_int = 2;
 pub const BUS_OBJERR: c_int = 3;
 // Linux-specific si_code values for SIGBUS signal
+#[cfg(not(target_os = "l4re"))]
 pub const BUS_MCEERR_AR: c_int = 4;
+#[cfg(not(target_os = "l4re"))]
 pub const BUS_MCEERR_AO: c_int = 5;
 
 // si_code values for SIGTRAP
 pub const TRAP_BRKPT: c_int = 1;
 pub const TRAP_TRACE: c_int = 2;
+#[cfg(not(target_os = "l4re"))]
 pub const TRAP_BRANCH: c_int = 3;
+#[cfg(not(target_os = "l4re"))]
 pub const TRAP_HWBKPT: c_int = 4;
+#[cfg(not(target_os = "l4re"))]
 pub const TRAP_UNK: c_int = 5;
 
 // si_code values for SIGCHLD signal
@@ -1497,7 +1920,7 @@ pub const ARPHRD_VOID: u16 = 0xFFFF;
 pub const ARPHRD_NONE: u16 = 0xFFFE;
 
 cfg_if! {
-    if #[cfg(not(target_os = "emscripten"))] {
+    if #[cfg(not(any(target_os = "emscripten", target_os = "l4re")))] {
         // linux/if_tun.h
         /* TUNSETIFF ifr flags */
         pub const IFF_TUN: c_int = 0x0001;
@@ -1584,7 +2007,7 @@ cfg_if! {
 }
 
 cfg_if! {
-    if #[cfg(target_os = "emscripten")] {
+    if #[cfg(any(target_os = "emscripten", target_os = "l4re"))] {
         // Emscripten does not define any `*_SUPER_MAGIC` constants.
     } else if #[cfg(not(target_arch = "s390x"))] {
         pub const ADFS_SUPER_MAGIC: c_long = 0x0000adf5;
@@ -1701,7 +2124,8 @@ cfg_if! {
     if #[cfg(any(
         target_env = "gnu",
         target_os = "android",
-        all(target_env = "musl", musl_v1_2_3)
+        all(target_env = "musl", musl_v1_2_3),
+        target_os = "l4re"
     ))] {
         pub const AT_STATX_SYNC_TYPE: c_int = 0x6000;
         pub const AT_STATX_SYNC_AS_STAT: c_int = 0x0000;
@@ -1957,6 +2381,7 @@ extern "C" {
     pub fn sem_destroy(sem: *mut sem_t) -> c_int;
     pub fn sem_init(sem: *mut sem_t, pshared: c_int, value: c_uint) -> c_int;
     pub fn fdatasync(fd: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar) -> c_int;
 
     #[cfg_attr(gnu_time_bits64, link_name = "__clock_getres64")]
@@ -1965,6 +2390,7 @@ extern "C" {
     pub fn clock_gettime(clk_id: crate::clockid_t, tp: *mut crate::timespec) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__clock_settime64")]
     pub fn clock_settime(clk_id: crate::clockid_t, tp: *const crate::timespec) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn clock_getcpuclockid(pid: crate::pid_t, clk_id: *mut crate::clockid_t) -> c_int;
 
     pub fn dirfd(dirp: *mut crate::DIR) -> c_int;
@@ -1982,6 +2408,7 @@ extern "C" {
     ) -> c_int;
     pub fn memalign(align: size_t, size: size_t) -> *mut c_void;
     pub fn setgroups(ngroups: size_t, ptr: *const crate::gid_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn pipe2(fds: *mut c_int, flags: c_int) -> c_int;
     #[cfg_attr(gnu_file_offset_bits64, link_name = "statfs64")]
     pub fn statfs(path: *const c_char, buf: *mut statfs) -> c_int;
@@ -1991,6 +2418,7 @@ extern "C" {
     #[cfg_attr(gnu_file_offset_bits64, link_name = "posix_fadvise64")]
     pub fn posix_fadvise(fd: c_int, offset: off_t, len: off_t, advise: c_int) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__futimens64")]
+    #[cfg(not(target_os = "l4re"))]
     pub fn futimens(fd: c_int, times: *const crate::timespec) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__utimensat64")]
     pub fn utimensat(
@@ -1999,15 +2427,19 @@ extern "C" {
         times: *const crate::timespec,
         flag: c_int,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn duplocale(base: crate::locale_t) -> crate::locale_t;
     pub fn freelocale(loc: crate::locale_t);
     pub fn newlocale(mask: c_int, locale: *const c_char, base: crate::locale_t) -> crate::locale_t;
     pub fn uselocale(loc: crate::locale_t) -> crate::locale_t;
+    #[cfg(not(target_os = "l4re"))]
     pub fn mknodat(dirfd: c_int, pathname: *const c_char, mode: mode_t, dev: dev_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn pthread_condattr_getclock(
         attr: *const pthread_condattr_t,
         clock_id: *mut clockid_t,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn pthread_condattr_setclock(
         attr: *mut pthread_condattr_t,
         clock_id: crate::clockid_t,
@@ -2019,44 +2451,59 @@ extern "C" {
         val: *mut c_int,
     ) -> c_int;
     pub fn pthread_rwlockattr_setpshared(attr: *mut pthread_rwlockattr_t, val: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn ptsname_r(fd: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
     pub fn clearenv() -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn waitid(
         idtype: idtype_t,
         id: id_t,
         infop: *mut crate::siginfo_t,
         options: c_int,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn getresuid(
         ruid: *mut crate::uid_t,
         euid: *mut crate::uid_t,
         suid: *mut crate::uid_t,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn getresgid(
         rgid: *mut crate::gid_t,
         egid: *mut crate::gid_t,
         sgid: *mut crate::gid_t,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn acct(filename: *const c_char) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn brk(addr: *mut c_void) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn sbrk(increment: intptr_t) -> *mut c_void;
+    #[cfg(not(target_os = "l4re"))]
     pub fn setresgid(rgid: crate::gid_t, egid: crate::gid_t, sgid: crate::gid_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn setresuid(ruid: crate::uid_t, euid: crate::uid_t, suid: crate::uid_t) -> c_int;
     #[cfg_attr(gnu_time_bits64, link_name = "__wait4_time64")]
+    #[cfg(not(target_os = "l4re"))]
     pub fn wait4(
         pid: crate::pid_t,
         status: *mut c_int,
         options: c_int,
         rusage: *mut crate::rusage,
     ) -> crate::pid_t;
+    #[cfg(not(target_os = "l4re"))]
     pub fn login_tty(fd: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn execvpe(
         file: *const c_char,
         argv: *const *mut c_char,
         envp: *const *mut c_char,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn fexecve(fd: c_int, argv: *const *mut c_char, envp: *const *mut c_char) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn getifaddrs(ifap: *mut *mut crate::ifaddrs) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn freeifaddrs(ifa: *mut crate::ifaddrs);
     pub fn bind(
         socket: c_int,
@@ -2093,10 +2540,32 @@ extern "C" {
     #[cfg_attr(gnu_file_offset_bits64, link_name = "mkostemp64")]
     pub fn mkostemp(template: *mut c_char, flags: c_int) -> c_int;
     #[cfg_attr(gnu_file_offset_bits64, link_name = "mkostemps64")]
+    #[cfg(not(target_os = "l4re"))]
     pub fn mkostemps(template: *mut c_char, suffixlen: c_int, flags: c_int) -> c_int;
 
+    #[cfg(not(target_os = "l4re"))]
     pub fn getdomainname(name: *mut c_char, len: size_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn setdomainname(name: *const c_char, len: size_t) -> c_int;
+
+    pub fn if_nameindex() -> *mut if_nameindex;
+    pub fn if_freenameindex(ptr: *mut if_nameindex);
+
+    pub fn getpwuid_r(
+        uid: crate::uid_t,
+        pwd: *mut passwd,
+        buf: *mut c_char,
+        buflen: size_t,
+        result: *mut *mut passwd,
+    ) -> c_int;
+    pub fn getpwnam_r(
+        name: *const c_char,
+        pwd: *mut passwd,
+        buf: *mut c_char,
+        buflen: size_t,
+        result: *mut *mut passwd,
+    ) -> c_int;
+
 }
 
 // LFS64 extensions
@@ -2114,6 +2583,7 @@ cfg_if! {
             #[cfg_attr(gnu_time_bits64, link_name = "__fstat64_time64")]
             pub fn fstat64(fildes: c_int, buf: *mut stat64) -> c_int;
             #[cfg_attr(gnu_time_bits64, link_name = "__fstatat64_time64")]
+            #[cfg(not(target_os = "l4re"))]
             pub fn fstatat64(
                 dirfd: c_int,
                 pathname: *const c_char,
@@ -2123,6 +2593,7 @@ cfg_if! {
             pub fn ftruncate64(fd: c_int, length: off64_t) -> c_int;
             pub fn lseek64(fd: c_int, offset: off64_t, whence: c_int) -> off64_t;
             #[cfg_attr(gnu_time_bits64, link_name = "__lstat64_time64")]
+            #[cfg(not(target_os = "l4re"))]
             pub fn lstat64(path: *const c_char, buf: *mut stat64) -> c_int;
             pub fn mmap64(
                 addr: *mut c_void,
@@ -2154,6 +2625,7 @@ cfg_if! {
                 result: *mut *mut crate::dirent64,
             ) -> c_int;
             #[cfg_attr(gnu_time_bits64, link_name = "__stat64_time64")]
+            #[cfg(not(target_os = "l4re"))]
             pub fn stat64(path: *const c_char, buf: *mut stat64) -> c_int;
             pub fn truncate64(path: *const c_char, length: off64_t) -> c_int;
         }
@@ -2231,9 +2703,13 @@ cfg_if! {
     } else if #[cfg(target_os = "linux")] {
         mod linux;
         pub use self::linux::*;
+        mod linux_l4re_shared;
+        pub use self::linux_l4re_shared::*;
     } else if #[cfg(target_os = "l4re")] {
-        mod linux;
-        pub use self::linux::*;
+        mod l4re;
+        pub use self::l4re::*;
+        mod linux_l4re_shared;
+        pub use self::linux_l4re_shared::*;
     } else if #[cfg(target_os = "android")] {
         mod android;
         pub use self::android::*;
diff --git a/src/unix/mod.rs b/src/unix/mod.rs
index 2a0fd17a1..6af5793c7 100644
--- a/src/unix/mod.rs
+++ b/src/unix/mod.rs
@@ -261,7 +261,7 @@ cfg_if! {
 }
 
 cfg_if! {
-    if #[cfg(not(target_os = "nto"))] {
+    if #[cfg(not(any(target_os = "nto", target_os = "l4re")))] {
         pub const USRQUOTA: c_int = 0;
         pub const GRPQUOTA: c_int = 1;
     }
@@ -984,6 +984,7 @@ extern "C" {
 
     pub fn fchmodat(dirfd: c_int, pathname: *const c_char, mode: mode_t, flags: c_int) -> c_int;
     pub fn fchown(fd: c_int, owner: crate::uid_t, group: crate::gid_t) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn fchownat(
         dirfd: c_int,
         pathname: *const c_char,
@@ -1004,7 +1005,9 @@ extern "C" {
         all(not(gnu_time_bits64), gnu_file_offset_bits64),
         link_name = "fstatat64"
     )]
+    #[cfg(not(target_os = "l4re"))]
     pub fn fstatat(dirfd: c_int, pathname: *const c_char, buf: *mut stat, flags: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn linkat(
         olddirfd: c_int,
         oldpath: *const c_char,
@@ -1012,13 +1015,16 @@ extern "C" {
         newpath: *const c_char,
         flags: c_int,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn renameat(
         olddirfd: c_int,
         oldpath: *const c_char,
         newdirfd: c_int,
         newpath: *const c_char,
     ) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn symlinkat(target: *const c_char, newdirfd: c_int, linkpath: *const c_char) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn unlinkat(dirfd: c_int, pathname: *const c_char, flags: c_int) -> c_int;
 
     pub fn access(path: *const c_char, amode: c_int) -> c_int;
@@ -1425,6 +1431,7 @@ extern "C" {
         link_name = "res_9_init"
     )]
     #[cfg_attr(target_os = "aix", link_name = "_res_init")]
+    #[cfg(not(target_os = "l4re"))]
     pub fn res_init() -> c_int;
 
     #[cfg_attr(target_os = "netbsd", link_name = "__gmtime_r50")]
@@ -1610,9 +1617,13 @@ extern "C" {
     )]
     pub fn nice(incr: c_int) -> c_int;
 
+    #[cfg(not(target_os = "l4re"))]
     pub fn grantpt(fd: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn posix_openpt(flags: c_int) -> c_int;
+    #[cfg(not(target_os = "l4re"))]
     pub fn ptsname(fd: c_int) -> *mut c_char;
+    #[cfg(not(target_os = "l4re"))]
     pub fn unlockpt(fd: c_int) -> c_int;
 
     #[cfg(not(target_os = "aix"))]
@@ -1650,6 +1661,7 @@ cfg_if! {
         target_os = "solaris",
         target_os = "cygwin",
         target_os = "aix",
+        target_os = "l4re",
     )))] {
         extern "C" {
             #[cfg_attr(gnu_time_bits64, link_name = "__adjtime64")]
@@ -1681,6 +1693,7 @@ cfg_if! {
         target_os = "hurd",
         target_os = "macos",
         target_os = "openbsd",
+        target_os = "l4re",
     )))] {
         extern "C" {
             pub fn sigqueue(pid: pid_t, sig: c_int, value: crate::sigval) -> c_int;
@@ -1735,6 +1748,7 @@ cfg_if! {
             )]
             pub fn pause() -> c_int;
 
+            #[cfg(not(target_os = "l4re"))]
             pub fn mkdirat(dirfd: c_int, pathname: *const c_char, mode: mode_t) -> c_int;
             #[cfg_attr(gnu_file_offset_bits64, link_name = "openat64")]
             pub fn openat(dirfd: c_int, pathname: *const c_char, flags: c_int, ...) -> c_int;
@@ -1802,13 +1816,17 @@ cfg_if! {
         }
     } else {
         extern "C" {
+            #[cfg(not(target_os = "l4re"))]
             pub fn readlinkat(
                 dirfd: c_int,
                 pathname: *const c_char,
                 buf: *mut c_char,
                 bufsiz: size_t,
             ) -> ssize_t;
+            #[cfg(not(target_os = "l4re"))]
             pub fn fmemopen(buf: *mut c_void, size: size_t, mode: *const c_char) -> *mut FILE;
+            #[cfg(not(target_os = "l4re"))]
+            #[cfg(not(target_os = "l4re"))]
             pub fn open_memstream(ptr: *mut *mut c_char, sizeloc: *mut size_t) -> *mut FILE;
             pub fn atexit(cb: extern "C" fn()) -> c_int;
             #[cfg_attr(target_os = "netbsd", link_name = "__sigaction14")]
@@ -1863,6 +1881,7 @@ cfg_if! {
         target_os = "nto"
     )))] {
         extern "C" {
+            #[cfg(not(target_os = "l4re"))]
             pub fn cfsetspeed(termios: *mut crate::termios, speed: crate::speed_t) -> c_int;
         }
     }
